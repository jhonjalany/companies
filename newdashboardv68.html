<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-File Excel Uploader - Enhanced with Sorting</title>
    <script src="https://cdn.sheetjs.com/xlsx-0.20.2/package/dist/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.23/jspdf.plugin.autotable.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #1a2a6c);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 90%;
            margin: 0 auto;
            padding: 20px;
        }
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        h1 {
            font-size: 2.8rem;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
            max-width: 700px;
            margin: 0 auto;
        }
        .upload-section {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .upload-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        .file-input-wrapper {
            position: relative;
            width: 100%;
            max-width: 500px;
        }
        .file-input {
            width: 100%;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            color: white;
            font-size: 1.1rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .file-input:hover {
            background: rgba(0, 0, 0, 0.4);
            border-color: rgba(255, 255, 255, 0.5);
        }
        .file-input input {
            display: none;
        }
        .upload-btn {
            background: linear-gradient(to right, #4facfe, #00f2fe);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.2rem;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        .upload-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }
        .upload-btn:active {
            transform: translateY(1px);
        }
        .upload-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        .status {
            margin-top: 15px;
            font-size: 1.1rem;
            min-height: 25px;
        }
        .success {
            color: #7fff00;
        }
        .error {
            color: #ff4d4d;
        }
        .file-list {
            width: 100%;
            max-width: 600px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
            max-height: 200px;
            overflow-y: auto;
        }
        .file-item {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
            margin-bottom: 8px;
            align-items: center;
        }
        .file-item:last-child {
            margin-bottom: 0;
        }
        .file-name {
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            padding-right: 10px;
        }
        .remove-file {
            background: rgba(255, 0, 0, 0.3);
            border: none;
            color: white;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .remove-file:hover {
            background: rgba(255, 0, 0, 0.5);
        }
        .info-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        .info-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .info-card h2 {
            margin-bottom: 15px;
            font-size: 1.5rem;
            color: #4facfe;
        }
        .info-card ul {
            padding-left: 20px;
        }
        .info-card li {
            margin-bottom: 10px;
            line-height: 1.5;
        }
        /* Container for all file data sections */
        .data-section-container {
            display: flex;
            flex-direction: column;
            gap: 30px; /* Space between file sections */
        }
        /* Individual file data section */
        .file-data-section {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative; /* Needed for absolute positioning of delete button */
        }
        .file-data-section h2 {
            margin-bottom: 20px;
            font-size: 1.8rem;
            color: #00f2fe;
            word-break: break-all; /* Handle long filenames */
            padding-right: 40px; /* Make space for the delete button */
        }
        /* --- Add Delete Button Styles --- */
        .delete-section-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 0, 0, 0.3);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.3s ease;
        }
        .delete-section-btn:hover {
            background: rgba(255, 0, 0, 0.5);
        }
        /* --- End Delete Button Styles --- */
        .sheet-tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }
        .sheet-tab {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px 20px;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .sheet-tab.active {
            background: linear-gradient(to right, #4facfe, #00f2fe);
            color: white;
        }
        .sheet-tab:hover:not(.active) {
            background: rgba(0, 0, 0, 0.5);
        }
        .sheet-data {
            overflow-x: auto;
            max-height: 100vh;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 15px;
            display: flex;
            flex-direction: column;
        }
        .table-container {
            overflow-y: auto;
            max-height: 600px;
            flex-grow: 1;
        }
        .table-container table {
            width: 100%;
            border-collapse: collapse;
            min-width: 600px;
        }
        .table-container thead th {
            position: sticky;
            top: 0;
            background: rgba(31, 27, 27, 0.911);
            z-index: 1;
            font-weight: 600;
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
            transition: background 0.3s ease;
        }
        .table-container thead th:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        .table-container thead th.sorted-asc::after {
            content: " â–²";
            color: #4facfe;
        }
        .table-container thead th.sorted-desc::after {
            content: " â–¼";
            color: #4facfe;
        }
        .table-container tbody td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        .table-container tr:nth-child(even) {
            background: rgba(255, 255, 255, 0.05);
        }
        .table-container tr:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        /* Hidden column class */
        .hidden-column {
            display: none;
        }
        /* Column visibility controls */
        .column-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
        }
        .column-control-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 6px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }
        .column-control-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        .column-control-btn.hidden {
            background: rgba(255, 0, 0, 0.3);
            border-color: rgba(255, 0, 0, 0.5);
        }
        .column-control-btn.hidden::after {
            content: " (Hidden)";
            font-size: 0.8em;
            opacity: 0.8;
        }
        .controls {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        .clear-btn {
            background: rgba(255, 0, 0, 0.3);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .clear-btn:hover {
            background: rgba(255, 0, 0, 0.5);
        }
        footer {
            text-align: center;
            margin-top: 30px;
            padding: 20px;
            font-size: 0.9rem;
            opacity: 0.8;
        }
        @media (max-width: 768px) {
            h1 {
                font-size: 2.2rem;
            }
            .upload-section, .info-card, .file-data-section {
                padding: 20px;
            }
            .info-section {
                grid-template-columns: 1fr;
            }
            .controls {
                flex-direction: column;
            }
            /* --- Responsive Delete Button --- */
            .file-data-section h2 {
                 padding-right: 0;
            }
            .delete-section-btn {
                position: relative;
                top: auto;
                right: auto;
                margin-top: 10px;
                align-self: flex-end;
            }
            /* --- End Responsive Delete Button --- */
        }
        /* Search input styling */
        .table-container thead th input {
            width: 100%;
            padding: 5px;
            margin-top: 5px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background-color: rgba(255, 255, 255, 0.1);
            color: white;
        }
        .table-container thead th input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }
        .table-container thead th input:focus {
            outline: none;
            border-color: #4facfe;
            background-color: rgba(255, 255, 255, 0.2);
        }
        .table-stats {
    font-size: 0.9rem;
    opacity: 0.9;
    display: flex;
    justify-content: space-between;
    flex-wrap: wrap;
    gap: 10px;
    margin-top: 15px;
    align-items: center;
}
.pagination-controls button {
    background: rgba(79, 172, 254, 0.3);
    color: white;
    border: 1px solid rgba(255, 255, 255, 0.3);
    padding: 6px 12px;
    border-radius: 5px;
    cursor: pointer;
    margin: 0 5px;
}
.pagination-controls button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}
.pagination-controls button:hover:not(:disabled) {
    background: rgba(79, 172, 254, 0.5);
}
.chart-controls {
    margin: 20px 0 10px;
    padding: 15px;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 8px;
    display: none; /* Hidden by default */
}
.chart-container-wrapper {
    margin-top: 15px;
    position: relative;
    height: 400px;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 8px;
    overflow: hidden;
}
.chart-container {
    height: 100%;
    width: 100%;
}
.chart-actions {
    display: flex;
    gap: 10px;
    margin-top: 10px;
}
.chart-actions select, .chart-actions button {
    padding: 8px;
    border-radius: 5px;
    border: 1px solid rgba(255, 255, 255, 0.3);
    background: rgba(255, 255, 255, 0.1);
    color: white;
}
.chart-actions button {
    background: linear-gradient(to right, #4facfe, #00f2fe);
    cursor: pointer;
    border: none;
}
.chart-actions button:hover {
    opacity: 0.9;
}
.toggle-chart-btn {
    background: rgba(79, 172, 254, 0.3);
    color: white;
    border: 1px solid rgba(255, 255, 255, 0.3);
    padding: 8px 16px;
    border-radius: 5px;
    cursor: pointer;
    margin-top: 10px;
    font-size: 0.9rem;
}
/* === Statistics Panel Styles === */
.stats-panel {
    margin-top: 15px;
    padding: 15px;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 8px;
    font-size: 0.95rem;
    line-height: 1.6;
    display: none; /* Hidden by default */
}
.stats-panel h3 {
    margin-bottom: 10px;
    color: #00f2fe;
    font-size: 1.1rem;
}
.stats-toggle-btn {
    background: rgba(79, 172, 254, 0.3);
    color: white;
    border: 1px solid rgba(255, 255, 255, 0.3);
    padding: 8px 16px;
    border-radius: 5px;
    cursor: pointer;
    margin-top: 10px;
    font-size: 0.9rem;
}
.stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 10px;
}
.stat-item {
    background: rgba(255, 255, 255, 0.05);
    padding: 8px;
    border-radius: 5px;
    white-space: nowrap;
}
.stat-label {
    font-weight: 600;
    opacity: 0.9;
}
.stat-value {
    color: #7fff00;
}
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Multi-File Excel Uploader</h1>
            <p class="subtitle">Upload multiple Excel, CSV, or spreadsheet files to view and manage sheet data in real-time</p>
        </header>
        <section class="upload-section">
            <div class="upload-container">
                <div class="file-input-wrapper">
                    <div class="file-input" id="dropZone">
                        <span id="fileText">Drag & drop files here or click to browse</span>
                        <input type="file" id="fileInput" accept=".xlsx,.xls,.csv" multiple>
                    </div>
                </div>
                <!-- Add this new section in the upload-container, right after the file input wrapper -->
                <div class="url-input-wrapper" style="width: 100%; max-width: 500px; margin: 20px 0;">
                    <div style="display: flex; gap: 10px;">
                        <input 
                            type="text" 
                            id="urlInput" 
                            placeholder="Paste Google Sheets or Excel URL here"
                            style="flex: 1; padding: 15px; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 10px; color: white; font-size: 1.1rem;"
                        >
                        <button id="loadUrlBtn" style="background: linear-gradient(to right, #4facfe, #00f2fe); color: white; border: none; padding: 15px 20px; font-size: 1.1rem; border-radius: 10px; cursor: pointer;">Load</button>
                    </div>
                    <p style="margin-top: 10px; font-size: 0.9rem; opacity: 0.8;">Supports Google Sheets links and direct Excel file URLs</p>
                </div>
                <button class="upload-btn" id="uploadBtn" disabled>Process Files</button>
                <div class="status" id="status"></div>
                <div class="file-list" id="fileList"></div>
            </div>
        </section>
        <section class="info-section">
            <div class="info-card">
                <h2>Supported File Types</h2>
                <ul>
                    <li>Excel files (.xlsx, .xls)</li>
                    <li>CSV files (.csv)</li>
                    <li>OpenDocument spreadsheets (.ods)</li>
                    <li>Tab-separated values (.tsv)</li>
                </ul>
            </div>
            <div class="info-card">
                <h2>Features</h2>
                <ul>
                    <li>Upload multiple files at once</li>
                    <li>Handles large files efficiently</li>
                    <li>Clears previous data when needed</li>
                    <li>Displays data from all sheets</li>
                    <li>Responsive design for all devices</li>
                    <li><strong>Preserves original date/time formatting</strong></li>
                    <li><strong>Hide and unhide columns for each sheet individually</strong></li>
                    <li><strong>Sort data by any column (text, numbers, dates)</strong></li>
                    <li>Advanced search with multiple conditions</li>
                </ul>
            </div>
        </section>
        <!-- Template for individual file data sections -->
        <template id="fileDataSectionTemplate">
            <section class="file-data-section">
                <h2 class="file-title"></h2>
                <button class="delete-section-btn">Delete File Data</button>
                <div class="sheet-tabs"></div>
                <div class="sheet-data">
                    <div class="column-controls" id="columnControls"></div>
                    <div class="table-container">
                        <table>
                            <thead></thead>
                            <tbody></tbody>
                        </table>
                    </div>
                    <div class="no-data">No data available for this file.</div>
                    <div class="table-stats" style="margin-top: 15px; font-size: 0.9rem; opacity: 0.9; display: flex; justify-content: space-between; flex-wrap: wrap;">
                        <div class="row-count">Rows: 0</div>
                        <div class="pagination-controls">
                            <button class="prev-page" disabled>â—€ Previous</button>
                            <span class="page-info">Page 1</span>
                            <button class="next-page">Next â–¶</button>
                        </div>
                    </div>
                    <div class="stats-panel">
                        <h3>Data Statistics</h3>
                        <div class="stats-grid" id="statsGrid"></div>
                    </div>
                    <button class="stats-toggle-btn">Show Statistics</button>
                </div>
            </section>
        </template>
        <!-- Container for dynamically created file data sections -->
        <div class="data-section-container" id="dataSectionContainer"></div>
        <div class="controls">
            <button class="clear-btn" id="clearAllBtn">Clear All Data</button>
        </div>
        <footer>
            <p>Multi-File Excel Uploader &copy; 2023 | All data is processed locally in your browser</p>
        </footer>
    </div>
    <script>
    // DOM elements
    const fileInput = document.getElementById('fileInput');
    const dropZone = document.getElementById('dropZone');
    const fileText = document.getElementById('fileText');
    const uploadBtn = document.getElementById('uploadBtn');
    const statusDiv = document.getElementById('status');
    const fileList = document.getElementById('fileList');
    const dataSectionContainer = document.getElementById('dataSectionContainer');
    const clearAllBtn = document.getElementById('clearAllBtn');
    const fileDataSectionTemplate = document.getElementById('fileDataSectionTemplate');
    const urlInput = document.getElementById('urlInput');
    const loadUrlBtn = document.getElementById('loadUrlBtn');
    // Track hidden columns for each file and sheet
    let hidden = {};
    
    // Track sorting state for each column
    let sortingState = {};

    


    async function detectDateTimeFormats(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = function (e) {
            try {
                const data = new Uint8Array(e.target.result);
                const workbook = XLSX.read(data, { type: 'array', cellDates: false, cellNF: true, cellText: true });
                const dateTimeInfo = {};

                // Predefined regex patterns for common date/time strings
                const dateRegexes = [
                    /\b\d{4}-\d{1,2}-\d{1,2}\s*\d{1,2}:\d{2}(:\d{2})?\s*(Z|[+-]\d{2}:\d{2})?/, // ISO: 2024-05-20 14:30
                    /\b\d{1,2}[/\-\.]\d{1,2}[/\-\.]\d{2,4}\b/, // MM/DD/YYYY, DD/MM/YY
                    /\b(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\b.*\d{1,2},?.*\d{2,4}/i, // Jan 1, 2024
                    /\b\d{1,2}\s+(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\b\s+\d{2,4}/i, // 5 Jan 2024
                    /\b\d{1,2}:\d{2}(:\d{2})?\s*(AM|PM)?\b/i, // 10:30 or 10:30 PM
                    /\b\d{4}-\d{2}-\d{2}\b/, // YYYY-MM-DD
                    /\b\d{1,2}-\d{1,2}-\d{4}\b/, // DD-MM-YYYY
                    /\b\d{8,}\b/ // Unix timestamps (8+ digits)
                ];

                // Helper: test if a string matches any date pattern
                function isDateContent(str) {
                    if (typeof str !== 'string' || !str.trim()) return false;
                    return dateRegexes.some(regex => regex.test(str.trim()));
                }

                workbook.SheetNames.forEach(sheetName => {
                    const worksheet = workbook.Sheets[sheetName];
                    const dateColumns = new Set();
                    const timeColumns = new Set();
                    const potentialDateColumns = new Map(); // Track likelihood

                    const range = XLSX.utils.decode_range(worksheet['!ref']);
                    let sampleCount = 0;
                    const maxRowsToSample = 100; // Limit for performance

                    for (let R = range.s.r; R <= range.e.r && sampleCount < maxRowsToSample; ++R) {
                        sampleCount++;
                        for (let C = range.s.c; C <= range.e.c; ++C) {
                            const cellAddress = XLSX.utils.encode_cell({ r: R, c: C });
                            const cell = worksheet[cellAddress];
                            if (!cell) continue;

                            let isDateByFormat = false;
                            let isTimeByFormat = false;
                            let isDateByContent = false;

                            // 1. Format-based detection (Excel only)
                            if (cell.z && typeof cell.z === 'string') {
                                const format = cell.z.toLowerCase();
                                if (
                                    format.includes('yy') ||
                                    format.includes('yyyy') ||
                                    format.includes('mm') ||
                                    format.includes('mmm') ||
                                    format.includes('dd') ||
                                    format.includes('d') ||
                                    format.includes('date') ||
                                    /\[(h|m|s)\]/.test(format) ||
                                    (format.includes(':') && (format.includes('h') || format.includes('m') || format.includes('s')))
                                ) {
                                    if (format.includes(':') || /\[(h|m|s)\]/.test(format)) {
                                        isTimeByFormat = true;
                                    } else {
                                        isDateByFormat = true;
                                    }
                                }
                            }

                            // 2. Content-based detection (works for CSV & formatted cells)
                            const cellText = cell.w || String(cell.v) || '';
                            if (isDateContent(cellText)) {
                                isDateByContent = true;
                            }

                            // Only count if either format OR content suggests date
                            if (isDateByFormat || isDateByContent) {
                                const score = (potentialDateColumns.get(C) || 0) + 1;
                                potentialDateColumns.set(C, score);
                            }
                            if (isTimeByFormat) {
                                timeColumns.add(C);
                            }
                        }
                    }

                    // Promote columns with sufficient "date-like" cells
                    for (const [col, score] of potentialDateColumns) {
                        if (score >= 3 || score / sampleCount > 0.1) { // At least 3 hits or 10% of rows
                            dateColumns.add(parseInt(col));
                        }
                    }

                    // Finalize
                    dateTimeInfo[sheetName] = {
                        dateColumns: Array.from(dateColumns),
                        timeColumns: Array.from(timeColumns)
                    };
                });

                resolve(dateTimeInfo);
            } catch (error) {
                reject(error);
            }
        };
        reader.onerror = () => reject(new Error("Failed to read file"));
        reader.readAsArrayBuffer(file);
    });
}

    // --- NEW: Reusable Delete Function ---
    function deleteFileSection(sectionElement) {
        const sectionToDelete = sectionElement || this.closest('.file-data-section');
        if (!sectionToDelete) return;
        const fileTitleElement = sectionToDelete.querySelector('.file-title');
        const fileName = fileTitleElement ? fileTitleElement.textContent.replace('Data from: ', '') : 'this file';
        const userConfirmed = confirm(`Are you sure you want to delete the data for "${fileName}"?`);
        if (userConfirmed) {
            if (sectionToDelete.fileName) {
                delete hidden[sectionToDelete.fileName];
                delete sortingState[sectionToDelete.fileName];
            }
            sectionToDelete.fileDataArrayBuffer = null;
            sectionToDelete.dateTimeInfo = null;
            sectionToDelete.remove();
            showStatus(`Data for "${fileName}" deleted.`, 'success');
        }
    }
    

    // === DYNAMIC PIVOT TABLE ANALYZER ===
function setupPivotAnalyzer(fileDataSection, headers, tableBody) {
    const sheetData = fileDataSection.querySelector('.sheet-data');

    // Create pivot toggle button
    const togglePivotBtn = document.createElement('button');
    togglePivotBtn.className = 'toggle-pivot-btn';
    togglePivotBtn.textContent = 'ðŸ“Š Pivot Analyzer';
    togglePivotBtn.style.cssText = `
        background: rgba(100, 200, 100, 0.3);
        color: white;
        border: 1px solid rgba(255, 255, 255, 0.3);
        padding: 8px 12px;
        border-radius: 5px;
        cursor: pointer;
        margin-top: 10px;
        display: none; /* Show only after data loads */
    `;

    // Create pivot container
    const pivotContainer = document.createElement('div');
    pivotContainer.className = 'pivot-container';
    pivotContainer.style.cssText = `
        display: none;
        margin-top: 15px;
        padding: 15px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 8px;
        overflow: auto;
        max-height: 500px;
    `;
    pivotContainer.innerHTML = `<p>Loading pivot controls...</p>`;

    // Insert into DOM
    sheetData.parentNode.insertBefore(togglePivotBtn, sheetData.nextSibling);
    sheetData.parentNode.insertBefore(pivotContainer, togglePivotBtn.nextSibling);

    // Show pivot button after data loads
    setTimeout(() => {
        togglePivotBtn.style.display = 'inline-block';
    }, 100);

    togglePivotBtn.addEventListener('click', () => {
    const isHidden = pivotContainer.style.display === 'none';
    pivotContainer.style.display = isHidden ? 'block' : 'none';
    togglePivotBtn.textContent = isHidden ? 'âŒ Close Pivot' : 'ðŸ“Š Pivot Analyzer';

    if (isHidden) {
        // Get current headers from the active table header
        const table = fileDataSection.querySelector('table');
        const tableHeader = table.querySelector('thead');
        const headers = Array.from(tableHeader.querySelectorAll('th'))
                             .map(th => th.textContent.trim());

        // Now safely call renderPivotControls with all required args
        renderPivotControls(headers, pivotContainer, fileDataSection, table.querySelector('tbody'));
    }
});

    function renderPivotControls(headers, pivotContainer, fileDataSection, tableBody) {
    // Clear loading message
    pivotContainer.innerHTML = '';

    const fields = ['(None)'].concat(headers);
    pivotContainer.innerHTML = `
  <h4 style="margin-bottom: 10px; color: #4facfe;">ðŸ“Š Pivot Table Builder</h4>
  <div style="display: grid; gap: 10px; grid-template-columns: 1fr 1fr;">
    <!-- Row, Column, Value Fields -->
    <div><label>Row Field:</label>
      <select class="pivot-row-field" style="width: 100%; padding: 6px; border-radius: 4px; background: rgba(255,255,255,0.1); color: #88888;">${fields.map(f => `<option value="${f}">${f}</option>`).join('')}</select>
    </div>
    <div><label>Column Field (Optional):</label>
      <select class="pivot-col-field" style="width: 100%; padding: 6px; border-radius: 4px; background: rgba(255,255,255,0.1); color: #88888;">${fields.map(f => `<option value="${f}">${f}</option>`).join('')}</select>
    </div>
    <div><label>Value Field:</label>
      <select class="pivot-value-field" style="width: 100%; padding: 6px; border-radius: 4px; background: rgba(255,255,255,0.1); color: #88888;">${fields.map(f => `<option value="${f}">${f}</option>`).join('')}</select>
    </div>
    <div><label>Aggregations:</label>
      <div class="pivot-aggregations" style="display: flex; flex-direction: column; gap: 6px; margin-top: 4px;">
        <label style="font-size: 0.9rem;"><input type="checkbox" value="count" checked> Count</label>
        <label style="font-size: 0.9rem;"><input type="checkbox" value="sum" checked> Sum</label>
        <label style="font-size: 0.9rem;"><input type="checkbox" value="avg"> Average</label>
        <label style="font-size: 0.9rem;"><input type="checkbox" value="min"> Min</label>
        <label style="font-size: 0.9rem;"><input type="checkbox" value="max"> Max</label>
      </div>
    </div>
  </div>
  <button class="apply-pivot" style="background: #4facfe; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; margin-top: 10px;">Generate Pivot</button>

  <!-- Export Buttons -->
  <div class="pivot-export-controls" style="margin-top: 10px; display: flex; gap: 10px;">
    <button class="export-pivot-csv" style="background: #28a745; color: white; border: none; padding: 6px 10px; border-radius: 4px; cursor: pointer; font-size: 0.9rem;">ðŸ“¥ Export as CSV</button>
    <button class="export-pivot-pdf" style="background: #dc3545; color: white; border: none; padding: 6px 10px; border-radius: 4px; cursor: pointer; font-size: 0.9rem;">ðŸ“„ Export as Editable PDF</button>
  </div>

  <!-- Pivot Output -->
  <div class="pivot-output" style="margin-top: 15px; overflow: auto;"></div>
`;

    // Reattach event listeners
pivotContainer.querySelector('.apply-pivot').addEventListener('click', () => {
    generatePivotTable(headers, pivotContainer, fileDataSection, tableBody);
});

// === Attach Export Handlers for Pivot Table ===
const exportCsvBtn = pivotContainer.querySelector('.export-pivot-csv');
const exportPdfBtn = pivotContainer.querySelector('.export-pivot-pdf');

// === Export Pivot as CSV ===
exportCsvBtn?.addEventListener('click', () => {
    const outputDiv = pivotContainer.querySelector('.pivot-output');
    const table = outputDiv?.querySelector('table');
    if (!table) {
        showStatus('No pivot table to export.', 'error');
        return;
    }

    let csv = '';
    
    // Extract and clean headers
    const headerRow = table.querySelector('thead tr');
    const rawHeaders = Array.from(headerRow.querySelectorAll('th')).map(th => th.textContent.trim());
    const cleanedHeaders = rawHeaders.map(cleanHeaderName);
    csv += cleanedHeaders.join(',') + '\n';

    // Extract data rows
    const rows = table.querySelectorAll('tbody tr');
    rows.forEach(row => {
        const cells = row.querySelectorAll('td');
        const rowData = Array.from(cells).map(td => {
            let cellText = td.textContent.trim();
            // Escape commas and wrap in quotes if needed
            if (cellText.includes(',') || cellText.includes('"')) {
                cellText = `"${cellText.replace(/"/g, '""')}"`;
            }
            return cellText;
        });
        csv += rowData.join(',') + '\n';
    });

    // Trigger download
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.setAttribute('href', url);
    link.setAttribute('download', `pivot_export_${new Date().toISOString().slice(0,10)}.csv`);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
    showStatus('Pivot table exported as CSV successfully.', 'success');
});

// === Export Pivot as Editable PDF ===
exportPdfBtn?.addEventListener('click', () => {
    const outputDiv = pivotContainer.querySelector('.pivot-output');
    const table = outputDiv?.querySelector('table');
    if (!table) {
        showStatus('No pivot table to export.', 'error');
        return;
    }

    if (typeof window.jspdf === 'undefined') {
        alert('jsPDF library not loaded. Cannot export to PDF.');
        return;
    }
    const { jsPDF } = window.jspdf;

    // Extract and clean headers
    const rawHeaders = Array.from(table.querySelectorAll('thead th')).map(th => th.textContent.trim());
    const cleanedHeaders = rawHeaders.map(cleanHeaderName);

    const rows = [];
    table.querySelectorAll('tbody tr').forEach(tr => {
        const cells = Array.from(tr.querySelectorAll('td')).map(td => td.textContent.trim());
        rows.push(cells);
    });

    const pdf = new jsPDF('l', 'mm', 'a4');
    pdf.autoTable({
        head: [cleanedHeaders],  // Use cleaned headers
        body: rows,
        startY: 20,
        theme: 'striped',
        styles: { fontSize: 10, cellPadding: 3 },
        headStyles: { fillColor: [79, 172, 254], textColor: [255, 255, 255] },
        margin: { top: 15 }
    });

    pdf.setFontSize(16);
    pdf.text('Pivot Table Export', 14, 15);
    pdf.save(`pivot_export_${new Date().toISOString().slice(0,10)}.pdf`);
    showStatus('Pivot table exported as PDF successfully.', 'success');
});

// Update on any change: row, col, value, or aggregation checkbox
[rowSelect, colSelect, valSelect].forEach(sel => {
    sel.addEventListener('change', () => {
        generatePivotTable(headers, pivotContainer, fileDataSection, tableBody);
    });
});

// Add event listeners to aggregation checkboxes
pivotContainer.querySelectorAll('.pivot-aggregations input').forEach(cb => {
    cb.addEventListener('change', () => {
        generatePivotTable(headers, pivotContainer, fileDataSection, tableBody);
    });
});

    // Set default values safely
    const rowSelect = pivotContainer.querySelector('.pivot-row-field');
    const colSelect = pivotContainer.querySelector('.pivot-col-field');
    const valSelect = pivotContainer.querySelector('.pivot-value-field');

    rowSelect.value = fields[1] || '(None)';
    colSelect.value = '(None)';
    valSelect.value = fields[1] || '(None)';

    // Reattach event listeners
    pivotContainer.querySelector('.apply-pivot').addEventListener('click', () => {
        generatePivotTable(headers, pivotContainer, fileDataSection, tableBody);
    });

    [rowSelect, colSelect, valSelect].forEach(sel => {
        sel.addEventListener('change', () => {
            generatePivotTable(headers, pivotContainer, fileDataSection, tableBody);
        });
    });

    pivotContainer.querySelector('.pivot-aggregate').addEventListener('change', () => {
        generatePivotTable(headers, pivotContainer, fileDataSection, tableBody);
    });
}

function generatePivotTable(headers, pivotContainer, fileDataSection, tableBody) {
    const rowField = pivotContainer.querySelector('.pivot-row-field').value;
    const colField = pivotContainer.querySelector('.pivot-col-field').value;
    const valueField = pivotContainer.querySelector('.pivot-value-field').value;
    const aggregations = Array.from(pivotContainer.querySelectorAll('.pivot-aggregations input:checked')).map(cb => cb.value);

    if (rowField === '(None)' || valueField === '(None)' || aggregations.length === 0) {
        pivotContainer.querySelector('.pivot-output').innerHTML =
            '<p style="color: yellow;">Select Row, Value fields, and at least one aggregation.</p>';
        return;
    }

    const dataRows = fileDataSection.filteredRows?.length > 0
        ? fileDataSection.filteredRows
        : Array.from(tableBody.querySelectorAll('tr'));

    // Build pivot map: { rowKey: { colKey: { count, sum, values } } }
    const pivotMap = {};
    const columnKeys = new Set();
    const hasColField = colField !== '(None)';

    dataRows.forEach(rowEl => {
        const tds = rowEl.querySelectorAll('td');
        const rowData = {};
        headers.forEach((h, idx) => {
            rowData[h] = tds[idx]?.textContent.trim() || '';
        });

        const rowKey = rowData[rowField];
        const colKey = hasColField ? (rowData[colField] || '(Blank)') : 'Total';
        const valText = rowData[valueField];
        let valNum = parseFloat(valText.replace(/[$,%]/g, ''));
        if (isNaN(valNum)) valNum = 0;

        if (!pivotMap[rowKey]) pivotMap[rowKey] = {};
        if (!pivotMap[rowKey][colKey]) {
            pivotMap[rowKey][colKey] = { count: 0, sum: 0, values: [] };
        }

        const cell = pivotMap[rowKey][colKey];
        cell.count++;
        cell.sum += valNum;
        cell.values.push(valNum);

        columnKeys.add(colKey);
    });

    // Sort column keys and define aggregation pairs
    const sortedColKeys = hasColField ? [...columnKeys].sort() : ['Total'];
    const colAggPairs = [];
    sortedColKeys.forEach(colKey => {
        aggregations.forEach(agg => {
            colAggPairs.push({ colKey, agg });
        });
    });

    // === NEW: Add Total column for each aggregation ===
    aggregations.forEach(agg => {
        colAggPairs.push({ colKey: 'Total', agg, isTotal: true });
    });

    // Convert pivotMap to array for sorting
    const pivotRows = Object.keys(pivotMap).map(rowKey => {
        const rowData = { rowKey, cells: [] };

        colAggPairs.forEach(({ colKey, agg, isTotal }) => {
            let displayValue = '0.00';

            if (isTotal) {
                // Compute total across all columns for this row
                let totalSum = 0, totalCount = 0, allValues = [];

                Object.values(pivotMap[rowKey]).forEach(cell => {
                    totalSum += cell.sum;
                    totalCount += cell.count;
                    allValues = allValues.concat(cell.values);
                });

                switch (agg) {
                    case 'sum': displayValue = totalSum.toFixed(2); break;
                    case 'count': displayValue = totalCount; break;
                    case 'avg': displayValue = (totalCount ? (totalSum / totalCount).toFixed(2) : '0.00'); break;
                    case 'min': displayValue = allValues.length ? Math.min(...allValues).toFixed(2) : '0.00'; break;
                    case 'max': displayValue = allValues.length ? Math.max(...allValues).toFixed(2) : '0.00'; break;
                    default: displayValue = '0.00';
                }
            } else {
                const cell = pivotMap[rowKey][colKey];
                if (cell) {
                    switch (agg) {
                        case 'sum': displayValue = cell.sum.toFixed(2); break;
                        case 'count': displayValue = cell.count; break;
                        case 'avg': displayValue = (cell.count ? (cell.sum / cell.count).toFixed(2) : '0.00'); break;
                        case 'min': displayValue = Math.min(...cell.values).toFixed(2); break;
                        case 'max': displayValue = Math.max(...cell.values).toFixed(2); break;
                        default: displayValue = '0.00';
                    }
                }
            }

            rowData.cells.push(displayValue);
        });

        return rowData;
    });

    // Initialize sort state if not present
    if (!fileDataSection.pivotSortState) {
        fileDataSection.pivotSortState = { columnIndex: 0, direction: 'asc' };
    }

    // Sort the pivot rows
    const sortIndex = fileDataSection.pivotSortState.columnIndex;
    const sortDirection = fileDataSection.pivotSortState.direction;

    pivotRows.sort((a, b) => {
        let valueA, valueB;

        if (sortIndex === 0) {
            valueA = a.rowKey || '';
            valueB = b.rowKey || '';
            return sortDirection === 'asc'
                ? valueA.localeCompare(valueB)
                : valueB.localeCompare(valueA);
        } else {
            const pairIndex = sortIndex - 1;
            if (pairIndex < colAggPairs.length) {
                valueA = parseFloat(a.cells[pairIndex]) || 0;
                valueB = parseFloat(b.cells[pairIndex]) || 0;
                return sortDirection === 'asc' ? valueA - valueB : valueB - valueA;
            }
        }
        return 0;
    });

    // Pagination
    const rowsPerPage = parseInt(pivotContainer.querySelector('.pivot-rows-per-page')?.value) || 10;
    const currentPage = parseInt(pivotContainer.dataset.currentPage) || 1;
    const totalPivotRowCount = pivotRows.length;
    const totalPages = Math.ceil(totalPivotRowCount / rowsPerPage);
    const startIndex = (currentPage - 1) * rowsPerPage;
    const paginatedRows = pivotRows.slice(startIndex, startIndex + rowsPerPage);

    // Generate table HTML
    let tableHTML = `<div style="margin-bottom: 10px; font-size: 0.9em; opacity: 0.9;">
        <strong>Grouped Rows:</strong> ${totalPivotRowCount} |
        <strong>Page:</strong> ${currentPage} of ${totalPages || 1}
    </div>`;

    tableHTML += `<table style="width: 100%; border-collapse: collapse;"><thead><tr>
        <th style="padding: 6px; border: 1px solid #333; background: #1a2a6c; color: #4facfe; cursor: pointer;" data-sort-index="0">
            ${rowField}
            <span class="sort-indicator">
                ${fileDataSection.pivotSortState.columnIndex === 0 && fileDataSection.pivotSortState.direction === 'asc' ? 'â–²' :
                  fileDataSection.pivotSortState.columnIndex === 0 && fileDataSection.pivotSortState.direction === 'desc' ? 'â–¼' : ''}
            </span>
        </th>`;

    colAggPairs.forEach(({ colKey, agg, isTotal }, index) => {
        const sortIndex = index + 1;
        const aggLabel = agg === 'count' ? 'Count' :
                         agg === 'sum' ? 'Sum' :
                         agg === 'avg' ? 'Avg' :
                         agg === 'min' ? 'Min' : 'Max';

        const thStyle = `style="padding: 6px; border: 1px solid #333; background: #1a2a6c; color: #4facfe; cursor: pointer;"`;
        const displayColKey = isTotal ? 'Total' : (colKey === 'Total' ? '' : colKey);

        tableHTML += `<th ${thStyle} data-sort-index="${sortIndex}">
            ${displayColKey} ${aggLabel}
            <span class="sort-indicator">
                ${fileDataSection.pivotSortState.columnIndex === sortIndex && fileDataSection.pivotSortState.direction === 'asc' ? 'â–²' :
                  fileDataSection.pivotSortState.columnIndex === sortIndex && fileDataSection.pivotSortState.direction === 'desc' ? 'â–¼' : ''}
            </span>
        </th>`;
    });

    tableHTML += `</tr></thead><tbody>`;

    paginatedRows.forEach(rowData => {
        tableHTML += `<tr><td style="padding: 6px; border: 1px solid #ddd;">${rowData.rowKey}</td>`;
        rowData.cells.forEach(cell => {
            tableHTML += `<td style="padding: 6px; border: 1px solid #ddd; text-align: right;">${cell}</td>`;
        });
        tableHTML += `</tr>`;
    });

    // Add totals row (overall grand totals)
    if (aggregations.some(a => ['sum', 'count', 'avg'].includes(a))) {
        tableHTML += `<tr style="font-weight: bold; background: #2a3a5a; color: white;">
            <td style="padding: 6px;">Total</td>`;

        colAggPairs.forEach(({ colKey, agg, isTotal }) => {
            let total = 0;
            let totalCount = 0;

            if (isTotal) {
                // Total of totals per row â€” we already computed per-row totals, now sum across rows
                pivotRows.forEach(r => {
                    const val = parseFloat(r.cells[colAggPairs.findIndex(p => p.colKey === colKey && p.agg === agg && p.isTotal)] || 0);
                    total += isNaN(val) ? 0 : val;
                });
                displayValue = agg === 'count' ? total : total.toFixed(2);
            } else {
                // Aggregate across all row keys for this column+agg
                Object.values(pivotMap).forEach(row => {
                    const cell = row[colKey];
                    if (cell) {
                        if (agg === 'sum') total += cell.sum;
                        else if (agg === 'count') total += cell.count;
                        else if (agg === 'avg') { total += cell.sum; totalCount += cell.count; }
                    }
                });
                const displayValue = agg === 'avg' && totalCount ? (total / totalCount).toFixed(2) : total.toFixed(2);
                tableHTML += `<td style="padding: 6px; text-align: right;">${displayValue}</td>`;
                return;
            }

            tableHTML += `<td style="padding: 6px; text-align: right;">${displayValue}</td>`;
        });

        tableHTML += `</tr>`;
    }

    tableHTML += `</tbody></table>`;

    // Pagination controls
    const paginationHTML = `
        <div style="margin-top: 10px; display: flex; justify-content: space-between; align-items: center;">
            <select class="pivot-rows-per-page" style="padding: 4px; border-radius: 4px;">
                <option value="10" ${rowsPerPage === 10 ? 'selected' : ''}>10 rows</option>
                <option value="25" ${rowsPerPage === 25 ? 'selected' : ''}>25 rows</option>
                <option value="50" ${rowsPerPage === 50 ? 'selected' : ''}>50 rows</option>
                <option value="100" ${rowsPerPage === 100 ? 'selected' : ''}>100 rows</option>
            </select>
            <div>
                <button class="pivot-prev-page" ${currentPage <= 1 ? 'disabled' : ''} style="padding: 4px 8px;">â—€ Prev</button>
                <button class="pivot-next-page" ${currentPage >= totalPages ? 'disabled' : ''} style="margin-left: 5px; padding: 4px 8px;">Next â–¶</button>
            </div>
        </div>`;

    const outputContainer = pivotContainer.querySelector('.pivot-output');
    outputContainer.innerHTML = tableHTML + paginationHTML;

    // Reattach event listeners
    const prevBtn = outputContainer.querySelector('.pivot-prev-page');
    const nextBtn = outputContainer.querySelector('.pivot-next-page');
    const rowsSelect = outputContainer.querySelector('.pivot-rows-per-page');

    prevBtn?.addEventListener('click', () => {
        if (currentPage > 1) {
            pivotContainer.dataset.currentPage = currentPage - 1;
            generatePivotTable(headers, pivotContainer, fileDataSection, tableBody);
        }
    });

    nextBtn?.addEventListener('click', () => {
        if (currentPage < totalPages) {
            pivotContainer.dataset.currentPage = parseInt(pivotContainer.dataset.currentPage) + 1;
            generatePivotTable(headers, pivotContainer, fileDataSection, tableBody);
        }
    });

    rowsSelect?.addEventListener('change', () => {
        pivotContainer.dataset.currentPage = 1;
        generatePivotTable(headers, pivotContainer, fileDataSection, tableBody);
    });

    // Reattach sort listeners
    outputContainer.querySelectorAll('th[data-sort-index]').forEach(th => {
        th.addEventListener('click', function () {
            const columnIndex = parseInt(this.getAttribute('data-sort-index'));
            const currentState = fileDataSection.pivotSortState;

            if (currentState.columnIndex === columnIndex) {
                currentState.direction = currentState.direction === 'asc' ? 'desc' : 'asc';
            } else {
                currentState.columnIndex = columnIndex;
                currentState.direction = 'asc';
            }

            generatePivotTable(headers, pivotContainer, fileDataSection, tableBody);
        });
    });
}

}

function cleanHeaderName(header) {
    if (!header) return 'Column';
    return header
        .trim()                          // Remove leading/trailing whitespace
        .replace(/[^a-zA-Z0-9\s_]/g, '') // Remove all non-alphanumeric except spaces and underscores
        .replace(/\s+/g, '_')            // Replace spaces with underscores
        .replace(/_+/g, '_')             // Replace multiple underscores with single
        .replace(/^_|_$/g, '');          // Remove leading/trailing underscores
}

    // Initialize the application
    function init() {
        setupEventListeners();
        setupUrlEventListener(); // Add this line
        
        
   }
    
    function setupEventListeners() {
        fileInput.addEventListener('change', handleFileSelect);
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.style.borderColor = '#4facfe';
            dropZone.style.backgroundColor = 'rgba(0, 0, 0, 0.4)';
        });
        dropZone.addEventListener('dragleave', () => {
            dropZone.style.borderColor = 'rgba(255, 255, 255, 0.3)';
            dropZone.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';
        });
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.style.borderColor = 'rgba(255, 255, 255, 0.3)';
            dropZone.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';
            if (e.dataTransfer.files.length) {
                fileInput.files = e.dataTransfer.files;
                handleFileSelect();
            }
        });
        uploadBtn.addEventListener('click', processFiles);
        clearAllBtn.addEventListener('click', clearAllData);
    }
    
    function handleFileSelect() {
        const files = fileInput.files;
        if (files.length > 0) {
            fileText.textContent = `${files.length} file(s) selected`;
            uploadBtn.disabled = false;
            statusDiv.textContent = '';
            statusDiv.className = 'status';
            updateFileList();
        } else {
            fileText.textContent = 'Drag & drop files here or click to browse';
            uploadBtn.disabled = true;
            fileList.innerHTML = '';
        }
    }
    
    function updateFileList() {
        fileList.innerHTML = '';
        Array.from(fileInput.files).forEach((file, index) => {
            const fileItem = document.createElement('div');
            fileItem.className = 'file-item';
            const fileName = document.createElement('div');
            fileName.className = 'file-name';
            fileName.textContent = file.name;
            const removeBtn = document.createElement('button');
            removeBtn.className = 'remove-file';
            removeBtn.innerHTML = '&times;';
            removeBtn.addEventListener('click', () => removeFile(index));
            fileItem.appendChild(fileName);
            fileItem.appendChild(removeBtn);
            fileList.appendChild(fileItem);
        });
    }
    
    function removeFile(index) {
        const dt = new DataTransfer();
        const files = fileInput.files;
        for (let i = 0; i < files.length; i++) {
            if (i !== index) {
                dt.items.add(files[i]);
            }
        }
        fileInput.files = dt.files;
        handleFileSelect();
    }
    
    function processFiles() {
        const files = fileInput.files;
        if (files.length === 0) return;
        showStatus('Processing files...', 'success');
        uploadBtn.disabled = true;
        processFileBatch(Array.from(files), 0);
        
    }
    
    async function processFileBatch(files, index) {
        if (index >= files.length) {
            showStatus(`Processed ${files.length} files successfully!`, 'success');
            uploadBtn.disabled = false;
            return;
        }
        const file = files[index];
        try {
            showStatus(`Analyzing formats for ${file.name}...`, 'success');
            const dateTimeInfo = await detectDateTimeFormats(file);
            console.log(`Date/Time Info for ${file.name}:`, dateTimeInfo);
            const reader = new FileReader();
            reader.onload = async function(e) {
                try {
                    const arrayBuffer = e.target.result;
                    const fileDataSectionFragment = fileDataSectionTemplate.content.cloneNode(true);
                    const fileDataSection = fileDataSectionFragment.querySelector('.file-data-section');
                    fileDataSection.fileName = file.name;
                    fileDataSection.dateTimeInfo = dateTimeInfo;
                    const deleteBtn = fileDataSection.querySelector('.delete-section-btn');
                    deleteBtn.addEventListener('click', () => deleteFileSection(fileDataSection));
                    const fileTitle = fileDataSection.querySelector('.file-title');
                    fileTitle.textContent = `Data from: ${file.name}`;
                    
                    const sheetTabsContainer = fileDataSection.querySelector('.sheet-tabs');
                    const table = fileDataSection.querySelector('table');
                    const tableHeader = table.querySelector('thead');
                    const tableBody = table.querySelector('tbody');
                    const noDataMessage = fileDataSection.querySelector('.no-data');
                    const columnControls = fileDataSection.querySelector('.column-controls');
                    
                    if (!hidden[file.name]) hidden[file.name] = {};
                    if (!sortingState[file.name]) sortingState[file.name] = {};
                    
                    // Store raw ArrayBuffer for lazy loading
                    fileDataSection.fileDataArrayBuffer = arrayBuffer;
                    fileDataSection.workbook = null; // Will be parsed on demand
                    
                    // Read workbook structure to get sheet names
                    const tempWorkbook = XLSX.read(arrayBuffer, { type: 'array', bookSheets: true , cellDates: true });
                    const sheetNames = tempWorkbook.SheetNames;
                    
                    if (sheetNames.length === 0) {
                        noDataMessage.style.display = 'block';
                        table.style.display = 'none';
                        columnControls.style.display = 'none';
                    } else {
                        noDataMessage.style.display = 'none';
                        table.style.display = 'table';
                        columnControls.style.display = 'flex';
                        
                        // Create tabs
                        sheetNames.forEach((sheetName, tabIndex) => {
                            const tab = document.createElement('div');
                            tab.className = 'sheet-tab';
                            if (tabIndex === 0) tab.classList.add('active');
                            tab.textContent = sheetName;
                            tab.addEventListener('click', function () {
                                // === CLOSE PIVOT TABLE WHEN SWITCHING TABS ===
                                const pivotContainer = fileDataSection.querySelector('.pivot-container');
                                const togglePivotBtn = fileDataSection.querySelector('.toggle-pivot-btn');

                                if (pivotContainer && togglePivotBtn) {
                                    pivotContainer.style.display = 'none';
                                    togglePivotBtn.textContent = 'ðŸ“Š Pivot Analyzer';
                                }

                                // Lazy load sheet data when tab is clicked
                                loadSheetData(sheetName, fileDataSection, sheetTabsContainer, tableHeader, tableBody, columnControls, file.name);
                            });
                            sheetTabsContainer.appendChild(tab);
                        });
                        
                        // Load first sheet immediately
                        loadSheetData(sheetNames[0], fileDataSection, sheetTabsContainer, tableHeader, tableBody, columnControls, file.name);
                    }
                    
                    dataSectionContainer.appendChild(fileDataSection);
                    processFileBatch(files, index + 1);
                    addFormattingControls(fileDataSection);
                    
                } catch (err) {
                    console.error('Error parsing file:', err);
                    showStatus(`Error processing ${file.name}.`, 'error');
                    processFileBatch(files, index + 1);
                }
            };
            reader.onerror = () => {
                showStatus(`Error reading ${file.name}.`, 'error');
                processFileBatch(files, index + 1);
            };
            reader.readAsArrayBuffer(file);
        } catch (err) {
            console.error('Error detecting formats:', err);
            showStatus(`Error analyzing ${file.name}. Skipping.`, 'error');
            processFileBatch(files, index + 1);
        }
      
    }
    
    function resetAdvancedFilter(fileDataSection) {
    const advancedSearchContainer = fileDataSection.querySelector('.advanced-search-container');
    const conditions = advancedSearchContainer.querySelectorAll('.condition-group');
    conditions.forEach((conditionGroup, index) => {
        if (index === 0) {
            conditionGroup.querySelector('.value').value = '';
            conditionGroup.seenValues = {}; // Reset unique tracking
        } else {
            if (conditionGroup.parentNode) {
                conditionGroup.remove();
            }
        }
    });
    const tableBody = fileDataSection.querySelector('tbody');
    const bodyRows = tableBody.querySelectorAll('tr');
    bodyRows.forEach(row => {
        row.style.display = '';
    });
    
    // Properly notify the pagination system about the reset
    if (fileDataSection && typeof fileDataSection.currentFilterCallback === 'function') {
        const allRows = Array.from(tableBody.querySelectorAll('tr'));
        fileDataSection.currentFilterCallback(allRows);
    } else {
        // Fallback behavior
        const visibleCount = Array.from(tableBody.querySelectorAll('tr')).length;
        showStatus('Advanced filter reset', 'success');
    }
   
}
    
    function addAdvancedSearchControls(fileDataSection) {
        // Create advanced search container
        const advancedSearchContainer = document.createElement('div');
        advancedSearchContainer.className = 'advanced-search-container';
        advancedSearchContainer.style.cssText = `
            margin: 15px 0;
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            display: none; /* Hidden by default */
        `;
        
        // Create toggle button
        const toggleBtn = document.createElement('button');
        toggleBtn.className = 'toggle-advanced-search';
        toggleBtn.textContent = 'Toggle Advanced Search';
        toggleBtn.style.cssText = `
            background: rgba(79, 172, 254, 0.3);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            margin-bottom: 10px;
            font-size: 0.9rem;
        `;
        
        // Advanced search form
        advancedSearchContainer.innerHTML = `
            <div class="search-conditions" style="margin-bottom: 10px; max-height: 200px; overflow-y: auto;">
                <div class="condition-group" style="margin-bottom: 10px; padding: 10px; background: rgba(0, 0, 0, 0.2); border-radius: 5px;">
                    <select class="condition-type" style="padding: 5px; margin-right: 5px; background: rgba(255, 255, 255, 0.1); color: #888888; border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 4px;">
                        <option value="AND">AND</option>
                        <option value="OR">OR</option>
                    </select>
                    <select class="column-name" style="padding: 5px; margin-right: 5px; background: rgba(255, 255, 255, 0.1); color: #888888; border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 4px; flex: 1;"></select>
                    <select class="operator" style="padding: 5px; margin-right: 5px; background: rgba(255, 255, 255, 0.1); color: #888888; border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 4px;">
                        <option value="equals">=</option>
                        <option value="not-equals">!=</option>
                        <option value="greater-than">></option>
                        <option value="less-than"><</option>
                        <option value="greater-than-equal">>=</option>
                        <option value="less-than-equal"><=</option>
                        <option value="between">Between</option>
                        <option value="is-null">Is Empty</option>
                        <option value="is-not-null">Is Not Empty</option>
                        <option value="contains">Contains (Text)</option>
                        <option value="starts-with">Starts With</option>
                        <option value="ends-with">Ends With</option>
                        <option value="like">LIKE</option>
                        <option value="unique">Unique Values</option>
                    </select>
                    <input type="text" class="value" placeholder="Value" style="flex: 1; padding: 5px; border-radius: 4px; border: 1px solid rgba(255, 255, 255, 0.3); background-color: rgba(255, 255, 255, 0.1); color: white;">
                    <button class="remove-condition" style="background: rgba(255, 0, 0, 0.3); color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer; margin-left: 5px;">âœ•</button>
                </div>
            </div>
            <div style="display: flex; gap: 10px;">
                <button class="add-condition-btn" style="flex: 1; background: rgba(79, 172, 254, 0.3); color: white; border: 1px solid rgba(255, 255, 255, 0.3); padding: 8px; border-radius: 5px; cursor: pointer;">
                    + Add Condition
                </button>
                <button class="apply-advanced-filter" style="flex: 1; background: linear-gradient(to right, #4facfe, #00f2fe); color: white; border: none; padding: 8px; border-radius: 5px; cursor: pointer;">
                    Apply Filter
                </button>
                <button class="reset-advanced-filter" style="flex: 1; background: rgba(255, 0, 0, 0.3); color: white; border: none; padding: 8px; border-radius: 5px; cursor: pointer;">
                    Reset
                </button>
            </div>
        `;
        
        // Add the controls to the file data section
        const sheetData = fileDataSection.querySelector('.sheet-data');
        sheetData.parentNode.insertBefore(advancedSearchContainer, sheetData);
        sheetData.parentNode.insertBefore(toggleBtn, advancedSearchContainer);
        
        // Setup event listeners
        toggleBtn.addEventListener('click', () => {
            advancedSearchContainer.style.display = advancedSearchContainer.style.display === 'none' ? 'block' : 'none';
        });
        
        // Add initial condition event listeners
        setupConditionEvents(advancedSearchContainer, fileDataSection);
        
        // Add condition button
        const addConditionBtn = advancedSearchContainer.querySelector('.add-condition-btn');
        addConditionBtn.addEventListener('click', () => {
            const conditionGroup = document.createElement('div');
            conditionGroup.className = 'condition-group';
            conditionGroup.style.cssText = 'margin-bottom: 10px; padding: 10px; background: rgba(0, 0, 0, 0.2); border-radius: 5px;';
            conditionGroup.innerHTML = `
                <select class="condition-type" style="padding: 5px; margin-right: 5px; background: rgba(255, 255, 255, 0.1); color: #888888; border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 4px;">
                    <option value="AND">AND</option>
                    <option value="OR">OR</option>
                </select>
                <select class="column-name" style="padding: 5px; margin-right: 5px; background: rgba(255, 255, 255, 0.1); color: #888888; border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 4px; flex: 1;"></select>
                <select class="operator" style="padding: 5px; margin-right: 5px; background: rgba(255, 255, 255, 0.1); color: #888888; border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 4px;">
                    <option value="equals">=</option>
                    <option value="not-equals">!=</option>
                    <option value="greater-than">></option>
                    <option value="less-than"><</option>
                    <option value="greater-than-equal">>=</option>
                    <option value="less-than-equal"><=</option>
                    <option value="between">Between</option>
                    <option value="is-null">Is Empty</option>
                    <option value="is-not-null">Is Not Empty</option>
                    <option value="contains">Contains (Text)</option>
                    <option value="starts-with">Starts With</option>
                    <option value="ends-with">Ends With</option>
                    <option value="like">LIKE</option>
                    <option value="unique">Unique Values</option>
                </select>
                <input type="text" class="value" placeholder="Value" style="flex: 1; padding: 5px; border-radius: 4px; border: 1px solid rgba(255, 255, 255, 0.3); background-color: rgba(255, 255, 255, 0.1); color: white;">
                <button class="remove-condition" style="background: rgba(255, 0, 0, 0.3); color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer; margin-left: 5px;">âœ•</button>
            `;
            advancedSearchContainer.querySelector('.search-conditions').appendChild(conditionGroup);
            setupConditionEvents(advancedSearchContainer, fileDataSection);
            populateColumnNames(fileDataSection, conditionGroup);
        });
        
        // Apply filter button
        const applyFilterBtn = advancedSearchContainer.querySelector('.apply-advanced-filter');
        applyFilterBtn.addEventListener('click', () => {
            applyAdvancedFilter(fileDataSection);
        });
        
        // Reset filter button
        const resetFilterBtn = advancedSearchContainer.querySelector('.reset-advanced-filter');
        resetFilterBtn.addEventListener('click', () => {
            resetAdvancedFilter(fileDataSection);
        });
        
        return advancedSearchContainer;
    }
    
    function setupConditionEvents(advancedSearchContainer, fileDataSection) {
        // Remove condition button
        const removeButtons = advancedSearchContainer.querySelectorAll('.remove-condition');
        removeButtons.forEach(btn => {
            btn.onclick = null; // Remove any existing listeners
            btn.addEventListener('click', function() {
                if (advancedSearchContainer.querySelectorAll('.condition-group').length > 1) {
                    this.closest('.condition-group').remove();
                } else {
                    // Clear values instead of removing the last condition
                    const group = this.closest('.condition-group');
                    group.querySelector('.value').value = '';
                }
            });
        });
        
        // Populate column names for all condition groups
        const conditionGroups = advancedSearchContainer.querySelectorAll('.condition-group');
        conditionGroups.forEach(group => {
            populateColumnNames(fileDataSection, group);
        });
    }
    
    function populateColumnNames(fileDataSection, conditionGroup) {
        const columnNameSelect = conditionGroup.querySelector('.column-name');
        const previouslySelectedValue = columnNameSelect.value; // Save the current selection
        columnNameSelect.innerHTML = ''; // Clear existing options
        
        // Get headers from the current active sheet
        const tableHeader = fileDataSection.querySelector('thead');
        if (tableHeader) {
            const headers = tableHeader.querySelectorAll('th');
            headers.forEach(th => {
                const headerText = th.textContent.split('\n')[0]; // Extract just the header text
                const option = document.createElement('option');
                option.value = headerText;
                option.textContent = headerText;
                columnNameSelect.appendChild(option);
            });
            // Restore the previously selected value if it still exists
            if (previouslySelectedValue && Array.from(columnNameSelect.options).some(opt => opt.value === previouslySelectedValue)) {
                columnNameSelect.value = previouslySelectedValue;
            }
        }
    }
    
    
    // Enhanced version of applyAdvancedFilter with improved logic
    function applyAdvancedFilter(fileDataSection) {
        const advancedSearchContainer = fileDataSection.querySelector('.advanced-search-container');
        fileDataSection.currentAdvancedFilterActive = true;
        const conditions = Array.from(advancedSearchContainer.querySelectorAll('.condition-group'));
        const tableBody = fileDataSection.querySelector('tbody');
        const bodyRows = Array.from(tableBody.querySelectorAll('tr'));
        const seenComposites = {}; // For unique tracking
        
        // Reset all rows to visible
        bodyRows.forEach(row => {
            row.style.display = '';
        });
        
        // Get current sheet name and date/time info
        const activeTab = fileDataSection.querySelector('.sheet-tab.active');
        if (!activeTab) return;
        const sheetName = activeTab.textContent;
        const dateTimeInfo = fileDataSection.dateTimeInfo?.[sheetName];
        const dateCols = new Set(dateTimeInfo?.dateColumns || []);
        const timeCols = new Set(dateTimeInfo?.timeColumns || []);
        
        // Apply each condition
        conditions.forEach((conditionGroup, index) => {
            const columnName = conditionGroup.querySelector('.column-name').value;
            const operator = conditionGroup.querySelector('.operator').value;
            const inputVal = conditionGroup.querySelector('.value').value.trim();
            const conditionType = conditionGroup.querySelector('.condition-type').value;
            
            // Skip empty value fields unless operator is null-related or unique
            if (!['unique', 'is-null', 'is-not-null'].includes(operator) && !inputVal) return;
            
            // Get column index
            const tableHeader = fileDataSection.querySelector('thead');
            const headers = Array.from(tableHeader.querySelectorAll('th'));
            const colIndex = headers.findIndex(th => {
                const headerText = th.textContent.split('\n')[0];
                return headerText === columnName;
            });
            if (colIndex === -1) return;
            
            // Determine if this column is a date/time column
            const isDateColumn = dateCols.has(colIndex);
            
            // Parse input value if needed
            let inputDate = null;
            let parsedInputValue = null;
            let isInputNumeric = false;
            if (isDateColumn && ['equals', 'not-equals', 'greater-than', 'less-than', 'greater-than-equal', 'less-than-equal', 'between'].includes(operator)) {
                inputDate = parseDate(inputVal);
                if (!inputDate && operator !== 'between') {
                    showStatus(`Invalid date format: "${inputVal}"`, 'error');
                    return;
                }
            } else if (!['unique', 'is-null', 'is-not-null', 'between'].includes(operator)) {
                parsedInputValue = parseFormattedNumber(inputVal);
                isInputNumeric = parsedInputValue !== null;
            }
            
            bodyRows.forEach((row, rowIndex) => {
                if (row.style.display === 'none' && conditionType === 'AND') return;
                const cell = row.cells[colIndex];
                if (!cell) return;
                const cellText = cell.textContent.trim();
                let matches = false;
                
                if (isDateColumn) {
                    const cellDate = parseDate(cellText);
                    if (operator === 'is-null') {
                        matches = !cellDate && !cellText;
                    } else if (operator === 'is-not-null') {
                        matches = !!cellDate;
                    } else if (operator === 'between') {
                        const [from, to] = inputVal.split(',').map(v => parseDate(v.trim())).filter(Boolean);
                        if (from && to) {
                            matches = cellDate && cellDate >= from && cellDate <= to;
                        } else {
                            matches = false;
                        }
                    } else if (cellDate) {
                        switch (operator) {
                            case 'equals':
                                matches = cellDate.toDateString() === inputDate.toDateString();
                                break;
                            case 'not-equals':
                                matches = cellDate.toDateString() !== inputDate.toDateString();
                                break;
                            case 'greater-than':
                                matches = cellDate > inputDate;
                                break;
                            case 'less-than':
                                matches = cellDate < inputDate;
                                break;
                            case 'greater-than-equal':
                                matches = cellDate >= inputDate;
                                break;
                            case 'less-than-equal':
                                matches = cellDate <= inputDate;
                                break;
                            default:
                                matches = false;
                        }
                    }
                } else {
                    let cellValue = cellText;
                    let cellNumeric = parseFormattedNumber(cellText);
                    let useNumeric = isInputNumeric && cellNumeric !== null;
                    
                    switch (operator) {
                        case 'is-null':
                            matches = !cellText;
                            break;
                        case 'is-not-null':
                            matches = !!cellText;
                            break;
                        case 'equals':
                            matches = useNumeric
                                ? Math.abs(cellNumeric - parsedInputValue) < 1e-9
                                : cellText.toLowerCase() === inputVal.toLowerCase();
                            break;
                        case 'not-equals':
                            matches = useNumeric
                                ? Math.abs(cellNumeric - parsedInputValue) > 1e-9
                                : cellText.toLowerCase() !== inputVal.toLowerCase();
                            break;
                        case 'contains':
                            matches = cellText.toLowerCase().includes(inputVal.toLowerCase());
                            break;
                        case 'starts-with':
                            matches = cellText.toLowerCase().startsWith(inputVal.toLowerCase());
                            break;
                        case 'ends-with':
                            matches = cellText.toLowerCase().endsWith(inputVal.toLowerCase());
                            break;
                        case 'greater-than':
                            matches = useNumeric ? cellNumeric > parsedInputValue : false;
                            break;
                        case 'less-than':
                            matches = useNumeric ? cellNumeric < parsedInputValue : false;
                            break;
                        case 'greater-than-equal':
                            matches = useNumeric ? cellNumeric >= parsedInputValue : false;
                            break;
                        case 'less-than-equal':
                            matches = useNumeric ? cellNumeric <= parsedInputValue : false;
                            break;
                        case 'like':
                            const escaped = inputVal.replace(/[-\\^$*+?.()|[\]{}]/g, '\\$&');
                            const pattern = '^' + escaped.replace(/%/g, '.*').replace(/_/g, '.') + '$';
                            matches = new RegExp(pattern, 'i').test(cellText);
                            break;
                        case 'unique':
                            // Handle unique across multiple columns
                            const selectedColumns = conditions
                                .filter(c => c.querySelector('.operator').value === 'unique')
                                .map(c => c.querySelector('.column-name').value);
                            if (selectedColumns.length === 0) {
                                matches = true;
                            } else {
                                const keyParts = selectedColumns.map(colName => {
                                    const idx = headers.findIndex(th => {
                                        const headerText = th.textContent.split('\n')[0];
                                        return headerText === colName;
                                    });
                                    return idx !== -1 ? row.cells[idx]?.textContent.trim() : '';
                                });
                                const compositeKey = keyParts.join('|||'); // Delimiter to avoid collisions
                                if (conditionType === 'AND' && index > 0) {
                                    // Only keep if previously visible AND unique
                                    matches = !seenComposites[compositeKey];
                                } else {
                                    matches = !seenComposites[compositeKey];
                                }
                                if (matches) {
                                    seenComposites[compositeKey] = true;
                                }
                            }
                            break;
                        default:
                            matches = false;
                    }
                }
                
                // Apply logic based on condition index and type
                if (index === 0) {
                    if (!matches) row.style.display = 'none';
                } else {
                    if (conditionType === 'AND') {
                        if (!matches) row.style.display = 'none';
                    } else { // OR
                        if (matches) row.style.display = '';
                    }
                }
            });
        });
        // Notify pagination system
if (fileDataSection && typeof fileDataSection.currentFilterCallback === 'function') {
    const visibleRows = Array.from(tableBody.querySelectorAll('tr')).filter(r => r.style.display !== 'none');
    fileDataSection.currentFilterCallback(visibleRows);
} else {
    // Fallback
    const visibleCount = Array.from(tableBody.querySelectorAll('tr')).filter(r => r.style.display !== 'none').length;
    showStatus(`Advanced filter applied: ${visibleCount} rows`, 'success');
}
    }

    
    function resetAdvancedFilter(fileDataSection) {
    const advancedSearchContainer = fileDataSection.querySelector('.advanced-search-container');
    fileDataSection.currentAdvancedFilterActive = false;
    const conditions = advancedSearchContainer.querySelectorAll('.condition-group');
    
    // Reset all condition groups
    conditions.forEach((conditionGroup, index) => {
        if (index === 0) {
            conditionGroup.querySelector('.value').value = '';
            conditionGroup.seenValues = {}; // Reset unique tracking
        } else {
            if (conditionGroup.parentNode) {
                conditionGroup.remove();
            }
        }
    });

    const tableBody = fileDataSection.querySelector('tbody');
    const allRows = Array.from(tableBody.querySelectorAll('tr')); // Get all rows

    // Show all rows
    allRows.forEach(row => {
        row.style.display = '';
    });

    // âœ… Notify pagination system that filter is reset
    if (fileDataSection && typeof fileDataSection.currentFilterCallback === 'function') {
        fileDataSection.currentFilterCallback(allRows); // Pass all rows
    }

    showStatus('Advanced filter reset', 'success');
}

    function parseFormattedNumber(value) {
        if (typeof value !== 'string') value = String(value);
        value = value.trim();
        // Handle percentage: convert to decimal
        if (value.includes('%')) {
            const numericPart = value.replace(/[%$â‚¬Â£Â¥â‚¹,]/g, '');
            const num = parseFloat(numericPart);
            return isNaN(num) ? null : num / 100;
        }
        // Extract number from currency/commas
        const numericPart = value.replace(/[$â‚¬Â£Â¥â‚¹,]/g, '');
        const num = parseFloat(numericPart);
        return isNaN(num) ? null : num;
    }
    
    // --- NEW: Sorting Functions ---
    function sortTableData(fileDataSection, columnIndex, sheetName) {
    const table = fileDataSection.querySelector('table');
    const tableHeader = table.querySelector('thead');
    const tableBody = table.querySelector('tbody');

    // Get current search filters
    const searchTerms = {};
    const headers = tableHeader.querySelectorAll('th');
    headers.forEach((th, idx) => {
        const input = th.querySelector('input');
        if (input && input.value.trim()) {
            searchTerms[idx] = input.value.trim().toLowerCase();
        }
    });

    // Get the current sort state
    const currentState = sortingState[fileDataSection.fileName]?.[sheetName]?.[columnIndex] || 'none';
    const nextSortState = currentState === 'none' || currentState === 'desc' ? 'asc' : 'desc';

    // Update sort state
    if (!sortingState[fileDataSection.fileName]) sortingState[fileDataSection.fileName] = {};
    if (!sortingState[fileDataSection.fileName][sheetName]) sortingState[fileDataSection.fileName][sheetName] = {};
    sortingState[fileDataSection.fileName][sheetName][columnIndex] = nextSortState;

    // Reset header indicators
    headers.forEach(th => {
        th.classList.remove('sorted-asc', 'sorted-desc');
    });
    headers[columnIndex]?.classList.add(nextSortState === 'asc' ? 'sorted-asc' : 'sorted-desc');

    // Get column type info
    const dateTimeInfo = fileDataSection.dateTimeInfo?.[sheetName];
    const isDateColumn = dateTimeInfo?.dateColumns?.includes(columnIndex);

    // --- Get all rows (including hidden ones) ---
    const allRows = Array.from(tableBody.querySelectorAll('tr'));

    // Sort all rows
    const sortedRows = allRows.sort((a, b) => {
        const cellA = a.cells[columnIndex];
        const cellB = b.cells[columnIndex];
        if (!cellA || !cellB) return 0;

        const valA = cellA.textContent.trim();
        const valB = cellB.textContent.trim();
        let comparison = 0;

        if (isDateColumn) {
            const dateA = parseDate(valA);
            const dateB = parseDate(valB);
            if (dateA && dateB) {
                comparison = dateA - dateB;
            } else if (dateA) {
                comparison = 1;
            } else if (dateB) {
                comparison = -1;
            } else {
                comparison = valA.localeCompare(valB);
            }
        } else if (valA !== '' && valB !== '') {
            const numA = parseFormattedNumber(valA);
            const numB = parseFormattedNumber(valB);
            if (numA !== null && numB !== null) {
                comparison = numA - numB;
            } else {
                const floatA = parseFloat(valA);
                const floatB = parseFloat(valB);
                if (!isNaN(floatA) && !isNaN(floatB)) {
                    comparison = floatA - floatB;
                } else {
                    comparison = valA.localeCompare(valB);
                }
            }
        } else {
            if (valA === '' && valB === '') comparison = 0;
            else if (valA === '') comparison = 1;
            else comparison = -1;
        }

        return nextSortState === 'desc' ? -comparison : comparison;
    });

    // Re-append sorted rows to update DOM order
    sortedRows.forEach(row => tableBody.appendChild(row));

    // âœ… Re-apply the current filter after sorting
    if (Object.keys(searchTerms).length > 0) {
        // Simulate filter re-apply using existing function
        filterTableData(fileDataSection.fileName, sheetName, table, searchTerms, fileDataSection);
    } else if (fileDataSection.currentAdvancedFilterActive) {
        // If advanced filter was applied, re-apply it
        applyAdvancedFilter(fileDataSection);
    } else {
        // No filter: just notify pagination system with all sorted rows
        if (typeof fileDataSection.currentFilterCallback === 'function') {
            fileDataSection.currentFilterCallback(sortedRows);
        }
    }

    showStatus(`Sorted column ${columnIndex + 1} ${nextSortState === 'asc' ? 'ascending' : 'descending'}`, 'success');
}

    function loadSheetData(sheetName, fileDataSection, sheetTabsContainer, tableHeader, tableBody, columnControls, fileName) {
    // 1. Update active tab
    updateActiveTab(sheetTabsContainer, sheetName);

    

    // 2. Lazy-load workbook if not already parsed
    if (!fileDataSection.workbook) {
        try {
            fileDataSection.workbook = XLSX.read(fileDataSection.fileDataArrayBuffer, {
                type: 'array',
                cellDates: false,
                cellNF: true,
                cellText: true
            });
        } catch (err) {
            showStatus(`Failed to parse workbook for ${fileName}.`, 'error');
            return;
        }
    }
    const workbook = fileDataSection.workbook;
    const worksheet = workbook.Sheets[sheetName];
    if (!worksheet) {
        tableBody.innerHTML = '<tr><td colspan="100">Sheet data not found.</td></tr>';
        return;
    }

    // 3. Extract data
    const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: '' });
    if (jsonData.length === 0) {
        renderEmptyState(tableHeader, tableBody, columnControls);
        return;
    }

    const headers = jsonData[0];

    // 4. Render UI Components
    renderTableHeader(headers, tableHeader, fileDataSection, fileName, sheetName);
    renderTableBody(headers, jsonData, worksheet, tableBody);
    initializeColumnControls(headers, columnControls, fileName, sheetName, tableHeader, tableBody);

    // 5. Apply visibility, sorting, and filtering
    applyHiddenColumns(fileName, sheetName, tableHeader, tableBody);
    applySavedSortState(headers, tableHeader, fileDataSection, fileName, sheetName);
    reapplyFilters(fileDataSection, fileName, sheetName, tableHeader, tableBody);

    // 6. Setup Pagination & Stats
    setupPaginationAndStats(fileDataSection, tableBody);

    // 7. Setup Advanced Search (rebind or create)
    setupAdvancedSearch(fileDataSection, headers);

    // 8. Add Export Controls (if not already present)
    if (!fileDataSection.querySelector('.export-controls')) {
        addExportControls(fileDataSection);
    }
    // 9. Setup Charting
    setupCharting(fileDataSection);

   

    
    setupStatsPanel(fileDataSection, headers, tableBody);

    
    


    if (!fileDataSection.querySelector('.toggle-pivot-btn')) {
        setupPivotAnalyzer(fileDataSection, headers, tableBody);
    }

    

    
}

function updateActiveTab(sheetTabsContainer, sheetName) {
    sheetTabsContainer.querySelectorAll('.sheet-tab').forEach(tab => {
        tab.classList.toggle('active', tab.textContent === sheetName);
    });
}
function renderEmptyState(tableHeader, tableBody, columnControls) {
    tableHeader.innerHTML = '';
    tableBody.innerHTML = '<tr><td colspan="100">No data available</td></tr>';
    columnControls.innerHTML = '';
}
function renderTableHeader(headers, tableHeader, fileDataSection, fileName, sheetName) {
    tableHeader.innerHTML = '';
    const headerRow = document.createElement('tr');
    const searchTerms = {};

    headers.forEach((header, index) => {
        const th = document.createElement('th');
        th.dataset.columnIndex = index;

        const headerContainer = document.createElement('div');
        headerContainer.style.display = 'flex';
        headerContainer.style.flexDirection = 'column';

        const headerText = document.createElement('div');
        headerText.textContent = header || `Column ${index}`;
        headerContainer.appendChild(headerText);

        const searchInput = document.createElement('input');
        searchInput.type = 'text';
        searchInput.placeholder = 'Search...';
        searchInput.style.cssText = `
            width: 100%; padding: 5px; margin-top: 5px; border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background-color: rgba(255, 255, 255, 0.1); color: white;
        `;
        searchInput.addEventListener('input', function () {
            const colIndex = parseInt(th.dataset.columnIndex);
            if (this.value.trim() === '') {
                delete searchTerms[colIndex];
            } else {
                searchTerms[colIndex] = this.value;
            }
            filterTableData(fileName, sheetName, tableHeader.closest('table'), searchTerms, fileDataSection);
        });
        headerContainer.appendChild(searchInput);
        th.appendChild(headerContainer);

        // Sort on click
        th.addEventListener('click', function (e) {
            if (e.target !== searchInput) {
                sortTableData(fileDataSection, index, sheetName);
            }
        });

        headerRow.appendChild(th);
    });
    tableHeader.appendChild(headerRow);
}
function renderTableBody(headers, jsonData, worksheet, tableBody) {
    tableBody.innerHTML = '';
    for (let i = 1; i < jsonData.length; i++) {
        const row = document.createElement('tr');
        const rowData = jsonData[i];
        headers.forEach((_, cellIndex) => {
            const td = document.createElement('td');
            let displayText = '';
            const cellAddress = XLSX.utils.encode_cell({ r: i, c: cellIndex });
            const cell = worksheet[cellAddress];
            if (cell) {
                displayText = cell.w !== undefined ? cell.w : cell.v;
            } else {
                displayText = rowData[cellIndex] || '';
            }
            td.textContent = displayText;
            row.appendChild(td);
        });
        tableBody.appendChild(row);
    }
}
function initializeColumnControls(headers, columnControls, fileName, sheetName, tableHeader, tableBody) {
    if (!hidden[fileName][sheetName]) hidden[fileName][sheetName] = [];
    columnControls.innerHTML = '';
    headers.forEach((header, index) => {
        const headerText = header || `Column ${index}`;
        const btn = document.createElement('button');
        btn.className = 'column-control-btn';
        btn.textContent = headerText;
        btn.dataset.columnIndex = index;
        if (hidden[fileName][sheetName].includes(headerText)) btn.classList.add('hidden');
        btn.addEventListener('click', function () {
            toggleColumnVisibility(index, headerText, fileName, sheetName, tableHeader, tableBody);
            this.classList.toggle('hidden');
        });
        columnControls.appendChild(btn);
    });
}
function applySavedSortState(headers, tableHeader, fileDataSection, fileName, sheetName) {
    const sortState = sortingState[fileName]?.[sheetName];
    if (!sortState) return;

    Object.keys(sortState).forEach(colIndexStr => {
        const colIndex = parseInt(colIndexStr);
        const state = sortState[colIndex];
        const th = tableHeader.querySelector(`th[data-column-index="${colIndex}"]`);
        if (th) {
            th.classList.remove('sorted-asc', 'sorted-desc');
            th.classList.add(state === 'asc' ? 'sorted-asc' : 'sorted-desc');
        }
    });
}
function reapplyFilters(fileDataSection, fileName, sheetName, tableHeader, tableBody) {
    const searchInputs = tableHeader.querySelectorAll('input');
    const searchTerms = {};
    searchInputs.forEach(input => {
        const th = input.parentElement.parentElement;
        const colIndex = th.dataset.columnIndex;
        if (input.value.trim()) {
            searchTerms[colIndex] = input.value;
        }
    });

    if (Object.keys(searchTerms).length > 0) {
        filterTableData(fileName, sheetName, tableHeader.closest('table'), searchTerms, fileDataSection);
    } else if (fileDataSection.currentAdvancedFilterActive) {
        applyAdvancedFilter(fileDataSection);
    } else {
        const allRows = Array.from(tableBody.querySelectorAll('tr'));
        if (typeof fileDataSection.currentFilterCallback === 'function') {
            fileDataSection.currentFilterCallback(allRows);
        }
    }
}
function setupPaginationAndStats(fileDataSection, tableBody) {
    const tableStats = fileDataSection.querySelector('.table-stats');
    const rowCountEl = tableStats.querySelector('.row-count');
    const paginationControls = tableStats.querySelector('.pagination-controls');
    const prevBtn = paginationControls.querySelector('.prev-page');
    const nextBtn = paginationControls.querySelector('.next-page');
    const pageInfo = paginationControls.querySelector('.page-info');

    const allRows = Array.from(tableBody.querySelectorAll('tr'));
    let filteredRows = [...allRows];
    let currentPage = 1;
    const rowsPerPage = 25;

    function updateStats() {
        const total = allRows.length;
        const visible = filteredRows.length;
        const totalPages = Math.ceil(visible / rowsPerPage);
        const start = (currentPage - 1) * rowsPerPage + 1;
        const end = Math.min(start + rowsPerPage - 1, visible);
        rowCountEl.textContent = `Total: ${total} | Displayed: ${visible}`;
        pageInfo.textContent = visible === 0 ? 'Page 0' : `Page ${currentPage} of ${totalPages} (${start}â€“${end})`;
        prevBtn.disabled = currentPage === 1;
        nextBtn.disabled = currentPage === totalPages || totalPages === 0;
    }

    function renderPage() {
        allRows.forEach(row => (row.style.display = 'none'));
        const start = (currentPage - 1) * rowsPerPage;
        const end = start + rowsPerPage;
        filteredRows.slice(start, end).forEach(row => (row.style.display = ''));
        updateStats();
    }

    function onFilterChange(filteredVisibleRows) {
        filteredRows = filteredVisibleRows;
        fileDataSection.filteredRows = filteredVisibleRows; // For export
        currentPage = 1;
        renderPage();
    }

    fileDataSection.currentFilterCallback = onFilterChange;

    prevBtn.addEventListener('click', () => {
        if (currentPage > 1) {
            currentPage--;
            renderPage();
        }
    });

    nextBtn.addEventListener('click', () => {
        const totalPages = Math.ceil(filteredRows.length / rowsPerPage);
        if (currentPage < totalPages) {
            currentPage++;
            renderPage();
        }
    });

    updateStats();
    renderPage();
}
function setupAdvancedSearch(fileDataSection, headers) {
    const advancedSearchContainer = fileDataSection.querySelector('.advanced-search-container');
    if (!advancedSearchContainer) {
        addAdvancedSearchControls(fileDataSection);
        return;
    }

    const conditionGroups = advancedSearchContainer.querySelectorAll('.condition-group');
    conditionGroups.forEach(group => {
        const select = group.querySelector('.column-name');
        if (select) {
            const prevValue = select.value;
            select.innerHTML = '';
            headers.forEach(h => {
                const opt = document.createElement('option');
                opt.value = h;
                opt.textContent = h;
                select.appendChild(opt);
            });
            if (Array.from(select.options).some(o => o.value === prevValue)) {
                select.value = prevValue;
            }
        }
    });

    setupConditionEvents(advancedSearchContainer, fileDataSection);
}

    function clearAllData() {
        dataSectionContainer.innerHTML = '';
        hidden = {};
        sortingState = {};
        fileInput.value = '';
        fileText.textContent = 'Drag & drop files here or click to browse';
        uploadBtn.disabled = true;
        fileList.innerHTML = '';
        showStatus('All data cleared', 'success');
    }
    
    function toggleColumnVisibility(columnIndex, columnName, fileName, sheetName, tableHeader, tableBody) {
        if (!hidden[fileName][sheetName]) hidden[fileName][sheetName] = [];
        const idx = hidden[fileName][sheetName].indexOf(columnName);
        if (idx > -1) {
            hidden[fileName][sheetName].splice(idx, 1);
        } else {
            hidden[fileName][sheetName].push(columnName);
        }
        applyHiddenColumns(fileName, sheetName, tableHeader, tableBody);
        showStatus(`Column "${columnName}" ${hidden[fileName][sheetName].includes(columnName) ? 'hidden' : 'shown'}`, 'success');
    }
    
    function applyHiddenColumns(fileName, sheetName, tableHeader, tableBody) {
        const headerCells = Array.from(tableHeader.querySelectorAll('th'));
        const bodyRows = tableBody.querySelectorAll('tr');
        bodyRows.forEach(row => row.querySelectorAll('td').forEach(td => td.classList.remove('hidden-column')));
        headerCells.forEach(th => th.classList.remove('hidden-column'));
        
        if (hidden[fileName] && hidden[fileName][sheetName]) {
            hidden[fileName][sheetName].forEach(colName => {
                const colIndex = headerCells.findIndex(th => th.textContent.trim() === colName);
                if (colIndex !== -1) {
                    headerCells[colIndex].classList.add('hidden-column');
                    bodyRows.forEach(row => {
                        const cells = row.querySelectorAll('td');
                        if (cells[colIndex]) cells[colIndex].classList.add('hidden-column');
                    });
                }
            });
        }
    }
    
    function parseDate(value) {
    if (!value || typeof value !== 'string') return null;
    value = value.trim();

    // Handle ISO formats
    if (/^\d{4}-\d{2}-\d{2}/.test(value)) {
        const date = new Date(value);
        if (!isNaN(date.getTime())) return date;
    }

    // Handle common formats: MM/DD/YYYY, DD/MM/YYYY, MM-DD-YYYY, etc.
    const dateParts = value.split(/[/\-.\s]+/);
    if (dateParts.length >= 3) {
        let [p1, p2, p3] = dateParts.map(Number);
        const meridiemMatch = value.match(/(AM|PM)/i);
        let hours = 0, minutes = 0;

        // Extract time if present
        const timeMatch = value.match(/(\d{1,2}):(\d{2})(?::(\d{2}))?\s*(AM|PM)?/i);
        if (timeMatch) {
            hours = parseInt(timeMatch[1], 10);
            minutes = parseInt(timeMatch[2], 10);
            const seconds = timeMatch[3] ? parseInt(timeMatch[3], 10) : 0;
            const isPM = timeMatch[4] ? timeMatch[4].toUpperCase() === 'PM' : false;
            if (isPM && hours < 12) hours += 12;
            if (!isPM && hours === 12) hours = 0;
        }

        // Guess format based on position and ranges
        if (p1 > 31) return null; // Invalid day/month
        if (p3 < 100) p3 += 2000; // 2-digit year

        let year, month, day;

        // Try MM/DD/YYYY or DD/MM/YYYY based on values
        if (p1 <= 12 && p2 > 12) {
            // Likely MM/DD/YYYY
            [month, day, year] = [p1 - 1, p2, p3];
        } else if (p2 <= 12 && p1 > 12) {
            // Likely DD/MM/YYYY
            [day, month, year] = [p1, p2 - 1, p3];
        } else if (p1 <= 12 && p2 <= 31) {
            // Ambiguous â€” assume MM/DD/YYYY
            [month, day, year] = [p1 - 1, p2, p3];
        } else {
            return null;
        }

        const date = new Date(year, month, day, hours, minutes);
        if (date.getFullYear() === year && date.getMonth() === month && date.getDate() === day) {
            return date;
        }
    }

    // Handle textual months: Jan, Feb, etc.
    const monthNames = {
        jan: 0, feb: 1, mar: 2, apr: 3, may: 4, jun: 5,
        jul: 6, aug: 7, sep: 8, oct: 9, nov: 10, dec: 11
    };
    const monthRegex = new RegExp(Object.keys(monthNames).join('|'), 'i');
    if (monthRegex.test(value)) {
        const m = value.match(monthRegex)[0];
        const numPart = value.replace(m, '').trim();
        const nums = numPart.split(/[\s\/\\,.]+/).map(Number).filter(n => !isNaN(n));
        if (nums.length >= 2) {
            let year, day;
            const mIndex = monthNames[m.toLowerCase()];
            for (let n of nums) {
                if (n > 31) year = n;
                else if (n <= 31) day = n;
            }
            if (day && typeof year !== 'undefined') {
                if (year < 100) year += 2000;
                const date = new Date(year, mIndex, day, hours, minutes);
                if (date.getDate() === day && date.getFullYear() === year) {
                    return date;
                }
            }
        }
    }

    return null;
}
    function filterTableData(fileName, sheetName, table, searchTerms, fileDataSection) {
  
    const bodyRows = Array.from(table.querySelector('tbody').querySelectorAll('tr'));
    const headers = Array.from(table.querySelector('thead').querySelectorAll('th'));
    const lowerCaseSearchTerms = {};
    Object.keys(searchTerms).forEach(k => {
        if (searchTerms[k]) lowerCaseSearchTerms[k] = searchTerms[k].toLowerCase();
    });

    const filteredRows = bodyRows.filter(row => {
        const cells = row.querySelectorAll('td');
        let matches = true;
        Object.keys(lowerCaseSearchTerms).forEach(colIndex => {
            const term = lowerCaseSearchTerms[colIndex];
            if (colIndex < cells.length) {
                const text = (cells[colIndex].textContent || '').toLowerCase();
                if (!text.includes(term)) matches = false;
            }
        });
        return matches;
    });

    // Hide all rows first
    bodyRows.forEach(row => (row.style.display = 'none'));

    // Notify pagination system
    if (fileDataSection && typeof fileDataSection.currentFilterCallback === 'function') {
        fileDataSection.currentFilterCallback(filteredRows);
    } else {
        // Fallback: just show filtered
        filteredRows.forEach(row => (row.style.display = ''));
    }
    
    showStatus(`Filtered: ${filteredRows.length} rows match`, 'success');
}
    function showStatus(message, type) {
        statusDiv.textContent = message;
        statusDiv.className = `status ${type}`;
    }

    function addExportControls(fileDataSection) {
        // Create export controls container
        const exportControls = document.createElement('div');
        exportControls.className = 'export-controls';
        exportControls.style.cssText = `
            display: flex;
            gap: 10px;
            margin: 15px 0;
            flex-wrap: wrap;
        `;
        
        // Export full file button
        const exportFullBtn = document.createElement('button');
        exportFullBtn.className = 'export-btn full-data';
        exportFullBtn.textContent = 'Export Full File';
        exportFullBtn.style.cssText = `
            background: linear-gradient(to right, #4facfe, #00f2fe);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
        `;
        
        // Export visible data button
        const exportVisibleBtn = document.createElement('button');
        exportVisibleBtn.className = 'export-btn visible-data';
        exportVisibleBtn.textContent = 'Export Visible Data as CSV';
        exportVisibleBtn.style.cssText = `
            background: rgba(79, 172, 254, 0.3);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
        `;
        
        // Add buttons to container
        exportControls.appendChild(exportFullBtn);
        exportControls.appendChild(exportVisibleBtn);


        // Inside addExportControls(), after exportVisibleBtn
        const exportPdfBtn = document.createElement('button');
        exportPdfBtn.className = 'export-btn export-pdf';
        exportPdfBtn.textContent = 'Export Table as PDF';
        exportPdfBtn.style.cssText = `
        background: #dc3545;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 0.9rem;
        `;
        exportControls.appendChild(exportPdfBtn);

        // Attach event listener
        exportPdfBtn.addEventListener('click', () => {
        exportFullTableAsPDF(fileDataSection);
        });
        
        // Add event listeners
        exportFullBtn.addEventListener('click', () => {
            exportFileData(fileDataSection, 'full');
        });
        
        exportVisibleBtn.addEventListener('click', () => {
            exportFileData(fileDataSection, 'visible');
        });
        
        // Add export controls to the file data section
        const sheetData = fileDataSection.querySelector('.sheet-data');
        sheetData.parentNode.insertBefore(exportControls, sheetData);
        
        return exportControls;
    }

    function exportFullTableAsPDF(fileDataSection) {
    const fileName = fileDataSection.fileName || 'table_export';
    const activeTab = fileDataSection.querySelector('.sheet-tab.active');
    if (!activeTab) {
        showStatus('No active sheet to export.', 'error');
        return;
    }
    const sheetName = activeTab.textContent;

    // Get headers (only non-hidden columns) - FIXED: get full text
    const tableHeader = fileDataSection.querySelector('thead');
    const headerCells = Array.from(tableHeader.querySelectorAll('th'))
        .filter(th => !th.classList.contains('hidden-column'))
        .map(th => {
            // Correctly extract full column name, ignoring search inputs
            const headerTextElement = th.querySelector('.header-text') || th; // if you have a class for text
            return th.textContent.trim(); // Safe: modern browsers preserve full text even with inputs
        });

    // Use filteredRows if available, otherwise use all visible rows
    const tableBody = fileDataSection.querySelector('tbody');
    let dataRows = [];

    const rows = fileDataSection.filteredRows && Array.isArray(fileDataSection.filteredRows)
        ? fileDataSection.filteredRows
        : Array.from(tableBody.querySelectorAll('tr'));

    dataRows = rows.map(row => {
        return Array.from(row.cells)
            .filter((_, index) => {
                const header = tableHeader.querySelector(`th:nth-child(${index + 1})`);
                return header && !header.classList.contains('hidden-column');
            })
            .map(cell => cell.textContent.trim());
    });

    if (dataRows.length === 0) {
        showStatus('No data available to export.', 'error');
        return;
    }

    // Load jsPDF and autoTable
    if (typeof window.jspdf === 'undefined') {
        alert('jsPDF not loaded. Cannot export to PDF.');
        return;
    }
    const { jsPDF } = window.jspdf;

    // Create PDF (landscape to fit wide tables)
    const pdf = new jsPDF('l', 'mm', 'a4');
    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();

    // Add title
    pdf.setFontSize(16);
    pdf.text(`Data Export: ${fileName} - ${sheetName}`, 10, 15);

    // Generate table
    pdf.autoTable({
        head: [headerCells],
        body: dataRows,
        startY: 25,
        theme: 'striped',
        styles: { fontSize: 9, cellPadding: 3 },
        headStyles: { fillColor: [79, 172, 254], textColor: 255 },
        margin: { top: 15, left: 5, right: 5 },
        didDrawPage: function (data) {
            // Add footer
            const footerText = `Page ${pdf.getCurrentPageInfo?.().pageNumber || 1}`;
            const textWidth = pdf.getStringUnitWidth(footerText) * pdf.internal.getFontSize() / pdf.internal.scaleFactor;
            pdf.text(footerText, pageWidth - textWidth - 10, pageHeight - 10);
        }
    });

    // Save the PDF
    const dateStr = new Date().toISOString().slice(0, 10);
    pdf.save(`${fileName}_${sheetName}_table_export_${dateStr}.pdf`);
    showStatus(`Exported ${dataRows.length} rows as PDF successfully.`, 'success');
}

    function exportFileData(fileDataSection, exportType) {
    const fileName = fileDataSection.fileName;
    const sheetName = fileDataSection.querySelector('.sheet-tab.active')?.textContent;

    if (!sheetName) return;

    try {
        if (exportType === 'visible') {
            exportVisibleDataAsCSV(fileDataSection, sheetName, fileName);
        } else {
            // Pass fileDataSection so we can check for cleaned/edited state
            exportFullFile(fileDataSection.workbook, fileName, fileDataSection);
        }
    } catch (error) {
        console.error('Export error:', error);
        showStatus(`Export failed: ${error.message}`, 'error');
    }
}

    function exportVisibleDataAsCSV(fileDataSection, sheetName, originalFileName) {
    const tableBody = fileDataSection.querySelector('tbody');
    const tableHeader = fileDataSection.querySelector('thead');

    // Get headers (only non-hidden columns)
    const headers = Array.from(tableHeader.querySelectorAll('th'))
        .filter(th => !th.classList.contains('hidden-column'))
        .map(th => {
            const text = th.textContent.split('\n')[0]; // Remove search input line
            return text.trim();
        });

    // âœ… Use the full filteredRows list instead of DOM visibility
    let filteredRows = Array.from(tableBody.querySelectorAll('tr'));
    
    // Check if pagination system has a filtered list
    if (fileDataSection.filteredRows && Array.isArray(fileDataSection.filteredRows)) {
        filteredRows = fileDataSection.filteredRows;
    } else {
        // Fallback: use all rows (unfiltered)
        console.warn("No filteredRows found, exporting all data.");
    }

    // Extract data from all filtered rows
    const csvData = [];
    csvData.push(headers); // Header row

    filteredRows.forEach(row => {
        const rowData = [];
        const cells = row.querySelectorAll('td');
        Array.from(tableHeader.querySelectorAll('th')).forEach((th, index) => {
            if (!th.classList.contains('hidden-column') && cells[index]) {
                rowData.push(cells[index].textContent.trim());
            }
        });
        csvData.push(rowData);
    });

    // Convert to CSV string
    const csvString = csvData.map(row =>
        row.map(cell => {
            // Escape quotes and wrap if needed
            const escaped = String(cell).replace(/"/g, '""');
            return /[",\r\n]/.test(escaped) ? `"${escaped}"` : escaped;
        }).join(',')
    ).join('\n');

    // Create download
    const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    const url = URL.createObjectURL(blob);
    const baseName = originalFileName.replace(/\.[^/.]+$/, "");
    link.setAttribute('href', url);
    link.setAttribute('download', `${baseName}_${sheetName}_filtered_data.csv`);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);

    showStatus(`Exported ${filteredRows.length} filtered/sorted rows as CSV`, 'success');
}

    function exportFullFile(workbook, originalFileName, fileDataSection) {
    try {
        // Since there is no data editing functionality implemented,
        // we always export the original workbook.
        const finalWorkbook = workbook;

        // Generate file and trigger download
        const wbout = XLSX.write(finalWorkbook, { bookType: 'xlsx', type: 'array', cellDates: true });
        const blob = new Blob([wbout], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
        const link = document.createElement('a');
        const url = URL.createObjectURL(blob);
        link.setAttribute('href', url);
        link.setAttribute('download', originalFileName);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
        showStatus('Full file exported successfully', 'success');
    } catch (error) {
        console.error('Full file export error:', error);
        showStatus('Failed to export full file', 'error');
    }
}

function addChartControls(fileDataSection, headers) {
    const sheetData = fileDataSection.querySelector('.sheet-data');

    // Create toggle button
    const toggleChartBtn = document.createElement('button');
    toggleChartBtn.className = 'toggle-chart-btn';
    toggleChartBtn.textContent = 'Show Chart';
    toggleChartBtn.dataset.expanded = 'false';

    // Chart controls container
    const chartControls = document.createElement('div');
    chartControls.className = 'chart-controls';
    chartControls.innerHTML = `
        <div style="display: grid; gap: 10px; grid-template-columns: 1fr 1fr;">
            <div>
                <label>Chart Type:</label>
                <select class="chart-type">
                    <option value="bar">Bar</option>
                    <option value="line">Line</option>
                    <option value="pie">Pie</option>
                    <option value="doughnut">Doughnut</option>
                    <option value="radar">Radar</option>
                    <option value="polarArea">Polar Area</option>
                </select>
            </div>
            <div>
                <label>X-Axis Column:</label>
                <select class="x-axis-select"></select>
            </div>
        </div>
        <div>
            <label>Y-Axis Columns:</label>
            <div class="y-axis-container" style="display: flex; flex-wrap: wrap; gap: 8px; margin-top: 8px; max-height: 150px; overflow-y: auto; border: 1px solid rgba(255,255,255,0.3); border-radius: 6px; padding: 10px; background: rgba(0,0,0,0.1);">
                <!-- Y-axis column buttons will be inserted here -->
            </div>
        </div>
        <div class="chart-actions">
            <button class="generate-chart-btn">Generate Chart</button>
            <button class="export-chart-pdf-btn" style="background: #dc3545; color: white; border: none; padding: 6px 10px; border-radius: 4px; cursor: pointer; font-size: 0.9rem;">ðŸ“„ Export Chart as PDF</button>
        </div>
    `;

    // Chart container
    const chartWrapper = document.createElement('div');
    chartWrapper.className = 'chart-container-wrapper';
    chartWrapper.style.display = 'none';
    chartWrapper.innerHTML = `<canvas class="chart-canvas"></canvas>`;

    // Append elements
    sheetData.parentNode.insertBefore(toggleChartBtn, sheetData.nextSibling);
    sheetData.parentNode.insertBefore(chartControls, toggleChartBtn.nextSibling);
    sheetData.parentNode.insertBefore(chartWrapper, chartControls.nextSibling);

    // Populate X-Axis dropdown
    const xAxisSelect = chartControls.querySelector('.x-axis-select');
    headers.forEach(header => {
        const opt = document.createElement('option');
        opt.value = header;
        opt.textContent = header;
        xAxisSelect.appendChild(opt);
    });
    if (headers.length > 0) xAxisSelect.value = headers[0];

    // Populate Y-Axis as toggle buttons
    const yAxisContainer = chartControls.querySelector('.y-axis-container');
    headers.forEach(header => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'y-axis-btn';
        btn.dataset.value = header;
        btn.style.cssText = `
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        `;
        btn.textContent = header;

        // Toggle selection on click
        btn.addEventListener('click', function () {
            const isSelected = this.classList.toggle('selected');
            this.style.background = isSelected ? '#4facfe' : 'rgba(255, 255, 255, 0.1)';
            this.style.color = isSelected ? 'white' : '#ddd';
        });

        yAxisContainer.appendChild(btn);
    });

    // Store references
    fileDataSection.chartControls = chartControls;
    fileDataSection.chartWrapper = chartWrapper;
    fileDataSection.toggleChartBtn = toggleChartBtn;

    // Toggle visibility
    toggleChartBtn.addEventListener('click', () => {
        const isExpanded = toggleChartBtn.dataset.expanded === 'true';
        chartControls.style.display = isExpanded ? 'none' : 'block';
        chartWrapper.style.display = isExpanded ? 'none' : 'block';
        toggleChartBtn.textContent = isExpanded ? 'Show Chart' : 'Hide Chart';
        toggleChartBtn.dataset.expanded = isExpanded ? 'false' : 'true';
        if (!isExpanded) {
            setTimeout(() => {
                if (fileDataSection.chartInstance) {
                    fileDataSection.chartInstance.resize();
                }
            }, 100);
        }
    });

    // Generate chart button
    chartControls.querySelector('.generate-chart-btn').addEventListener('click', () => {
        renderChart(fileDataSection);
    });
    // Export Chart as PDF
chartControls.querySelector('.export-chart-pdf-btn').addEventListener('click', () => {
  if (!fileDataSection.chartInstance) {
    showStatus('No chart to export.', 'error');
    return;
  }

  // Dynamically load jsPDF if not available
  if (typeof window.jspdf === 'undefined') {
    alert('jsPDF not loaded. Cannot export chart.');
    return;
  }

  const { jsPDF } = window.jspdf;
  const canvas = chartWrapper.querySelector('.chart-canvas');

  // Confirm chart is visible and canvas exists
  if (!canvas) {
    showStatus('Chart canvas not found.', 'error');
    return;
  }

  // Extract image from canvas
  canvas.toBlob(function (blob) {
    if (!blob) {
      showStatus('Failed to generate chart image.', 'error');
      return;
    }

    // Create file reader to convert blob to data URL
    const reader = new FileReader();
    reader.onload = function () {
      const imgData = reader.result;

      // Create PDF (landscape for charts)
      const pdf = new jsPDF('l', 'mm', 'a4');
      const pdfWidth = pdf.internal.pageSize.getWidth();
      const pdfHeight = pdf.internal.pageSize.getHeight();

      // Calculate image dimensions (maintain aspect ratio)
      const imgProps = pdf.getImageProperties(imgData);
      const ratio = imgProps.height / imgProps.width;
      const imgWidth = pdfWidth - 20; // 10mm margin left/right
      const imgHeight = imgWidth * ratio;

      // Add image to PDF
      pdf.addImage(imgData, 'PNG', 10, 40, imgWidth, imgHeight);

      // Optional: Add title
      const fileName = fileDataSection.fileName || 'Chart';
      const sheetName = fileDataSection.querySelector('.sheet-tab.active')?.textContent || '';
      pdf.setFontSize(16);
      pdf.text(`Chart Export: ${fileName} - ${sheetName}`, 10, 30);

      // Save the PDF
      pdf.save(`chart_export_${new Date().toISOString().slice(0,10)}.pdf`);
    };
    reader.readAsDataURL(blob);
  });
});
}

function renderChart(fileDataSection) {
    const chartWrapper = fileDataSection.chartWrapper;
    const canvas = chartWrapper.querySelector('.chart-canvas');
    const chartType = fileDataSection.chartControls.querySelector('.chart-type').value;
    const xAxisCol = fileDataSection.chartControls.querySelector('.x-axis-select').value;

    // Get selected Y-axis columns from buttons
    const selectedYButtons = fileDataSection.chartControls.querySelectorAll('.y-axis-btn.selected');
    const yAxisCols = Array.from(selectedYButtons).map(btn => btn.dataset.value);

    if (!xAxisCol || yAxisCols.length === 0) {
        showStatus('Please select X and at least one Y column.', 'error');
        return;
    }

    // Destroy old chart
    destroyChart(fileDataSection);

    // Get current filtered/sorted rows
    let dataRows = fileDataSection.filteredRows || Array.from(fileDataSection.querySelector('tbody').querySelectorAll('tr'));
    if (dataRows.length === 0) {
        showStatus('No data to chart.', 'error');
        return;
    }

    // Get headers
    const headers = Array.from(fileDataSection.querySelector('thead').querySelectorAll('th'))
        .map(th => th.textContent.split('\n')[0].trim());
    const xIndex = headers.indexOf(xAxisCol);
    const yIndices = yAxisCols.map(col => headers.indexOf(col)).filter(idx => idx !== -1);

    if (xIndex === -1 || yIndices.length === 0) {
        showStatus('Invalid column selection.', 'error');
        return;
    }

    // Extract data
    const dataMap = new Map();
    const pieData = [];

    dataRows.forEach(row => {
        const cells = row.querySelectorAll('td');
        const xVal = cells[xIndex]?.textContent.trim() || 'Unknown';

        if (chartType === 'pie' || chartType === 'doughnut') {
            if (yIndices.length !== 1) {
                showStatus('Pie/Doughnut charts require exactly one Y column.', 'error');
                return;
            }
            const yVal = parseFloat(parseFormattedNumber(cells[yIndices[0]]?.textContent.trim()) || 0);
            pieData.push({ label: xVal, value: yVal });
        } else {
            if (!dataMap.has(xVal)) {
                dataMap.set(xVal, {});
            }
            const entry = dataMap.get(xVal);
            yIndices.forEach((yIdx, i) => {
                const key = yAxisCols[i];
                const val = parseFloat(parseFormattedNumber(cells[yIdx]?.textContent.trim()) || 0);
                entry[key] = (entry[key] || 0) + val;
            });
        }
    });

    // Prepare datasets
    let labels, datasets;
    if (chartType === 'pie' || chartType === 'doughnut') {
        labels = pieData.map(d => d.label);
        datasets = [{
            data: pieData.map(d => d.value),
            backgroundColor: generateColors(pieData.length)
        }];
    } else {
        labels = Array.from(dataMap.keys());
        datasets = yIndices.map((yIdx, i) => ({
            label: yAxisCols[i],
            data: labels.map(label => {
                const entry = dataMap.get(label);
                return entry ? entry[yAxisCols[i]] || 0 : 0;
            }),
            backgroundColor: `hsla(${(i * 137) % 360}, 70%, 60%, 0.7)`,
            borderColor: `hsla(${(i * 137) % 360}, 70%, 60%, 1)`,
            borderWidth: 1
        }));
    }

    // Show chart
    chartWrapper.style.display = 'block';
    const ctx = canvas.getContext('2d');

    fileDataSection.chartInstance = new Chart(ctx, {
  type: chartType,
  data: { labels, datasets },
  options: {
    responsive: true,
    maintainAspectRatio: false,
    plugins: {
      legend: { position: 'top' },
      title: { display: true, text: `Chart: ${xAxisCol} vs ${yAxisCols.join(', ')}` },
      datalabels: {
        color: '#fff',
        formatter: (value, context) => {
          const sum = context.dataset.data.reduce((acc, val) => acc + val, 0);
          const percentage = ((value / sum) * 100).toFixed(1) + '%';
          const label = context.chart.data.labels[context.dataIndex];
          return `${label}\n${percentage}`;
        },
        font: { weight: 'bold', size: 10 },
        textAlign: 'center',
        anchor: 'center'
      }
    },
    scales: (chartType === 'pie' || chartType === 'doughnut') ? {} : { y: { beginAtZero: true } }
  },
  plugins: [ChartDataLabels] // Only if plugin is global
});
}

function destroyChart(fileDataSection) {
    if (fileDataSection.chartInstance) {
        fileDataSection.chartInstance.destroy();
        fileDataSection.chartInstance = null;
    }
}

function generateColors(count) {
    return Array(count).fill().map((_, i) => `hsla(${(i * 360 / count) % 360}, 70%, 60%, 0.8)`);
}

// --- Hook into existing systems ---

// Modify setupPaginationAndStats to expose filteredRows
// Already done: fileDataSection.filteredRows is set

// Modify reapplyFilters to trigger chart update
const originalReapplyFilters = reapplyFilters;
window.reapplyFilters = function(fileDataSection, fileName, sheetName, tableHeader, tableBody) {
    originalReapplyFilters(fileDataSection, fileName, sheetName, tableHeader, tableBody);
    // Trigger chart update if visible
    if (fileDataSection.chartInstance && fileDataSection.toggleChartBtn?.dataset.expanded === 'true') {
        renderChart(fileDataSection);
    }
};

// Modify setupAdvancedSearch to trigger chart update
const originalApplyAdvancedFilter = applyAdvancedFilter;
window.applyAdvancedFilter = function(fileDataSection) {
    originalApplyAdvancedFilter(fileDataSection);
    if (fileDataSection.chartInstance && fileDataSection.toggleChartBtn?.dataset.expanded === 'true') {
        renderChart(fileDataSection);
    }

    
};

// Modify sortTableData to trigger chart update
const originalSortTableData = sortTableData;
window.sortTableData = function(fileDataSection, columnIndex, sheetName) {
    originalSortTableData(fileDataSection, columnIndex, sheetName);
    if (fileDataSection.chartInstance && fileDataSection.toggleChartBtn?.dataset.expanded === 'true') {
        setTimeout(() => renderChart(fileDataSection), 100); // Wait for DOM update
    }
    
};

function setupCharting(fileDataSection) {
    const sheetData = fileDataSection.querySelector('.sheet-data');
    const table = sheetData.querySelector('table');
    const tableHeader = table.querySelector('thead');
    const headers = Array.from(tableHeader.querySelectorAll('th')).map(th => {
        return th.textContent.split('\n')[0].trim();
    });

    const chartControls = fileDataSection.chartControls;
    const chartWrapper = fileDataSection.chartWrapper;
    const toggleChartBtn = fileDataSection.toggleChartBtn;

    if (!chartControls || !chartWrapper || !toggleChartBtn) {
        addChartControls(fileDataSection, headers);
        return;
    }

    // Update X-axis dropdown
    const xAxisSelect = chartControls.querySelector('.x-axis-select');
    const previousX = xAxisSelect.value;
    xAxisSelect.innerHTML = '';
    headers.forEach(header => {
        const opt = document.createElement('option');
        opt.value = header;
        opt.textContent = header;
        xAxisSelect.appendChild(opt);
    });
    xAxisSelect.value = headers.includes(previousX) ? previousX : (headers[0] || '');

    // Rebuild Y-axis buttons
    const yAxisContainer = chartControls.querySelector('.y-axis-container');
    const selectedValues = new Set(
        Array.from(yAxisContainer.querySelectorAll('.y-axis-btn.selected')).map(btn => btn.dataset.value)
    );
    yAxisContainer.innerHTML = '';

    headers.forEach(header => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'y-axis-btn';
        btn.dataset.value = header;
        btn.textContent = header;
        btn.style.cssText = `
            background: ${selectedValues.has(header) ? '#4facfe' : 'rgba(255,255,255,0.1)'};
            color: ${selectedValues.has(header) ? 'white' : 'white'};
            border: 1px solid rgba(255,255,255,0.3);
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        `;
        if (selectedValues.has(header)) {
            btn.classList.add('selected');
        }
        btn.addEventListener('click', function () {
            const isSelected = this.classList.toggle('selected');
            this.style.background = isSelected ? '#4facfe' : 'rgba(255,255,255,0.1)';
            this.style.color = isSelected ? 'white' : '#ddd';
        });
        yAxisContainer.appendChild(btn);
    });
}

// === FIXED & FULLY FUNCTIONAL setupStatsPanel ===
function setupStatsPanel(fileDataSection, initialHeaders, initialTableBody) {
    const statsPanel = fileDataSection.querySelector('.stats-panel');
    const toggleBtn = fileDataSection.querySelector('.stats-toggle-btn');

    // Prevent duplicate setup
    if (fileDataSection._statsSetupDone) return;
    fileDataSection._statsSetupDone = true;

    toggleBtn.addEventListener('click', () => {
        const isHidden = statsPanel.style.display === 'none' || !statsPanel.style.display;
        statsPanel.style.display = isHidden ? 'block' : 'none';
        toggleBtn.textContent = isHidden ? 'Hide Statistics' : 'Show Statistics';

        if (isHidden) return;

        // Re-compute stats for current sheet/view
        updateStatsForCurrentSheet(fileDataSection);
    });

    // Central function to compute stats for the current sheet and filter state
    function updateStatsForCurrentSheet(section) {
        const activeTab = section.querySelector('.sheet-tab.active');
        if (!activeTab) return;

        const sheetName = activeTab.textContent;
        const tableBody = section.querySelector('tbody');
        const tableHeader = section.querySelector('thead');

        if (!tableBody || !tableHeader) return;

        // Get current headers (from DOM, not cached)
        const headers = Array.from(tableHeader.querySelectorAll('th'))
            .map(th => th.textContent.split('\n')[0].trim());

        // Get all rows (original full list)
        const allRows = Array.from(tableBody.querySelectorAll('tr'));

        // Determine which rows to use
        let rowsForStats = allRows;
        if (section.currentAdvancedFilterActive && Array.isArray(section.filteredRows)) {
            rowsForStats = section.filteredRows;
        } else {
            // Check if any search input has value
            const searchInputs = tableHeader.querySelectorAll('input');
            const hasSearch = Array.from(searchInputs).some(input => input.value.trim() !== '');
            if (hasSearch && Array.isArray(section.filteredRows)) {
                rowsForStats = section.filteredRows;
            }
        }

        // Recompute stats
        computeColumnStats(section, headers, rowsForStats, sheetName);
    }

    // Hook into filter/sort updates
    const originalCallback = fileDataSection.currentFilterCallback;
    fileDataSection.currentFilterCallback = function (filteredRows) {
        if (typeof originalCallback === 'function') originalCallback(filteredRows);
        if (statsPanel.style.display === 'block') {
            updateStatsForCurrentSheet(fileDataSection);
        }
    };

    // Wrap sort function
    const originalSort = window.sortTableData;
    window.sortTableData = function (section, col, sheet) {
        originalSort(section, col, sheet);
        if (section === fileDataSection && statsPanel.style.display === 'block') {
            setTimeout(() => updateStatsForCurrentSheet(fileDataSection), 150);
        }

        
    };

    // Listen for sheet tab changes
    const sheetTabsContainer = fileDataSection.querySelector('.sheet-tabs');
    if (sheetTabsContainer) {
        sheetTabsContainer.addEventListener('click', function (e) {
            if (!e.target.classList.contains('sheet-tab')) return;
            // Wait for new sheet to load
            setTimeout(() => updateStatsForCurrentSheet(fileDataSection), 100);
        });
    }

    // Listen for column visibility changes
    const columnControls = fileDataSection.querySelector('.column-controls');
    if (columnControls) {
        columnControls.addEventListener('click', function (e) {
            if (e.target.classList.contains('column-control-btn') && statsPanel.style.display === 'block') {
                setTimeout(() => updateStatsForCurrentSheet(fileDataSection), 100);
            }
        });
    }
}

// === Reusable computeColumnStats (uses current state) ===
function computeColumnStats(fileDataSection, headers, dataRows, sheetName) {
    const statsGrid = fileDataSection.querySelector('#statsGrid');
    if (!statsGrid) return;

    statsGrid.innerHTML = '';

    // Add sheet header
    const sheetHeader = document.createElement('div');
    sheetHeader.style.cssText = 'grid-column: 1 / -1; font-weight: bold; color: #00f2fe; margin-bottom: 10px; padding-bottom: 5px; border-bottom: 1px solid rgba(255,255,255,0.3);';
    sheetHeader.textContent = `Sheet: ${sheetName}`;
    statsGrid.appendChild(sheetHeader);

    const fileName = fileDataSection.fileName;
    const dateTimeInfo = fileDataSection.dateTimeInfo?.[sheetName] || {};
    const dateCols = new Set(dateTimeInfo.dateColumns || []);

    // Get current visibility (from both hidden array and DOM)
    const tableHeader = fileDataSection.querySelector('thead');
    const headerCells = tableHeader?.querySelectorAll('th') || [];
    const hiddenColumns = new Set(hidden[fileName]?.[sheetName] || []);

    const columnVisibility = new Map();
    headers.forEach((header, idx) => {
        const th = headerCells[idx];
        const isHiddenByClass = th?.classList.contains('hidden-column');
        const isHiddenByName = hiddenColumns.has(header);
        columnVisibility.set(header, !(isHiddenByClass || isHiddenByName));
    });

    // Compute stats per visible column
    headers.forEach((header, colIndex) => {
        if (!columnVisibility.get(header)) return;

        const cellValues = dataRows
            .map(row => {
                const cell = row.cells[colIndex];
                return cell ? cell.textContent.trim() : '';
            })
            .filter(val => val !== '');

        const isDateCol = dateCols.has(colIndex);
        const statItem = document.createElement('div');
        statItem.className = 'stat-item';
        statItem.innerHTML = `<div class="stat-label">${header}</div>`;

        if (isDateCol) {
    const dates = cellValues.map(parseDate).filter(d => d);
    if (dates.length > 0) {
        const minDate = new Date(Math.min(...dates));
        const maxDate = new Date(Math.max(...dates));
        const avgTime = dates.reduce((sum, d) => sum + d.getTime(), 0) / dates.length;
        const avgDate = new Date(avgTime);

        statItem.innerHTML += `
            <div class="stat-value">Min: ${minDate.toLocaleDateString()}</div>
            <div class="stat-value">Max: ${maxDate.toLocaleDateString()}</div>
            <div class="stat-value">Avg: ${avgDate.toLocaleDateString()}</div>
            <div class="stat-value">Range: ${minDate.toLocaleDateString()} â†’ ${maxDate.toLocaleDateString()}</div>
            <div class="stat-value">Count: ${dates.length}</div>
            <div class="stat-value">Span: ${Math.ceil((maxDate - minDate) / (24 * 60 * 60 * 1000))} days</div>
        `;
    } else {
        statItem.innerHTML += `<div class="stat-value">No valid dates</div>`;
    }

        } else {
            const parsedNumbers = cellValues
                .map(v => parseFormattedNumber(v))
                .filter(n => n !== null && !isNaN(n));

            if (parsedNumbers.length > 0) {
                const sum = parsedNumbers.reduce((a, b) => a + b, 0);
                const avg = sum / parsedNumbers.length;
                const sorted = [...parsedNumbers].sort((a, b) => a - b);
                const median = sorted.length % 2 === 0
                    ? (sorted[sorted.length / 2 - 1] + sorted[sorted.length / 2]) / 2
                    : sorted[Math.floor(sorted.length / 2)];
                const variance = parsedNumbers.reduce((acc, val) => acc + Math.pow(val - avg, 2), 0) / parsedNumbers.length;
                const stdDev = Math.sqrt(variance);

                statItem.innerHTML += `
                    <div class="stat-value">Avg: ${avg.toFixed(2)}</div>
                    <div class="stat-value">Sum: ${sum.toFixed(2)}</div>
                    <div class="stat-value">Min: ${sorted[0].toFixed(2)} | Max: ${sorted[sorted.length - 1].toFixed(2)}</div>
                    <div class="stat-value">Median: ${median.toFixed(2)}</div>
                    <div class="stat-value">Std Dev: ${stdDev.toFixed(2)}</div>
                    <div class="stat-value">Count: ${parsedNumbers.length}</div>
                `;
            } else {
                const uniqueValues = new Set(cellValues);
                statItem.innerHTML += `
                    <div class="stat-value">Unique: ${uniqueValues.size}</div>
                    <div class="stat-value">Total: ${cellValues.length}</div>
                `;
            }
        }
        statsGrid.appendChild(statItem);
    });
}

// Add this function to extract the Google Sheets ID from URL
function getGoogleSheetsId(url) {
    // Handle various Google Sheets URL formats
    const patterns = [
        /docs\.google\.com\/spreadsheets\/d\/([a-zA-Z0-9-_]+)/,
        /spreadsheets\/d\/([a-zA-Z0-9-_]+)/,
        /key=([a-zA-Z0-9-_]+)/
    ];
    
    for (const pattern of patterns) {
        const match = url.match(pattern);
        if (match && match[1]) {
            return match[1];
        }
    }
    return null;
}

// Add this function to handle loading from URL
async function loadFromUrl() {
    const url = urlInput.value.trim();
    if (!url) {
        showStatus('Please enter a URL', 'error');
        return;
    }
    
    showStatus('Processing URL...', 'success');
    loadUrlBtn.disabled = true;
    
    try {
        let arrayBuffer;
        let fileName = 'web_file.xlsx';
        
        // Check if it's a Google Sheets URL
        const googleSheetsId = getGoogleSheetsId(url);
        if (googleSheetsId) {
            // Convert Google Sheets URL to export URL
            const exportUrl = `https://docs.google.com/spreadsheets/d/${googleSheetsId}/export?format=xlsx`;
            fileName = `google_sheet_${googleSheetsId}.xlsx`;
            
            showStatus('Fetching Google Sheet...', 'success');
            const response = await fetch(exportUrl);
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            arrayBuffer = await response.arrayBuffer();
        } else {
            // Assume it's a direct file URL
            showStatus('Fetching file...', 'success');
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            // Try to get filename from URL or headers
            const contentDisposition = response.headers.get('content-disposition');
            if (contentDisposition) {
                const filenameMatch = contentDisposition.match(/filename[^;=\n]*=.*((['"]).*?\2|[^;\n]*)/);
                if (filenameMatch && filenameMatch[1]) {
                    fileName = filenameMatch[1].replace(/['"]/g, '');
                }
            } else {
                // Extract filename from URL path
                const urlParts = url.split('/');
                const lastPart = urlParts[urlParts.length - 1];
                if (lastPart && lastPart.includes('.')) {
                    fileName = lastPart.split('?')[0]; // Remove query parameters
                }
            }
            
            arrayBuffer = await response.arrayBuffer();
        }
        
        // Process the fetched file just like uploaded files
        await processSingleUrlFile(arrayBuffer, fileName);
        showStatus(`Successfully loaded ${fileName}`, 'success');
    } catch (error) {
        showStatus(`Error loading URL: ${error.message}`, 'error');
        console.error('URL loading error:', error);
    } finally {
        loadUrlBtn.disabled = false;
    }
}

// Add this function to process a single file from URL
async function processSingleUrlFile(arrayBuffer, fileName) {
    try {
        showStatus(`Analyzing formats for ${fileName}...`, 'success');
        // Create a blob from the array buffer to use with detectDateTimeFormats
        const blob = new Blob([arrayBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
        
        // Create a File object
        const file = new File([blob], fileName, { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
        
        const dateTimeInfo = await detectDateTimeFormats(file);
        console.log(`Date/Time Info for ${fileName}:`, dateTimeInfo);
        
        const fileDataSectionFragment = fileDataSectionTemplate.content.cloneNode(true);
        const fileDataSection = fileDataSectionFragment.querySelector('.file-data-section');
        fileDataSection.fileName = fileName;
        fileDataSection.dateTimeInfo = dateTimeInfo;
        const deleteBtn = fileDataSection.querySelector('.delete-section-btn');
        deleteBtn.addEventListener('click', () => deleteFileSection(fileDataSection));
        const fileTitle = fileDataSection.querySelector('.file-title');
        fileTitle.textContent = `Data from: ${fileName}`;
        const sheetTabsContainer = fileDataSection.querySelector('.sheet-tabs');
        const table = fileDataSection.querySelector('table');
        const tableHeader = table.querySelector('thead');
        const tableBody = table.querySelector('tbody');
        const noDataMessage = fileDataSection.querySelector('.no-data');
        const columnControls = fileDataSection.querySelector('.column-controls');
        if (!hidden[fileName]) hidden[fileName] = {};
        if (!sortingState[fileName]) sortingState[fileName] = {};
        
        // Store the array buffer directly
        fileDataSection.fileDataArrayBuffer = arrayBuffer;
        fileDataSection.workbook = null; // Will be parsed on demand
        
        // Read workbook structure to get sheet names
        const tempWorkbook = XLSX.read(arrayBuffer, { type: 'array', bookSheets: true, cellDates: true });
        const sheetNames = tempWorkbook.SheetNames;
        if (sheetNames.length === 0) {
            noDataMessage.style.display = 'block';
            table.style.display = 'none';
            columnControls.style.display = 'none';
        } else {
            noDataMessage.style.display = 'none';
            table.style.display = 'table';
            columnControls.style.display = 'flex';
            // Create tabs
            sheetNames.forEach((sheetName, tabIndex) => {
                const tab = document.createElement('div');
                tab.className = 'sheet-tab';
                if (tabIndex === 0) tab.classList.add('active');
                tab.textContent = sheetName;
                tab.addEventListener('click', function () {
                    // Lazy load sheet data when tab is clicked
                    loadSheetData(sheetName, fileDataSection, sheetTabsContainer, tableHeader, tableBody, columnControls, fileName, () => {
                    });
                      // === CLOSE PIVOT TABLE WHEN SWITCHING TABS ===
                                const pivotContainer = fileDataSection.querySelector('.pivot-container');
                                const togglePivotBtn = fileDataSection.querySelector('.toggle-pivot-btn');

                                if (pivotContainer && togglePivotBtn) {
                                    pivotContainer.style.display = 'none';
                                    togglePivotBtn.textContent = 'ðŸ“Š Pivot Analyzer';
                                }
                });
                sheetTabsContainer.appendChild(tab);
            });
            // Load first sheet immediately
            loadSheetData(sheetNames[0], fileDataSection, sheetTabsContainer, tableHeader, tableBody, columnControls, fileName);
        }
        dataSectionContainer.appendChild(fileDataSection);
        addFormattingControls(fileDataSection);
        
    } catch (err) {
        console.error('Error processing file from URL:', err);
        showStatus(`Error processing ${fileName}.`, 'error');
    }
}

// Add event listener for the URL input
function setupUrlEventListener() {
    loadUrlBtn.addEventListener('click', loadFromUrl);
    
    // Allow pressing Enter in the URL input
    urlInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            loadFromUrl();
        }
    });
}






// Add new function to create formatting controls
function addFormattingControls(fileDataSection) {
    const sheetData = fileDataSection.querySelector('.sheet-data');
    
    // Create format button
    const formatBtn = document.createElement('button');
    formatBtn.className = 'format-btn';
    formatBtn.textContent = 'ðŸŽ¨ Format Rows';
    formatBtn.style.cssText = `
        background: rgba(79, 172, 254, 0.3);
        color: white;
        border: 1px solid rgba(255, 255, 255, 0.3);
        padding: 8px 16px;
        border-radius: 5px;
        cursor: pointer;
        margin-bottom: 10px;
        font-size: 0.9rem;
    `;
    
    // Create modal container
    const modal = document.createElement('div');
    modal.className = 'format-modal';
    modal.style.cssText = `
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        z-index: 1000;
        justify-content: center;
        align-items: center;
    `;
    
    modal.innerHTML = `
        <div class="format-modal-content" style="
            background: #2c3e50;
            padding: 20px;
            border-radius: 10px;
            width: 90%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            color: white;
        ">
            <h3 style="margin-top: 0; color: #4facfe;">Format Rows</h3>
            
            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px;">Select Column:</label>
                <select class="format-column-select" style="
                    width: 100%;
                    padding: 8px;
                    border-radius: 4px;
                    border: 1px solid rgba(255, 255, 255, 0.3);
                    background-color: rgba(255, 255, 255, 0.1);
                    color: white;
                "></select>
            </div>
            
            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px;">Text Color:</label>
                <input type="color" class="text-color-picker" value="#ffffff" style="width: 60px; height: 40px;">
            </div>
            
            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px;">Background Color:</label>
                <input type="color" class="bg-color-picker" value="#000000" style="width: 60px; height: 40px;">
            </div>
            
            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px;">Font Weight:</label>
                <select class="font-weight-select" style="
                    width: 100%;
                    padding: 8px;
                    border-radius: 4px;
                    border: 1px solid rgba(255, 255, 255, 0.3);
                    background-color: rgba(255, 255, 255, 0.1);
                    color: white;
                ">
                    <option value="normal">Normal</option>
                    <option value="bold">Bold</option>
                    <option value="bolder">Bolder</option>
                    <option value="lighter">Lighter</option>
                </select>
            </div>
            
            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px;">Font Style:</label>
                <select class="font-style-select" style="
                    width: 100%;
                    padding: 8px;
                    border-radius: 4px;
                    border: 1px solid rgba(255, 255, 255, 0.3);
                    background-color: rgba(255, 255, 255, 0.1);
                    color: white;
                ">
                    <option value="normal">Normal</option>
                    <option value="italic">Italic</option>
                    <option value="oblique">Oblique</option>
                </select>
            </div>
            
            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px;">Text Decoration:</label>
                <select class="text-decoration-select" style="
                    width: 100%;
                    padding: 8px;
                    border-radius: 4px;
                    border: 1px solid rgba(255, 255, 255, 0.3);
                    background-color: rgba(255, 255, 255, 0.1);
                    color: white;
                ">
                    <option value="none">None</option>
                    <option value="underline">Underline</option>
                    <option value="overline">Overline</option>
                    <option value="line-through">Line Through</option>
                </select>
            </div>
            
            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px;">Apply to:</label>
                <div style="display: flex; gap: 15px;">
                    <label><input type="radio" name="apply-to" value="all" checked> All Rows</label>
                    <label><input type="radio" name="apply-to" value="filtered"> Filtered Rows Only</label>
                </div>
            </div>
            
            <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
                <button class="clear-all-format" style="
                    background: rgba(255, 165, 0, 0.3);
                    color: white;
                    border: none;
                    padding: 8px 16px;
                    border-radius: 4px;
                    cursor: pointer;
                ">Clear All Format</button>
                <button class="cancel-format" style="
                    background: rgba(255, 0, 0, 0.3);
                    color: white;
                    border: none;
                    padding: 8px 16px;
                    border-radius: 4px;
                    cursor: pointer;
                ">Cancel</button>
                <button class="apply-format" style="
                    background: linear-gradient(to right, #4facfe, #00f2fe);
                    color: white;
                    border: none;
                    padding: 8px 16px;
                    border-radius: 4px;
                    cursor: pointer;
                ">Apply Format</button>
            </div>
        </div>
    `;
    
    modal.querySelector('.clear-all-format').addEventListener('click', () => {
        if (!confirm('Are you sure you want to clear all formatting from this table?')) return;

        const tableBody = fileDataSection.querySelector('tbody');
        if (!tableBody) {
            showStatus('No table data found to clear.', 'error');
            return;
        }

        tableBody.querySelectorAll('td').forEach(cell => {
            cell.style.removeProperty('color');
            cell.style.removeProperty('background-color');
            cell.style.removeProperty('font-weight');
            cell.style.removeProperty('font-style');
            cell.style.removeProperty('text-decoration');
        });

        fileDataSection.rowFormatting = [];
        modal.style.display = 'none';
        showStatus('All formatting cleared.', 'success');
        });

    // Add elements to DOM
    sheetData.parentNode.insertBefore(formatBtn, sheetData);
    document.body.appendChild(modal);
    
    // Populate column dropdown
    function populateColumnSelect() {
        const select = modal.querySelector('.format-column-select');
        select.innerHTML = '';
        
        const thead = fileDataSection.querySelector('thead');
        if (!thead) return;
        
        const headers = thead.querySelectorAll('th');
        headers.forEach((th, index) => {
            if (th.style.display !== 'none') {  // Skip hidden columns
                const headerText = th.textContent.split('â–²')[0].split('â–¼')[0].trim();
                const option = document.createElement('option');
                option.value = index;
                option.textContent = headerText;
                select.appendChild(option);
            }
        });
    }
    
    // Event listeners
    formatBtn.addEventListener('click', () => {
        populateColumnSelect();
        modal.style.display = 'flex';
    });
    
    modal.querySelector('.cancel-format').addEventListener('click', () => {
        modal.style.display = 'none';
    });
    
    // Close modal when clicking outside
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            modal.style.display = 'none';
        }
    });
    
    // Apply format button
    modal.querySelector('.apply-format').addEventListener('click', () => {
        const columnSelect = modal.querySelector('.format-column-select');
        const textColor = modal.querySelector('.text-color-picker').value;
        const bgColor = modal.querySelector('.bg-color-picker').value;
        const fontWeight = modal.querySelector('.font-weight-select').value;
        const fontStyle = modal.querySelector('.font-style-select').value;
        const textDecoration = modal.querySelector('.text-decoration-select').value;
        const applyTo = modal.querySelector('input[name="apply-to"]:checked').value;
        
        const columnIndex = parseInt(columnSelect.value);
        const tableBody = fileDataSection.querySelector('tbody');
        
        if (!tableBody || isNaN(columnIndex)) {
            showStatus('Please select a valid column', 'error');
            return;
        }
        
        // Get rows to format
        let rowsToFormat = [];
        if (applyTo === 'filtered') {
            // Use filtered rows if available
            if (fileDataSection.filteredRows && fileDataSection.filteredRows.length > 0) {
                rowsToFormat = fileDataSection.filteredRows;
            } else {
                // Fall back to visible rows
                rowsToFormat = Array.from(tableBody.querySelectorAll('tr')).filter(row => 
                    row.style.display !== 'none'
                );
            }
        } else {
            // Apply to all rows
            rowsToFormat = Array.from(tableBody.querySelectorAll('tr'));
        }
        
        // Apply formatting to selected column cells
        rowsToFormat.forEach(row => {
            const cell = row.cells[columnIndex];
            if (cell) {
                cell.style.color = textColor;
                cell.style.backgroundColor = bgColor;
                cell.style.fontWeight = fontWeight;
                cell.style.fontStyle = fontStyle;
                cell.style.textDecoration = textDecoration;
            }
        });
        
        // Store formatting in a data attribute for persistence
        if (!fileDataSection.rowFormatting) {
            fileDataSection.rowFormatting = [];
        }
        
        // Save this formatting rule
        const formatRule = {
            column: columnIndex,
            textColor,
            bgColor,
            fontWeight,
            fontStyle,
            textDecoration,
            applyTo
        };
        
        fileDataSection.rowFormatting.push(formatRule);
        
        modal.style.display = 'none';
        showStatus(`Formatted ${rowsToFormat.length} rows`, 'success');
    });
}








window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>