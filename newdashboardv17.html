<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-File Excel Uploader - Enhanced with Column Hiding</title>
    <script src="https://cdn.sheetjs.com/xlsx-0.20.2/package/dist/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #1a2a6c);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 90%;
            margin: 0 auto;
            padding: 20px;
        }
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        h1 {
            font-size: 2.8rem;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
            max-width: 700px;
            margin: 0 auto;
        }
        .upload-section {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .upload-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        .file-input-wrapper {
            position: relative;
            width: 100%;
            max-width: 500px;
        }
        .file-input {
            width: 100%;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            color: white;
            font-size: 1.1rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .file-input:hover {
            background: rgba(0, 0, 0, 0.4);
            border-color: rgba(255, 255, 255, 0.5);
        }
        .file-input input {
            display: none;
        }
        .upload-btn {
            background: linear-gradient(to right, #4facfe, #00f2fe);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.2rem;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        .upload-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }
        .upload-btn:active {
            transform: translateY(1px);
        }
        .upload-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        .status {
            margin-top: 15px;
            font-size: 1.1rem;
            min-height: 25px;
        }
        .success {
            color: #7fff00;
        }
        .error {
            color: #ff4d4d;
        }
        .file-list {
            width: 100%;
            max-width: 600px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
            max-height: 200px;
            overflow-y: auto;
        }
        .file-item {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
            margin-bottom: 8px;
            align-items: center;
        }
        .file-item:last-child {
            margin-bottom: 0;
        }
        .file-name {
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            padding-right: 10px;
        }
        .remove-file {
            background: rgba(255, 0, 0, 0.3);
            border: none;
            color: white;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .remove-file:hover {
            background: rgba(255, 0, 0, 0.5);
        }
        .info-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        .info-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .info-card h2 {
            margin-bottom: 15px;
            font-size: 1.5rem;
            color: #4facfe;
        }
        .info-card ul {
            padding-left: 20px;
        }
        .info-card li {
            margin-bottom: 10px;
            line-height: 1.5;
        }
        /* Container for all file data sections */
        .data-section-container {
            display: flex;
            flex-direction: column;
            gap: 30px; /* Space between file sections */
        }
        /* Individual file data section */
        .file-data-section {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative; /* Needed for absolute positioning of delete button */
        }
        .file-data-section h2 {
            margin-bottom: 20px;
            font-size: 1.8rem;
            color: #00f2fe;
            word-break: break-all; /* Handle long filenames */
            padding-right: 40px; /* Make space for the delete button */
        }
        /* --- Add Delete Button Styles --- */
        .delete-section-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 0, 0, 0.3);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.3s ease;
        }
        .delete-section-btn:hover {
            background: rgba(255, 0, 0, 0.5);
        }
        /* --- End Delete Button Styles --- */
        .sheet-tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }
        .sheet-tab {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px 20px;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .sheet-tab.active {
            background: linear-gradient(to right, #4facfe, #00f2fe);
            color: white;
        }
        .sheet-tab:hover:not(.active) {
            background: rgba(0, 0, 0, 0.5);
        }
        .sheet-data {
            overflow-x: auto;
            max-height: 100vh;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 15px;
            display: flex;
            flex-direction: column;
        }
        .table-container {
            overflow-y: auto;
            max-height: 600px;
            flex-grow: 1;
        }
        .table-container table {
            width: 100%;
            border-collapse: collapse;
            min-width: 600px;
        }
        .table-container thead th {
            position: sticky;
            top: 0;
            background: rgba(31, 27, 27, 0.911);
            z-index: 1;
            font-weight: 600;
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
        }
        /*
        .table-container thead th:hover {
            background: rgba(255, 255, 255, 0.2);
        }*/
        .table-container tbody td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        .table-container tr:nth-child(even) {
            background: rgba(255, 255, 255, 0.05);
        }
        .table-container tr:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        /* Hidden column class */
        .hidden-column {
            display: none;
        }
        /* Column visibility controls */
        .column-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
        }
        .column-control-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 6px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }
        .column-control-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        .column-control-btn.hidden {
            background: rgba(255, 0, 0, 0.3);
            border-color: rgba(255, 0, 0, 0.5);
        }
        .column-control-btn.hidden::after {
            content: " (Hidden)";
            font-size: 0.8em;
            opacity: 0.8;
        }
        .controls {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        .clear-btn {
            background: rgba(255, 0, 0, 0.3);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .clear-btn:hover {
            background: rgba(255, 0, 0, 0.5);
        }
        footer {
            text-align: center;
            margin-top: 30px;
            padding: 20px;
            font-size: 0.9rem;
            opacity: 0.8;
        }
        @media (max-width: 768px) {
            h1 {
                font-size: 2.2rem;
            }
            .upload-section, .info-card, .file-data-section {
                padding: 20px;
            }
            .info-section {
                grid-template-columns: 1fr;
            }
            .controls {
                flex-direction: column;
            }
            /* --- Responsive Delete Button --- */
            .file-data-section h2 {
                 padding-right: 0;
            }
            .delete-section-btn {
                position: relative;
                top: auto;
                right: auto;
                margin-top: 10px;
                align-self: flex-end;
            }
            /* --- End Responsive Delete Button --- */
        }
        /* Search input styling */
.table-container thead th input {
    width: 100%;
    padding: 5px;
    margin-top: 5px;
    border-radius: 4px;
    border: 1px solid rgba(255, 255, 255, 0.3);
    background-color: rgba(255, 255, 255, 0.1);
    color: white;
}

.table-container thead th input::placeholder {
    color: rgba(255, 255, 255, 0.5);
}

.table-container thead th input:focus {
    outline: none;
    border-color: #4facfe;
    background-color: rgba(255, 255, 255, 0.2);
}
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Multi-File Excel Uploader</h1>
            <p class="subtitle">Upload multiple Excel, CSV, or spreadsheet files to view and manage sheet data in real-time</p>
        </header>
        <section class="upload-section">
            <div class="upload-container">
                <div class="file-input-wrapper">
                    <div class="file-input" id="dropZone">
                        <span id="fileText">Drag & drop files here or click to browse</span>
                        <input type="file" id="fileInput" accept=".xlsx,.xls,.csv" multiple>
                    </div>
                </div>
                <button class="upload-btn" id="uploadBtn" disabled>Process Files</button>
                <div class="status" id="status"></div>
                <div class="file-list" id="fileList"></div>
            </div>
        </section>
        <section class="info-section">
            <div class="info-card">
                <h2>Supported File Types</h2>
                <ul>
                    <li>Excel files (.xlsx, .xls)</li>
                    <li>CSV files (.csv)</li>
                    <li>OpenDocument spreadsheets (.ods)</li>
                    <li>Tab-separated values (.tsv)</li>
                </ul>
            </div>
            <div class="info-card">
                <h2>Features</h2>
                <ul>
                    <li>Upload multiple files at once</li>
                    <li>Handles large files efficiently</li>
                    <li>Clears previous data when needed</li>
                    <li>Displays data from all sheets</li>
                    <li>Responsive design for all devices</li>
                    <li><strong>Preserves original date/time formatting</strong></li>
                    <li><strong>Hide and unhide columns for each sheet individually</strong></li>
                </ul>
            </div>
        </section>
        <!-- Template for individual file data sections -->
        <template id="fileDataSectionTemplate">
            <section class="file-data-section">
                <h2 class="file-title"></h2>
                <button class="delete-section-btn">Delete File Data</button>
                <div class="sheet-tabs"></div>
                <div class="sheet-data">
                    <div class="column-controls" id="columnControls"></div>
                    <div class="table-container">
                        <table>
                            <thead></thead>
                            <tbody></tbody>
                        </table>
                    </div>
                    <div class="no-data">No data available for this file.</div>
                </div>
            </section>
        </template>
        <!-- Container for dynamically created file data sections -->
        <div class="data-section-container" id="dataSectionContainer"></div>
        <div class="controls">
            <button class="clear-btn" id="clearAllBtn">Clear All Data</button>
        </div>
        <footer>
            <p>Multi-File Excel Uploader &copy; 2023 | All data is processed locally in your browser</p>
        </footer>
    </div>
    <script>
    // DOM elements
    const fileInput = document.getElementById('fileInput');
    const dropZone = document.getElementById('dropZone');
    const fileText = document.getElementById('fileText');
    const uploadBtn = document.getElementById('uploadBtn');
    const statusDiv = document.getElementById('status');
    const fileList = document.getElementById('fileList');
    const dataSectionContainer = document.getElementById('dataSectionContainer');
    const clearAllBtn = document.getElementById('clearAllBtn');
    const fileDataSectionTemplate = document.getElementById('fileDataSectionTemplate');

    // Track hidden columns for each file and sheet
    let hidden = {};

    // --- NEW: Reusable Date/Time Detection Function ---
    async function detectDateTimeFormats(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = function (e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array', cellDates: false, cellNF: true });
                    const dateTimeInfo = {};
                    workbook.SheetNames.forEach(sheetName => {
                        const worksheet = workbook.Sheets[sheetName];
                        const dateColumns = new Set();
                        const timeColumns = new Set();
                        const range = XLSX.utils.decode_range(worksheet['!ref']);
                        for (let R = range.s.r; R <= range.e.r; ++R) {
                            for (let C = range.s.c; C <= range.e.c; ++C) {
                                const cellAddress = XLSX.utils.encode_cell({ r: R, c: C });
                                const cell = worksheet[cellAddress];
                                if (cell && cell.t === 'n' && typeof cell.z === 'string') {
                                    const format = cell.z.toLowerCase();
                                    if (
                                        format.includes('yy') || format.includes('yyyy') ||
                                        format.includes('mm') || format.includes('mmm') ||
                                        format.includes('dd') || format.includes('d') ||
                                        format.includes('date') ||
                                        /\[(h|m|s)\]/.test(format) ||
                                        (format.includes(':') && (format.includes('h') || format.includes('m') || format.includes('s')))
                                    ) {
                                        if (format.includes(':') || /\[(h|m|s)\]/.test(format)) {
                                            timeColumns.add(C);
                                        } else {
                                            dateColumns.add(C);
                                        }
                                    }
                                }
                            }
                        }
                        dateTimeInfo[sheetName] = {
                            dateColumns: Array.from(dateColumns),
                            timeColumns: Array.from(timeColumns)
                        };
                    });
                    resolve(dateTimeInfo);
                } catch (error) {
                    reject(error);
                }
            };
            reader.onerror = () => reject(new Error("Failed to read file"));
            reader.readAsArrayBuffer(file);
        });
    }

    // --- NEW: Reusable Delete Function ---
    function deleteFileSection(sectionElement) {
        const sectionToDelete = sectionElement || this.closest('.file-data-section');
        if (!sectionToDelete) return;

        const fileTitleElement = sectionToDelete.querySelector('.file-title');
        const fileName = fileTitleElement ? fileTitleElement.textContent.replace('Data from: ', '') : 'this file';

        const userConfirmed = confirm(`Are you sure you want to delete the data for "${fileName}"?`);
        if (userConfirmed) {
            if (sectionToDelete.fileName) delete hidden[sectionToDelete.fileName];
            sectionToDelete.fileDataArrayBuffer = null;
            sectionToDelete.dateTimeInfo = null;
            sectionToDelete.remove();
            showStatus(`Data for "${fileName}" deleted.`, 'success');
        }
    }

    // Initialize the application
    function init() {
        setupEventListeners();
    }

    function setupEventListeners() {
        fileInput.addEventListener('change', handleFileSelect);
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.style.borderColor = '#4facfe';
            dropZone.style.backgroundColor = 'rgba(0, 0, 0, 0.4)';
        });
        dropZone.addEventListener('dragleave', () => {
            dropZone.style.borderColor = 'rgba(255, 255, 255, 0.3)';
            dropZone.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';
        });
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.style.borderColor = 'rgba(255, 255, 255, 0.3)';
            dropZone.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';
            if (e.dataTransfer.files.length) {
                fileInput.files = e.dataTransfer.files;
                handleFileSelect();
            }
        });
        uploadBtn.addEventListener('click', processFiles);
        clearAllBtn.addEventListener('click', clearAllData);
    }

    function handleFileSelect() {
        const files = fileInput.files;
        if (files.length > 0) {
            fileText.textContent = `${files.length} file(s) selected`;
            uploadBtn.disabled = false;
            statusDiv.textContent = '';
            statusDiv.className = 'status';
            updateFileList();
        } else {
            fileText.textContent = 'Drag & drop files here or click to browse';
            uploadBtn.disabled = true;
            fileList.innerHTML = '';
        }
    }

    function updateFileList() {
        fileList.innerHTML = '';
        Array.from(fileInput.files).forEach((file, index) => {
            const fileItem = document.createElement('div');
            fileItem.className = 'file-item';
            const fileName = document.createElement('div');
            fileName.className = 'file-name';
            fileName.textContent = file.name;
            const removeBtn = document.createElement('button');
            removeBtn.className = 'remove-file';
            removeBtn.innerHTML = '&times;';
            removeBtn.addEventListener('click', () => removeFile(index));
            fileItem.appendChild(fileName);
            fileItem.appendChild(removeBtn);
            fileList.appendChild(fileItem);
        });
    }

    function removeFile(index) {
        const dt = new DataTransfer();
        const files = fileInput.files;
        for (let i = 0; i < files.length; i++) {
            if (i !== index) {
                dt.items.add(files[i]);
            }
        }
        fileInput.files = dt.files;
        handleFileSelect();
    }

    function processFiles() {
        const files = fileInput.files;
        if (files.length === 0) return;

        showStatus('Processing files...', 'success');
        uploadBtn.disabled = true;
        processFileBatch(Array.from(files), 0);
    }

    async function processFileBatch(files, index) {
        if (index >= files.length) {
            showStatus(`Processed ${files.length} files successfully!`, 'success');
            uploadBtn.disabled = false;
            return;
        }

        const file = files[index];
        try {
            showStatus(`Analyzing formats for ${file.name}...`, 'success');
            const dateTimeInfo = await detectDateTimeFormats(file);
            console.log(`Date/Time Info for ${file.name}:`, dateTimeInfo);

            const reader = new FileReader();
            reader.onload = async function(e) {
                try {
                    const arrayBuffer = e.target.result;

                    const fileDataSectionFragment = fileDataSectionTemplate.content.cloneNode(true);
                    const fileDataSection = fileDataSectionFragment.querySelector('.file-data-section');
                    fileDataSection.fileName = file.name;
                    fileDataSection.dateTimeInfo = dateTimeInfo;

                    const deleteBtn = fileDataSection.querySelector('.delete-section-btn');
                    deleteBtn.addEventListener('click', () => deleteFileSection(fileDataSection));

                    const fileTitle = fileDataSection.querySelector('.file-title');
                    fileTitle.textContent = `Data from: ${file.name}`;

                    const sheetTabsContainer = fileDataSection.querySelector('.sheet-tabs');
                    const table = fileDataSection.querySelector('table');
                    const tableHeader = table.querySelector('thead');
                    const tableBody = table.querySelector('tbody');
                    const noDataMessage = fileDataSection.querySelector('.no-data');
                    const columnControls = fileDataSection.querySelector('.column-controls');

                    if (!hidden[file.name]) hidden[file.name] = {};

                    // Store raw ArrayBuffer for lazy loading
                    fileDataSection.fileDataArrayBuffer = arrayBuffer;
                    fileDataSection.workbook = null; // Will be parsed on demand

                    // Read workbook structure to get sheet names
                    const tempWorkbook = XLSX.read(arrayBuffer, { type: 'array', bookSheets: true , cellDates: true });
                    const sheetNames = tempWorkbook.SheetNames;

                    if (sheetNames.length === 0) {
                        noDataMessage.style.display = 'block';
                        table.style.display = 'none';
                        columnControls.style.display = 'none';
                    } else {
                        noDataMessage.style.display = 'none';
                        table.style.display = 'table';
                        columnControls.style.display = 'flex';

                        // Create tabs
                        sheetNames.forEach((sheetName, tabIndex) => {
                            const tab = document.createElement('div');
                            tab.className = 'sheet-tab';
                            if (tabIndex === 0) tab.classList.add('active');
                            tab.textContent = sheetName;
                            tab.addEventListener('click', function() {
                                // Lazy load sheet data when tab is clicked
                                loadSheetData(sheetName, fileDataSection, sheetTabsContainer, tableHeader, tableBody, columnControls, file.name);
                            });
                            sheetTabsContainer.appendChild(tab);
                        });

                        // Load first sheet immediately
                        loadSheetData(sheetNames[0], fileDataSection, sheetTabsContainer, tableHeader, tableBody, columnControls, file.name);
                    }

                    dataSectionContainer.appendChild(fileDataSection);
                    processFileBatch(files, index + 1);
                } catch (err) {
                    console.error('Error parsing file:', err);
                    showStatus(`Error processing ${file.name}.`, 'error');
                    processFileBatch(files, index + 1);
                }
            };
            reader.onerror = () => {
                showStatus(`Error reading ${file.name}.`, 'error');
                processFileBatch(files, index + 1);
            };
            reader.readAsArrayBuffer(file);
        } catch (err) {
            console.error('Error detecting formats:', err);
            showStatus(`Error analyzing ${file.name}. Skipping.`, 'error');
            processFileBatch(files, index + 1);
        }
    }

    // --- NEW: Lazy Load Sheet Data ---
    // --- NEW: Advanced Search Functionality ---



// Add this line in the resetAdvancedFilter function, before resetting the condition values:
function resetAdvancedFilter(fileDataSection) {
    const advancedSearchContainer = fileDataSection.querySelector('.advanced-search-container');
    const conditions = advancedSearchContainer.querySelectorAll('.condition-group');
    
    // Clear seen values for unique operator
    conditions.forEach(conditionGroup => {
        conditionGroup.seenValues = {};
    });
    
    // Rest of the function...
}


function addAdvancedSearchControls(fileDataSection) {
    // Create advanced search container
    const advancedSearchContainer = document.createElement('div');
    advancedSearchContainer.className = 'advanced-search-container';
    advancedSearchContainer.style.cssText = `
        margin: 15px 0;
        padding: 15px;
        background: rgba(0, 0, 0, 0.2);
        border-radius: 8px;
        display: none; /* Hidden by default */
    `;
    
    // Create toggle button
    const toggleBtn = document.createElement('button');
    toggleBtn.className = 'toggle-advanced-search';
    toggleBtn.textContent = 'Toggle Advanced Search';
    toggleBtn.style.cssText = `
        background: rgba(79, 172, 254, 0.3);
        color: white;
        border: 1px solid rgba(255, 255, 255, 0.3);
        padding: 8px 16px;
        border-radius: 5px;
        cursor: pointer;
        margin-bottom: 10px;
        font-size: 0.9rem;
    `;
    
    // Advanced search form
    advancedSearchContainer.innerHTML = `
        <div class="search-conditions" style="margin-bottom: 10px; max-height: 200px; overflow-y: auto;">
            <div class="condition-group" style="margin-bottom: 10px; padding: 10px; background: rgba(0, 0, 0, 0.2); border-radius: 5px;">
                <select class="condition-type" style="padding: 5px; margin-right: 5px; background: rgba(255, 255, 255, 0.1); color: #888888; border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 4px;">
                    <option value="AND">AND</option>
                    <option value="OR">OR</option>
                </select>
                <select class="column-name" style="padding: 5px; margin-right: 5px; background: rgba(255, 255, 255, 0.1); color: #888888; border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 4px; flex: 1;"></select>
                <select class="operator" style="padding: 5px; margin-right: 5px; background: rgba(255, 255, 255, 0.1); color: #888888; border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 4px;">
                    <option value="equals">=</option>
                    <option value="not-equals">!=</option>
                    <option value="greater-than">></option>
                    <option value="less-than"><</option>
                    <option value="greater-than-equal">>=</option>
                    <option value="less-than-equal"><=</option>
                    <option value="between">Between</option>
                    <option value="is-null">Is Empty</option>
                    <option value="is-not-null">Is Not Empty</option>
                    <option value="contains">Contains (Text)</option>
                    <option value="starts-with">Starts With</option>
                    <option value="ends-with">Ends With</option>
                    <option value="like">LIKE</option>
                    <option value="unique">Unique Values</option>
                </select>
                <input type="text" class="value" placeholder="Value" style="flex: 1; padding: 5px; border-radius: 4px; border: 1px solid rgba(255, 255, 255, 0.3); background-color: rgba(255, 255, 255, 0.1); color: white;">
                <button class="remove-condition" style="background: rgba(255, 0, 0, 0.3); color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer; margin-left: 5px;">✕</button>
            </div>
        </div>
        <div style="display: flex; gap: 10px;">
            <button class="add-condition-btn" style="flex: 1; background: rgba(79, 172, 254, 0.3); color: white; border: 1px solid rgba(255, 255, 255, 0.3); padding: 8px; border-radius: 5px; cursor: pointer;">
                + Add Condition
            </button>
            <button class="apply-advanced-filter" style="flex: 1; background: linear-gradient(to right, #4facfe, #00f2fe); color: white; border: none; padding: 8px; border-radius: 5px; cursor: pointer;">
                Apply Filter
            </button>
            <button class="reset-advanced-filter" style="flex: 1; background: rgba(255, 0, 0, 0.3); color: white; border: none; padding: 8px; border-radius: 5px; cursor: pointer;">
                Reset
            </button>
        </div>
    `;
    
    // Add the controls to the file data section
    const sheetData = fileDataSection.querySelector('.sheet-data');
    sheetData.parentNode.insertBefore(advancedSearchContainer, sheetData);
    sheetData.parentNode.insertBefore(toggleBtn, advancedSearchContainer);
    
    // Setup event listeners
    toggleBtn.addEventListener('click', () => {
        advancedSearchContainer.style.display = advancedSearchContainer.style.display === 'none' ? 'block' : 'none';
    });
    
    // Add initial condition event listeners
    setupConditionEvents(advancedSearchContainer, fileDataSection);
    
    // Add condition button
    const addConditionBtn = advancedSearchContainer.querySelector('.add-condition-btn');
    addConditionBtn.addEventListener('click', () => {
        const conditionGroup = document.createElement('div');
        conditionGroup.className = 'condition-group';
        conditionGroup.style.cssText = 'margin-bottom: 10px; padding: 10px; background: rgba(0, 0, 0, 0.2); border-radius: 5px;';
        
        conditionGroup.innerHTML = `
            <select class="condition-type" style="padding: 5px; margin-right: 5px; background: rgba(255, 255, 255, 0.1); color: #888888; border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 4px;">
                <option value="AND">AND</option>
                <option value="OR">OR</option>
            </select>
            <select class="column-name" style="padding: 5px; margin-right: 5px; background: rgba(255, 255, 255, 0.1); color: #888888; border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 4px; flex: 1;"></select>
            <select class="operator" style="padding: 5px; margin-right: 5px; background: rgba(255, 255, 255, 0.1); color: #888888; border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 4px;">
                <option value="equals">=</option>
                <option value="not-equals">!=</option>
                <option value="greater-than">></option>
                <option value="less-than"><</option>
                <option value="greater-than-equal">>=</option>
                <option value="less-than-equal"><=</option>
                <option value="between">Between</option>
                <option value="is-null">Is Empty</option>
                <option value="is-not-null">Is Not Empty</option>
                <option value="contains">Contains (Text)</option>
                <option value="starts-with">Starts With</option>
                <option value="ends-with">Ends With</option>
                <option value="like">LIKE</option>
                <option value="unique">Unique Values</option>
            </select>
            <input type="text" class="value" placeholder="Value" style="flex: 1; padding: 5px; border-radius: 4px; border: 1px solid rgba(255, 255, 255, 0.3); background-color: rgba(255, 255, 255, 0.1); color: white;">
            <button class="remove-condition" style="background: rgba(255, 0, 0, 0.3); color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer; margin-left: 5px;">✕</button>
        `;
        
        advancedSearchContainer.querySelector('.search-conditions').appendChild(conditionGroup);
        setupConditionEvents(advancedSearchContainer, fileDataSection);
        populateColumnNames(fileDataSection, conditionGroup);
    });
    
    // Apply filter button
    const applyFilterBtn = advancedSearchContainer.querySelector('.apply-advanced-filter');
    applyFilterBtn.addEventListener('click', () => {
        applyAdvancedFilter(fileDataSection);
    });
    
    // Reset filter button
    const resetFilterBtn = advancedSearchContainer.querySelector('.reset-advanced-filter');
    resetFilterBtn.addEventListener('click', () => {
        resetAdvancedFilter(fileDataSection);
    });
    
    return advancedSearchContainer;
}

function setupConditionEvents(advancedSearchContainer, fileDataSection) {
    // Remove condition button
    const removeButtons = advancedSearchContainer.querySelectorAll('.remove-condition');
    removeButtons.forEach(btn => {
        btn.onclick = null; // Remove any existing listeners
        btn.addEventListener('click', function() {
            if (advancedSearchContainer.querySelectorAll('.condition-group').length > 1) {
                this.closest('.condition-group').remove();
            } else {
                // Clear values instead of removing the last condition
                const group = this.closest('.condition-group');
                group.querySelector('.value').value = '';
            }
        });
    });
    
    // Populate column names for all condition groups
    const conditionGroups = advancedSearchContainer.querySelectorAll('.condition-group');
    conditionGroups.forEach(group => {
        populateColumnNames(fileDataSection, group);
    });
}

function populateColumnNames(fileDataSection, conditionGroup) {
    const columnNameSelect = conditionGroup.querySelector('.column-name');
    const previouslySelectedValue = columnNameSelect.value; // Save the current selection

    columnNameSelect.innerHTML = ''; // Clear existing options

    // Get headers from the current active sheet
    const tableHeader = fileDataSection.querySelector('thead');
    if (tableHeader) {
        const headers = tableHeader.querySelectorAll('th');
        headers.forEach(th => {
            const headerText = th.textContent.split('\n')[0]; // Extract just the header text
            const option = document.createElement('option');
            option.value = headerText;
            option.textContent = headerText;
            columnNameSelect.appendChild(option);
        });

        // Restore the previously selected value if it still exists
        if (previouslySelectedValue && Array.from(columnNameSelect.options).some(opt => opt.value === previouslySelectedValue)) {
            columnNameSelect.value = previouslySelectedValue;
        }
    }
}

// Find the applyAdvancedFilter function and replace it with this enhanced version:

function applyAdvancedFilter(fileDataSection) {
    const advancedSearchContainer = fileDataSection.querySelector('.advanced-search-container');
    const conditions = advancedSearchContainer.querySelectorAll('.condition-group');
    const tableBody = fileDataSection.querySelector('tbody');
    const bodyRows = Array.from(tableBody.querySelectorAll('tr'));

    // Reset all rows to visible
    bodyRows.forEach(row => {
        row.style.display = '';
    });

    // Get current sheet name
    const activeTab = fileDataSection.querySelector('.sheet-tab.active');
    if (!activeTab) return;
    const sheetName = activeTab.textContent;

    // Access dateTimeInfo
    const dateTimeInfo = fileDataSection.dateTimeInfo?.[sheetName];
    const dateCols = new Set(dateTimeInfo?.dateColumns || []);
    const timeCols = new Set(dateTimeInfo?.timeColumns || []);

    conditions.forEach((conditionGroup, index) => {
        const columnName = conditionGroup.querySelector('.column-name').value;
        const operator = conditionGroup.querySelector('.operator').value;
        const inputVal = conditionGroup.querySelector('.value').value.trim();
        const conditionType = conditionGroup.querySelector('.condition-type').value;

        // Skip empty value fields unless operator is 'unique', 'is-null', or 'is-not-null'
        if (!['unique', 'is-null', 'is-not-null'].includes(operator) && !inputVal) return;

        // Get column index
        const tableHeader = fileDataSection.querySelector('thead');
        const headers = Array.from(tableHeader.querySelectorAll('th'));
        const colIndex = headers.findIndex(th => {
            const headerText = th.textContent.split('\n')[0];
            return headerText === columnName;
        });
        if (colIndex === -1) return;

        // Determine if this column is a date/time column
        const isDateColumn = dateCols.has(colIndex);

        // Parse input value if needed
        let inputDate = null;
        let parsedInputValue = null;
        let isInputNumeric = false;

        if (isDateColumn && ['equals', 'not-equals', 'greater-than', 'less-than', 'greater-than-equal', 'less-than-equal', 'between'].includes(operator)) {
            inputDate = parseDate(inputVal);
            if (!inputDate && operator !== 'between') {
                showStatus(`Invalid date format: "${inputVal}"`, 'error');
                return;
            }
        } else if (!['unique', 'is-null', 'is-not-null', 'between'].includes(operator)) {
            parsedInputValue = parseFormattedNumber(inputVal);
            isInputNumeric = parsedInputValue !== null;
        }

        bodyRows.forEach((row, rowIndex) => {
            if (row.style.display === 'none' && conditionType === 'AND') return;

            const cell = row.cells[colIndex];
            if (!cell) return;

            const cellText = cell.textContent.trim();
            let matches = false;

            if (isDateColumn) {
                const cellDate = parseDate(cellText);
                if (operator === 'is-null') {
                    matches = !cellDate && !cellText;
                } else if (operator === 'is-not-null') {
                    matches = !!cellDate;
                } else if (operator === 'between') {
                    const [from, to] = inputVal.split(',').map(v => parseDate(v.trim())).filter(Boolean);
                    if (from && to) {
                        matches = cellDate && cellDate >= from && cellDate <= to;
                    } else {
                        matches = false;
                    }
                } else if (cellDate) {
                    switch (operator) {
                        case 'equals':
                            matches = cellDate.toDateString() === inputDate.toDateString();
                            break;
                        case 'not-equals':
                            matches = cellDate.toDateString() !== inputDate.toDateString();
                            break;
                        case 'greater-than':
                            matches = cellDate > inputDate;
                            break;
                        case 'less-than':
                            matches = cellDate < inputDate;
                            break;
                        case 'greater-than-equal':
                            matches = cellDate >= inputDate;
                            break;
                        case 'less-than-equal':
                            matches = cellDate <= inputDate;
                            break;
                        default:
                            matches = false;
                    }
                }
            } else {
                // Non-date column logic (existing)
                let cellValue = cellText;
                let cellNumeric = parseFormattedNumber(cellText);
                let useNumeric = isInputNumeric && cellNumeric !== null;

                switch (operator) {
                    case 'is-null':
                        matches = !cellText;
                        break;
                    case 'is-not-null':
                        matches = !!cellText;
                        break;
                    case 'equals':
                        matches = useNumeric
                            ? Math.abs(cellNumeric - parsedInputValue) < 1e-9
                            : cellText.toLowerCase() === inputVal.toLowerCase();
                        break;
                    case 'not-equals':
                        matches = useNumeric
                            ? Math.abs(cellNumeric - parsedInputValue) > 1e-9
                            : cellText.toLowerCase() !== inputVal.toLowerCase();
                        break;
                    case 'contains':
                        matches = cellText.toLowerCase().includes(inputVal.toLowerCase());
                        break;
                    case 'starts-with':
                        matches = cellText.toLowerCase().startsWith(inputVal.toLowerCase());
                        break;
                    case 'ends-with':
                        matches = cellText.toLowerCase().endsWith(inputVal.toLowerCase());
                        break;
                    case 'greater-than':
                        matches = useNumeric ? cellNumeric > parsedInputValue : false;
                        break;
                    case 'less-than':
                        matches = useNumeric ? cellNumeric < parsedInputValue : false;
                        break;
                    case 'greater-than-equal':
                        matches = useNumeric ? cellNumeric >= parsedInputValue : false;
                        break;
                    case 'less-than-equal':
                        matches = useNumeric ? cellNumeric <= parsedInputValue : false;
                        break;
                    case 'like':
                        const escaped = inputVal.replace(/[-\\^$*+?.()|[\]{}]/g, '\\$&');
                        const pattern = '^' + escaped.replace(/%/g, '.*').replace(/_/g, '.') + '$';
                        matches = new RegExp(pattern, 'i').test(cellText);
                        break;
                    case 'unique':
                        // Handled separately below
                        matches = true;
                        break;
                    default:
                        matches = false;
                }
            }

            // Apply logic based on condition index and type
            if (operator === 'unique') {
                if (index === 0) {
                    conditionGroup.seenValues = conditionGroup.seenValues || {};
                    if (conditionGroup.seenValues[cellText]) {
                        row.style.display = 'none';
                    } else {
                        conditionGroup.seenValues[cellText] = true;
                        row.style.display = '';
                    }
                } else {
                    if (conditionType === 'AND') {
                        if (!matches) row.style.display = 'none';
                    } else {
                        if (matches) row.style.display = '';
                    }
                }
            } else {
                if (index === 0) {
                    if (!matches) row.style.display = 'none';
                } else {
                    if (conditionType === 'AND') {
                        if (!matches) row.style.display = 'none';
                    } else {
                        if (matches) row.style.display = '';
                    }
                }
            }
        });
    });

    showStatus('Advanced filter applied', 'success');
}


function resetAdvancedFilter(fileDataSection) {
    const advancedSearchContainer = fileDataSection.querySelector('.advanced-search-container');
    const conditions = advancedSearchContainer.querySelectorAll('.condition-group');

    conditions.forEach((conditionGroup, index) => {
        if (index === 0) {
            conditionGroup.querySelector('.value').value = '';
            conditionGroup.seenValues = {}; // Reset unique tracking
        } else {
            if (conditionGroup.parentNode) {
                conditionGroup.remove();
            }
        }
    });

    const tableBody = fileDataSection.querySelector('tbody');
    const bodyRows = tableBody.querySelectorAll('tr');
    bodyRows.forEach(row => {
        row.style.display = '';
    });

    showStatus('Advanced filter reset', 'success');
}


function parseFormattedNumber(value) {
    if (typeof value !== 'string') value = String(value);
    value = value.trim();

    // Handle percentage: convert to decimal
    if (value.includes('%')) {
        const numericPart = value.replace(/[%$€£¥₹,]/g, '');
        const num = parseFloat(numericPart);
        return isNaN(num) ? null : num / 100;
    }

    // Extract number from currency/commas
    const numericPart = value.replace(/[$€£¥₹,]/g, '');
    const num = parseFloat(numericPart);
    return isNaN(num) ? null : num;
}

// --- Modified loadSheetData function to include advanced search ---
function loadSheetData(sheetName, fileDataSection, sheetTabsContainer, tableHeader, tableBody, columnControls, fileName) {
    // Update active tab
    sheetTabsContainer.querySelectorAll('.sheet-tab').forEach(tab => {
        tab.classList.toggle('active', tab.textContent === sheetName);
    });

    // If workbook not yet parsed, do it now
    if (!fileDataSection.workbook) {
        try {
            fileDataSection.workbook = XLSX.read(fileDataSection.fileDataArrayBuffer, { 
                type: 'array', 
                cellDates: false,
                cellNF: true,
                cellText: true
            });
        } catch (err) {
            showStatus(`Failed to parse workbook for ${fileName}.`, 'error');
            return;
        }
    }
    const workbook = fileDataSection.workbook;
    const worksheet = workbook.Sheets[sheetName];
    if (!worksheet) {
        tableBody.innerHTML = '<tr><td colspan="100">Sheet data not found.</td></tr>';
        return;
    }
    const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: '' });
    if (jsonData.length === 0) {
        tableHeader.innerHTML = '';
        tableBody.innerHTML = '<tr><td colspan="100">No data available</td></tr>';
        columnControls.innerHTML = '';
        return;
    }

    const headers = jsonData[0];

    // Render header with search
    tableHeader.innerHTML = '';
    const headerRow = document.createElement('tr');
    const searchTerms = {};
    headers.forEach((header, index) => {
        const th = document.createElement('th');
        th.dataset.columnIndex = index;
        const headerContainer = document.createElement('div');
        headerContainer.style.display = 'flex';
        headerContainer.style.flexDirection = 'column';
        const headerText = document.createElement('div');
        headerText.textContent = header || `Column ${index}`;
        headerContainer.appendChild(headerText);
        const searchInput = document.createElement('input');
        searchInput.type = 'text';
        searchInput.placeholder = 'Search...';
        searchInput.style.width = '100%';
        searchInput.style.padding = '5px';
        searchInput.style.marginTop = '5px';
        searchInput.style.borderRadius = '4px';
        searchInput.style.border = '1px solid rgba(255, 255, 255, 0.3)';
        searchInput.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';
        searchInput.style.color = 'white';
        searchInput.addEventListener('input', function() {
            const colIndex = parseInt(th.dataset.columnIndex);
            if (this.value.trim() === '') {
                delete searchTerms[colIndex];
            } else {
                searchTerms[colIndex] = this.value;
            }
            filterTableData(fileName, sheetName, tableHeader.closest('table'), searchTerms);
        });
        headerContainer.appendChild(searchInput);
        th.appendChild(headerContainer);
        headerRow.appendChild(th);
    });
    tableHeader.appendChild(headerRow);

    // Render body
    tableBody.innerHTML = '';
    for (let i = 1; i < jsonData.length; i++) {
        const row = document.createElement('tr');
        const rowData = jsonData[i];
        headers.forEach((_, cellIndex) => {
            const td = document.createElement('td');
            let displayText = '';
            const cellAddress = XLSX.utils.encode_cell({ r: i, c: cellIndex });
            const cell = worksheet[cellAddress];
            if (cell) {
                displayText = cell.w !== undefined ? cell.w : cell.v;
            } else {
                displayText = rowData[cellIndex] || '';
            }
            td.textContent = displayText;
            row.appendChild(td);
        });
        tableBody.appendChild(row);
    }

    // Initialize hidden columns
    if (!hidden[fileName][sheetName]) hidden[fileName][sheetName] = [];
    columnControls.innerHTML = '';
    headers.forEach((header, index) => {
        const headerText = header || `Column ${index}`;
        const btn = document.createElement('button');
        btn.className = 'column-control-btn';
        btn.textContent = headerText;
        btn.dataset.columnIndex = index;
        if (hidden[fileName][sheetName].includes(headerText)) btn.classList.add('hidden');
        btn.addEventListener('click', function() {
            toggleColumnVisibility(index, headerText, fileName, sheetName, tableHeader, tableBody);
            this.classList.toggle('hidden');
        });
        columnControls.appendChild(btn);
    });
    applyHiddenColumns(fileName, sheetName, tableHeader, tableBody);

    // --- NEW: Repopulate Advanced Search column dropdowns ---
    const advancedSearchContainer = fileDataSection.querySelector('.advanced-search-container');
    if (advancedSearchContainer) {
        const conditionGroups = advancedSearchContainer.querySelectorAll('.condition-group');
        conditionGroups.forEach(group => {
            const selectElement = group.querySelector('.column-name');
            if (selectElement) {
                // Clear and repopulate options
                selectElement.innerHTML = '';
                headers.forEach(header => {
                    const option = document.createElement('option');
                    option.value = header;
                    option.textContent = header;
                    selectElement.appendChild(option);
                });
            }
        });
        // Re-apply event listeners for dynamic elements
        setupConditionEvents(advancedSearchContainer, fileDataSection);
    }

    // Add advanced search controls if not already added
    if (!fileDataSection.querySelector('.advanced-search-container')) {
        addAdvancedSearchControls(fileDataSection);
    }
}

    function clearAllData() {
        dataSectionContainer.innerHTML = '';
        hidden = {};
        fileInput.value = '';
        fileText.textContent = 'Drag & drop files here or click to browse';
        uploadBtn.disabled = true;
        fileList.innerHTML = '';
        showStatus('All data cleared', 'success');
    }

    function toggleColumnVisibility(columnIndex, columnName, fileName, sheetName, tableHeader, tableBody) {
        if (!hidden[fileName][sheetName]) hidden[fileName][sheetName] = [];
        const idx = hidden[fileName][sheetName].indexOf(columnName);
        if (idx > -1) {
            hidden[fileName][sheetName].splice(idx, 1);
        } else {
            hidden[fileName][sheetName].push(columnName);
        }
        applyHiddenColumns(fileName, sheetName, tableHeader, tableBody);
        showStatus(`Column "${columnName}" ${hidden[fileName][sheetName].includes(columnName) ? 'hidden' : 'shown'}`, 'success');
    }

    function applyHiddenColumns(fileName, sheetName, tableHeader, tableBody) {
        const headerCells = Array.from(tableHeader.querySelectorAll('th'));
        const bodyRows = tableBody.querySelectorAll('tr');
        bodyRows.forEach(row => row.querySelectorAll('td').forEach(td => td.classList.remove('hidden-column')));
        headerCells.forEach(th => th.classList.remove('hidden-column'));

        if (hidden[fileName] && hidden[fileName][sheetName]) {
            hidden[fileName][sheetName].forEach(colName => {
                const colIndex = headerCells.findIndex(th => th.textContent.trim() === colName);
                if (colIndex !== -1) {
                    headerCells[colIndex].classList.add('hidden-column');
                    bodyRows.forEach(row => {
                        const cells = row.querySelectorAll('td');
                        if (cells[colIndex]) cells[colIndex].classList.add('hidden-column');
                    });
                }
            });
        }
    }

    function parseDate(value) {
      if (!value || typeof value !== 'string') return null;
      value = value.trim();

      // Handle ISO formats, slashes, dashes
      const date = new Date(value);
      return isNaN(date.getTime()) ? null : date;
    }

    function filterTableData(fileName, sheetName, table, searchTerms) {
        const bodyRows = table.querySelector('tbody').querySelectorAll('tr');
        const headers = Array.from(table.querySelector('thead').querySelectorAll('th'));
        const lowerCaseSearchTerms = {};
        Object.keys(searchTerms).forEach(k => {
            if (searchTerms[k]) lowerCaseSearchTerms[k] = searchTerms[k].toLowerCase();
        });

        bodyRows.forEach(row => {
            const cells = row.querySelectorAll('td');
            let matches = true;
            Object.keys(lowerCaseSearchTerms).forEach(colIndex => {
                const term = lowerCaseSearchTerms[colIndex];
                if (colIndex < cells.length) {
                    const text = (cells[colIndex].textContent || '').toLowerCase();
                    if (!text.includes(term)) matches = false;
                }
            });
            row.style.display = matches ? '' : 'none';
        });
        showStatus(`Filtered results applied`, 'success');
    }

    function showStatus(message, type) {
        statusDiv.textContent = message;
        statusDiv.className = `status ${type}`;
    }

    window.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>