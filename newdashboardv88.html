<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-File Excel Uploader - Enhanced with Sorting</title>
    <script src="https://cdn.sheetjs.com/xlsx-0.20.2/package/dist/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.23/jspdf.plugin.autotable.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #1a2a6c);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 90%;
            margin: 0 auto;
            padding: 20px;
        }
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        h1 {
            font-size: 2.8rem;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
            max-width: 700px;
            margin: 0 auto;
        }
        .upload-section {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .upload-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        .file-input-wrapper {
            position: relative;
            width: 100%;
            max-width: 500px;
        }
        .file-input {
            width: 100%;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            color: white;
            font-size: 1.1rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .file-input:hover {
            background: rgba(0, 0, 0, 0.4);
            border-color: rgba(255, 255, 255, 0.5);
        }
        .file-input input {
            display: none;
        }
        .upload-btn {
            background: linear-gradient(to right, #4facfe, #00f2fe);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.2rem;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        .upload-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }
        .upload-btn:active {
            transform: translateY(1px);
        }
        .upload-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        .status {
            margin-top: 15px;
            font-size: 1.1rem;
            min-height: 25px;
        }
        .success {
            color: #7fff00;
        }
        .error {
            color: #ff4d4d;
        }
        .file-list {
            width: 100%;
            max-width: 600px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
            max-height: 200px;
            overflow-y: auto;
        }
        .file-item {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
            margin-bottom: 8px;
            align-items: center;
        }
        .file-item:last-child {
            margin-bottom: 0;
        }
        .file-name {
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            padding-right: 10px;
        }
        .remove-file {
            background: rgba(255, 0, 0, 0.3);
            border: none;
            color: white;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .remove-file:hover {
            background: rgba(255, 0, 0, 0.5);
        }
        .info-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        .info-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .info-card h2 {
            margin-bottom: 15px;
            font-size: 1.5rem;
            color: #4facfe;
        }
        .info-card ul {
            padding-left: 20px;
        }
        .info-card li {
            margin-bottom: 10px;
            line-height: 1.5;
        }
        /* Container for all file data sections */
        .data-section-container {
            display: flex;
            flex-direction: column;
            gap: 30px; /* Space between file sections */
        }
        /* Individual file data section */
        .file-data-section {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative; /* Needed for absolute positioning of delete button */
        }
        .file-data-section h2 {
            margin-bottom: 20px;
            font-size: 1.8rem;
            color: #00f2fe;
            word-break: break-all; /* Handle long filenames */
            padding-right: 40px; /* Make space for the delete button */
        }
        /* --- Add Delete Button Styles --- */
        .delete-section-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 0, 0, 0.3);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.3s ease;
        }
        .delete-section-btn:hover {
            background: rgba(255, 0, 0, 0.5);
        }
        /* --- End Delete Button Styles --- */
        .sheet-tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }
        .sheet-tab {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px 20px;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .sheet-tab.active {
            background: linear-gradient(to right, #4facfe, #00f2fe);
            color: white;
        }
        .sheet-tab:hover:not(.active) {
            background: rgba(0, 0, 0, 0.5);
        }
        .sheet-data {
            overflow-x: auto;
            max-height: 100vh;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 15px;
            display: flex;
            flex-direction: column;
        }
        .table-container {
            overflow-y: auto;
            max-height: 600px;
            flex-grow: 1;
        }
        .table-container table {
            width: 100%;
            border-collapse: collapse;
            min-width: 600px;
        }
        .table-container thead th {
            position: sticky;
            top: 0;
            background: rgba(31, 27, 27, 0.911);
            z-index: 1;
            font-weight: 600;
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
            transition: background 0.3s ease;
        }
        .table-container thead th:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        .table-container thead th.sorted-asc::after {
            content: " â–²";
            color: #4facfe;
        }
        .table-container thead th.sorted-desc::after {
            content: " â–¼";
            color: #4facfe;
        }
        .table-container tbody td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        .table-container tr:nth-child(even) {
            background: rgba(255, 255, 255, 0.05);
        }
        .table-container tr:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        /* Hidden column class */
        .hidden-column {
            display: none;
        }
        /* Column visibility controls */
        .column-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
        }
        .column-control-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 6px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }
        .column-control-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        .column-control-btn.hidden {
            background: rgba(255, 0, 0, 0.3);
            border-color: rgba(255, 0, 0, 0.5);
        }
        .column-control-btn.hidden::after {
            content: " (Hidden)";
            font-size: 0.8em;
            opacity: 0.8;
        }
        .controls {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        .clear-btn {
            background: rgba(255, 0, 0, 0.3);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .clear-btn:hover {
            background: rgba(255, 0, 0, 0.5);
        }
        footer {
            text-align: center;
            margin-top: 30px;
            padding: 20px;
            font-size: 0.9rem;
            opacity: 0.8;
        }
        @media (max-width: 768px) {
            h1 {
                font-size: 2.2rem;
            }
            .upload-section, .info-card, .file-data-section {
                padding: 20px;
            }
            .info-section {
                grid-template-columns: 1fr;
            }
            .controls {
                flex-direction: column;
            }
            /* --- Responsive Delete Button --- */
            .file-data-section h2 {
                 padding-right: 0;
            }
            .delete-section-btn {
                position: relative;
                top: auto;
                right: auto;
                margin-top: 10px;
                align-self: flex-end;
            }
            /* --- End Responsive Delete Button --- */
        }
        /* Search input styling */
        .table-container thead th input {
            width: 100%;
            padding: 5px;
            margin-top: 5px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background-color: rgba(255, 255, 255, 0.1);
            color: white;
        }
        .table-container thead th input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }
        .table-container thead th input:focus {
            outline: none;
            border-color: #4facfe;
            background-color: rgba(255, 255, 255, 0.2);
        }
        .table-stats {
    font-size: 0.9rem;
    opacity: 0.9;
    display: flex;
    justify-content: space-between;
    flex-wrap: wrap;
    gap: 10px;
    margin-top: 15px;
    align-items: center;
}
.pagination-controls button {
    background: rgba(79, 172, 254, 0.3);
    color: white;
    border: 1px solid rgba(255, 255, 255, 0.3);
    padding: 6px 12px;
    border-radius: 5px;
    cursor: pointer;
    margin: 0 5px;
}
.pagination-controls button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}
.pagination-controls button:hover:not(:disabled) {
    background: rgba(79, 172, 254, 0.5);
}
.chart-controls {
    margin: 20px 0 10px;
    padding: 15px;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 8px;
    display: none; /* Hidden by default */
}
.chart-container-wrapper {
    margin-top: 15px;
    position: relative;
    height: 400px;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 8px;
    overflow: hidden;
}
.chart-container {
    height: 100%;
    width: 100%;
}
.chart-actions {
    display: flex;
    gap: 10px;
    margin-top: 10px;
}
.chart-actions select, .chart-actions button {
    padding: 8px;
    border-radius: 5px;
    border: 1px solid rgba(255, 255, 255, 0.3);
    background: rgba(255, 255, 255, 0.1);
    color: white;
}
.chart-actions button {
    background: linear-gradient(to right, #4facfe, #00f2fe);
    cursor: pointer;
    border: none;
}
.chart-actions button:hover {
    opacity: 0.9;
}
.toggle-chart-btn {
    background: rgba(79, 172, 254, 0.3);
    color: white;
    border: 1px solid rgba(255, 255, 255, 0.3);
    padding: 8px 16px;
    border-radius: 5px;
    cursor: pointer;
    margin-top: 10px;
    font-size: 0.9rem;
}
/* === Statistics Panel Styles === */
.stats-panel {
    margin-top: 15px;
    padding: 15px;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 8px;
    font-size: 0.95rem;
    line-height: 1.6;
    display: none; /* Hidden by default */
}
.stats-panel h3 {
    margin-bottom: 10px;
    color: #00f2fe;
    font-size: 1.1rem;
}
.stats-toggle-btn {
    background: rgba(79, 172, 254, 0.3);
    color: white;
    border: 1px solid rgba(255, 255, 255, 0.3);
    padding: 8px 16px;
    border-radius: 5px;
    cursor: pointer;
    margin-top: 10px;
    font-size: 0.9rem;
}
.stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 10px;
}
.stat-item {
    background: rgba(255, 255, 255, 0.05);
    padding: 8px;
    border-radius: 5px;
    white-space: nowrap;
}
.stat-label {
    font-weight: 600;
    opacity: 0.9;
}
.stat-value {
    color: #7fff00;
}
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Multi-File Excel Uploader</h1>
            <p class="subtitle">Upload multiple Excel, CSV, or spreadsheet files to view and manage sheet data in real-time</p>
        </header>
        <section class="upload-section">
            <div class="upload-container">
                <div class="file-input-wrapper">
                    <div class="file-input" id="dropZone">
                        <span id="fileText">Drag & drop files here or click to browse</span>
                        <input type="file" id="fileInput" accept=".xlsx,.xls,.csv" multiple>
                    </div>
                </div>
                <!-- Add this new section in the upload-container, right after the file input wrapper -->
                <div class="url-input-wrapper" style="width: 100%; max-width: 500px; margin: 20px 0;">
                    <div style="display: flex; gap: 10px;">
                        <input 
                            type="text" 
                            id="urlInput" 
                            placeholder="Paste Google Sheets or Excel URL here"
                            style="flex: 1; padding: 15px; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 10px; color: white; font-size: 1.1rem;"
                        >
                        <button id="loadUrlBtn" style="background: linear-gradient(to right, #4facfe, #00f2fe); color: white; border: none; padding: 15px 20px; font-size: 1.1rem; border-radius: 10px; cursor: pointer;">Load</button>
                    </div>
                    <p style="margin-top: 10px; font-size: 0.9rem; opacity: 0.8;">Supports Google Sheets links and direct Excel file URLs</p>
                </div>
                <button class="upload-btn" id="uploadBtn" disabled>Process Files</button>
                <div class="status" id="status"></div>
                <div class="file-list" id="fileList"></div>
            </div>
        </section>
        <section class="info-section">
            <div class="info-card">
                <h2>Supported File Types</h2>
                <ul>
                    <li>Excel files (.xlsx, .xls)</li>
                    <li>CSV files (.csv)</li>
                    <li>OpenDocument spreadsheets (.ods)</li>
                    <li>Tab-separated values (.tsv)</li>
                </ul>
            </div>
            <div class="info-card">
                <h2>Features</h2>
                <ul>
                    <li>Upload multiple files at once</li>
                    <li>Handles large files efficiently</li>
                    <li>Clears previous data when needed</li>
                    <li>Displays data from all sheets</li>
                    <li>Responsive design for all devices</li>
                    <li><strong>Preserves original date/time formatting</strong></li>
                    <li><strong>Hide and unhide columns for each sheet individually</strong></li>
                    <li><strong>Sort data by any column (text, numbers, dates)</strong></li>
                    <li>Advanced search with multiple conditions</li>
                </ul>
            </div>
        </section>
        <!-- Template for individual file data sections -->
        <template id="fileDataSectionTemplate">
            <section class="file-data-section">
                <h2 class="file-title"></h2>
                <button class="delete-section-btn">Delete File Data</button>
                <div class="sheet-tabs"></div>
                <div class="sheet-data">
                    <div class="column-controls" id="columnControls"></div>
                    <div class="table-container">
                        <table>
                            <thead></thead>
                            <tbody></tbody>
                        </table>
                    </div>
                    <div class="no-data">No data available for this file.</div>
                    <div class="table-stats" style="margin-top: 15px; font-size: 0.9rem; opacity: 0.9; display: flex; justify-content: space-between; flex-wrap: wrap;">
                        <div class="row-count">Rows: 0</div>
                        <div class="pagination-controls">
                            <button class="prev-page" disabled>â—€ Previous</button>
                            <span class="page-info">Page 1</span>
                            <button class="next-page">Next â–¶</button>
                        </div>
                    </div>
                    <div class="stats-panel">
                        <h3>Data Statistics</h3>
                        <div class="stats-grid" id="statsGrid"></div>
                    </div>
                    <button class="stats-toggle-btn">Show Statistics</button>
                </div>
            </section>
        </template>
        <!-- Container for dynamically created file data sections -->
        <div class="data-section-container" id="dataSectionContainer"></div>
        <div class="controls">
            <button class="clear-btn" id="clearAllBtn">Clear All Data</button>
        </div>
        <!-- Sponsor Banner Section -->
<section class="sponsor-section" style="
    margin: 30px 0;
    padding: 20px;
    background: rgba(0, 0, 0, 0.25);
    backdrop-filter: blur(8px);
    border-radius: 12px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
    border: 1px solid rgba(255, 255, 255, 0.08);
">
    <h3 style="
        text-align: center;
        font-size: 1.3rem;
        color: #4facfe;
        margin-bottom: 16px;
        font-weight: 600;
    ">âœ¨ Our Sponsors</h3>
    <div class="sponsor-logos" style="
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 20px;
        align-items: center;
    ">
        <!-- Repeat this block for each sponsor (5+ as needed) -->
        <a href="https://example.com" target="_blank" rel="noopener sponsored" 
           style="
               display: flex;
               flex-direction: column;
               align-items: center;
               text-decoration: none;
               color: #fff;
               opacity: 0.9;
               transition: opacity 0.3s, transform 0.2s;
               width: 140px;
               text-align: center;
           "
           onmouseover="this.style.opacity='1'; this.style.transform='scale(1.03)';"
           onmouseout="this.style.opacity='0.9'; this.style.transform='scale(1)';"
        >
            <div style="
                width: 80px;
                height: 80px;
                background: rgba(255, 255, 255, 0.1);
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                margin-bottom: 8px;
                overflow: hidden;
            ">
                <!-- Replace with real logo (SVG/PNG). Use `alt` for accessibility. -->
                <img src="1mc_logo.webp" 
                     alt="Sponsor Name Logo" 
                     style="max-width: 100%; max-height: 100%; object-fit: contain;"
                />
            </div>
            <small style="font-size: 0.85rem; opacity: 0.85;">Sponsor Name</small>
        </a>

        <!-- Example: Repeat 4 more times -->
        <a href="https://example2.com" target="_blank" rel="noopener sponsored" style="display:flex;flex-direction:column;align-items:center;text-decoration:none;color:#fff;opacity:0.9;transition:opacity 0.3s,transform 0.2s;width:140px;text-align:center;" onmouseover="this.style.opacity='1';this.style.transform='scale(1.03)';" onmouseout="this.style.opacity='0.9';this.style.transform='scale(1)';">
            <div style="width:80px;height:80px;background:rgba(255,255,255,0.1);border-radius:50%;display:flex;align-items:center;justify-content:center;margin-bottom:8px;overflow:hidden;">
                <img src="anhs-school.jpg" alt="Sponsor 2 Logo" style="max-width:100%;max-height:100%;object-fit:contain;" />
            </div>
            <small style="font-size:0.85rem;opacity:0.85;">Sponsor Two</small>
        </a>

        <a href="https://example3.com" target="_blank" rel="noopener sponsored" style="display:flex;flex-direction:column;align-items:center;text-decoration:none;color:#fff;opacity:0.9;transition:opacity 0.3s,transform 0.2s;width:140px;text-align:center;" onmouseover="this.style.opacity='1';this.style.transform='scale(1.03)';" onmouseout="this.style.opacity='0.9';this.style.transform='scale(1)';">
            <div style="width:100px;height:60px;background:rgba(255,255,255,0.1);border-radius:8px;display:flex;align-items:center;justify-content:center;margin-bottom:8px;overflow:hidden;">
                <img src="https://via.placeholder.com/100x60/b21f1f/ffffff?text=BIZ3" alt="Sponsor 3 Logo" style="max-width:90%;max-height:90%;object-fit:contain;" />
            </div>
            <small style="font-size:0.85rem;opacity:0.85;">Biz Sponsor</small>
        </a>

        <a href="https://example4.com" target="_blank" rel="noopener sponsored" style="display:flex;flex-direction:column;align-items:center;text-decoration:none;color:#fff;opacity:0.9;transition:opacity 0.3s,transform 0.2s;width:140px;text-align:center;" onmouseover="this.style.opacity='1';this.style.transform='scale(1.03)';" onmouseout="this.style.opacity='0.9';this.style.transform='scale(1)';">
            <div style="width:100px;height:60px;background:rgba(255,255,255,0.1);border-radius:8px;display:flex;align-items:center;justify-content:center;margin-bottom:8px;overflow:hidden;">
                <img src="https://via.placeholder.com/100x60/1a2a6c/ffffff?text=TECH" alt="Sponsor 4 Logo" style="max-width:90%;max-height:90%;object-fit:contain;" />
            </div>
            <small style="font-size:0.85rem;opacity:0.85;">Tech Co.</small>
        </a>

        <a href="https://example5.com" target="_blank" rel="noopener sponsored" style="display:flex;flex-direction:column;align-items:center;text-decoration:none;color:#fff;opacity:0.9;transition:opacity 0.3s,transform 0.2s;width:140px;text-align:center;" onmouseover="this.style.opacity='1';this.style.transform='scale(1.03)';" onmouseout="this.style.opacity='0.9';this.style.transform='scale(1)';">
            <div style="width:100px;height:60px;background:rgba(255,255,255,0.1);border-radius:8px;display:flex;align-items:center;justify-content:center;margin-bottom:8px;overflow:hidden;">
                <img src="https://via.placeholder.com/100x60/7fff00/000000?text=S5" alt="Sponsor 5 Logo" style="max-width:90%;max-height:90%;object-fit:contain;" />
            </div>
            <small style="font-size:0.85rem;opacity:0.85;">Support Inc.</small>
        </a>
    </div>
    <p style="
        text-align: center;
        font-size: 0.85rem;
        opacity: 0.7;
        margin-top: 16px;
    ">Interested in sponsoring? <a href="/sponsor.html" style="color:#00f2fe;">Learn more here</a>.</p>
</section>
        <footer>
            <p>Multi-File Excel Uploader &copy; 2025 | 
              <a href="/privacyv2.html" style="color:#4facfe;">Privacy</a> â€¢ 
              <a href="/sponsor.html" style="color:#4facfe;">Sponsor</a> â€¢ 
              All data stays in your browser.
            </p>
        </footer>
    </div>
    <script>
    // DOM elements
    const fileInput = document.getElementById('fileInput');
    const dropZone = document.getElementById('dropZone');
    const fileText = document.getElementById('fileText');
    const uploadBtn = document.getElementById('uploadBtn');
    const statusDiv = document.getElementById('status');
    const fileList = document.getElementById('fileList');
    const dataSectionContainer = document.getElementById('dataSectionContainer');
    const clearAllBtn = document.getElementById('clearAllBtn');
    const fileDataSectionTemplate = document.getElementById('fileDataSectionTemplate');
    const urlInput = document.getElementById('urlInput');
    const loadUrlBtn = document.getElementById('loadUrlBtn');
    // Track hidden columns for each file and sheet
    let hidden = {};
    
    // Track sorting state for each column
    let sortingState = {};

    


    async function detectDateTimeFormats(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = function (e) {
            try {
                const data = new Uint8Array(e.target.result);
                const workbook = XLSX.read(data, { type: 'array', cellDates: false, cellNF: true, cellText: true });
                const dateTimeInfo = {};

                // Predefined regex patterns for common date/time strings
                const dateRegexes = [
                    /\b\d{4}-\d{1,2}-\d{1,2}\s*\d{1,2}:\d{2}(:\d{2})?\s*(Z|[+-]\d{2}:\d{2})?/, // ISO: 2024-05-20 14:30
                    /\b\d{1,2}[/\-\.]\d{1,2}[/\-\.]\d{2,4}\b/, // MM/DD/YYYY, DD/MM/YY
                    /\b(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\b.*\d{1,2},?.*\d{2,4}/i, // Jan 1, 2024
                    /\b\d{1,2}\s+(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\b\s+\d{2,4}/i, // 5 Jan 2024
                    /\b\d{1,2}:\d{2}(:\d{2})?\s*(AM|PM)?\b/i, // 10:30 or 10:30 PM
                    /\b\d{4}-\d{2}-\d{2}\b/, // YYYY-MM-DD
                    /\b\d{1,2}-\d{1,2}-\d{4}\b/, // DD-MM-YYYY
                    /\b\d{8,}\b/ // Unix timestamps (8+ digits)
                ];

                // Helper: test if a string matches any date pattern
                function isDateContent(str) {
                    if (typeof str !== 'string' || !str.trim()) return false;
                    return dateRegexes.some(regex => regex.test(str.trim()));
                }

                workbook.SheetNames.forEach(sheetName => {
                    const worksheet = workbook.Sheets[sheetName];
                    const dateColumns = new Set();
                    const timeColumns = new Set();
                    const potentialDateColumns = new Map(); // Track likelihood

                    const range = XLSX.utils.decode_range(worksheet['!ref']);
                    let sampleCount = 0;
                    const maxRowsToSample = 100; // Limit for performance

                    for (let R = range.s.r; R <= range.e.r && sampleCount < maxRowsToSample; ++R) {
                        sampleCount++;
                        for (let C = range.s.c; C <= range.e.c; ++C) {
                            const cellAddress = XLSX.utils.encode_cell({ r: R, c: C });
                            const cell = worksheet[cellAddress];
                            if (!cell) continue;

                            let isDateByFormat = false;
                            let isTimeByFormat = false;
                            let isDateByContent = false;

                            // 1. Format-based detection (Excel only)
                            if (cell.z && typeof cell.z === 'string') {
                                const format = cell.z.toLowerCase();
                                if (
                                    format.includes('yy') ||
                                    format.includes('yyyy') ||
                                    format.includes('mm') ||
                                    format.includes('mmm') ||
                                    format.includes('dd') ||
                                    format.includes('d') ||
                                    format.includes('date') ||
                                    /\[(h|m|s)\]/.test(format) ||
                                    (format.includes(':') && (format.includes('h') || format.includes('m') || format.includes('s')))
                                ) {
                                    if (format.includes(':') || /\[(h|m|s)\]/.test(format)) {
                                        isTimeByFormat = true;
                                    } else {
                                        isDateByFormat = true;
                                    }
                                }
                            }

                            // 2. Content-based detection (works for CSV & formatted cells)
                            const cellText = cell.w || String(cell.v) || '';
                            if (isDateContent(cellText)) {
                                isDateByContent = true;
                            }

                            // Only count if either format OR content suggests date
                            if (isDateByFormat || isDateByContent) {
                                const score = (potentialDateColumns.get(C) || 0) + 1;
                                potentialDateColumns.set(C, score);
                            }
                            if (isTimeByFormat) {
                                timeColumns.add(C);
                            }
                        }
                    }

                    // Promote columns with sufficient "date-like" cells
                    for (const [col, score] of potentialDateColumns) {
                        if (score >= 3 || score / sampleCount > 0.1) { // At least 3 hits or 10% of rows
                            dateColumns.add(parseInt(col));
                        }
                    }

                    // Finalize
                    dateTimeInfo[sheetName] = {
                        dateColumns: Array.from(dateColumns),
                        timeColumns: Array.from(timeColumns)
                    };
                });

                resolve(dateTimeInfo);
            } catch (error) {
                reject(error);
            }
        };
        reader.onerror = () => reject(new Error("Failed to read file"));
        reader.readAsArrayBuffer(file);
    });
}

    // --- NEW: Reusable Delete Function ---
    function deleteFileSection(sectionElement) {
        const sectionToDelete = sectionElement || this.closest('.file-data-section');
        if (!sectionToDelete) return;
        const fileTitleElement = sectionToDelete.querySelector('.file-title');
        const fileName = fileTitleElement ? fileTitleElement.textContent.replace('Data from: ', '') : 'this file';
        const userConfirmed = confirm(`Are you sure you want to delete the data for "${fileName}"?`);
        if (userConfirmed) {
            if (sectionToDelete.fileName) {
                delete hidden[sectionToDelete.fileName];
                delete sortingState[sectionToDelete.fileName];
            }
            sectionToDelete.fileDataArrayBuffer = null;
            sectionToDelete.dateTimeInfo = null;
            sectionToDelete.remove();
            showStatus(`Data for "${fileName}" deleted.`, 'success');
        }
    }
    

    // === DYNAMIC PIVOT TABLE ANALYZER ===
function setupPivotAnalyzer(fileDataSection, headers, tableBody) {

    const existingToggleBtn = fileDataSection.querySelector('.toggle-pivot-btn');
    const existingPivotContainer = fileDataSection.querySelector('.pivot-container');
    
    if (existingToggleBtn) {
        existingToggleBtn.remove(); // Remove the button from the DOM
    }
    if (existingPivotContainer) {
        existingPivotContainer.remove(); // Remove the container and all its content
    }
    
    const sheetData = fileDataSection.querySelector('.sheet-data');

    // Create pivot toggle button
    const togglePivotBtn = document.createElement('button');
    togglePivotBtn.className = 'toggle-pivot-btn';
    togglePivotBtn.textContent = 'ðŸ“Š Pivot Analyzer';
    togglePivotBtn.style.cssText = `
        background: rgba(100, 200, 100, 0.3);
        color: white;
        border: 1px solid rgba(255, 255, 255, 0.3);
        padding: 8px 12px;
        border-radius: 5px;
        cursor: pointer;
        margin-top: 10px;
        display: none; /* Show only after data loads */
    `;

    // Create pivot container
    const pivotContainer = document.createElement('div');
    pivotContainer.className = 'pivot-container';
    pivotContainer.style.cssText = `
        display: none;
        margin-top: 15px;
        padding: 15px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 8px;
        overflow: auto;
        max-height: 500px;
    `;
    pivotContainer.innerHTML = `<p>Loading pivot controls...</p>`;

    // Insert into DOM
    sheetData.parentNode.insertBefore(togglePivotBtn, sheetData.nextSibling);
    sheetData.parentNode.insertBefore(pivotContainer, togglePivotBtn.nextSibling);

    // Show pivot button after data loads
    setTimeout(() => {
        togglePivotBtn.style.display = 'inline-block';
    }, 100);

    togglePivotBtn.addEventListener('click', () => {
    const isHidden = pivotContainer.style.display === 'none';
    pivotContainer.style.display = isHidden ? 'block' : 'none';
    togglePivotBtn.textContent = isHidden ? 'âŒ Close Pivot' : 'ðŸ“Š Pivot Analyzer';

    if (isHidden) {
        // Get current headers from the active table header
        const table = fileDataSection.querySelector('table');
        const tableHeader = table.querySelector('thead');
        const headers = Array.from(tableHeader.querySelectorAll('th'))
                             .map(th => th.textContent.trim());

        // Now safely call renderPivotControls with all required args
        renderPivotControls(headers, pivotContainer, fileDataSection, table.querySelector('tbody'));
    }
});

    function renderPivotControls(headers, pivotContainer, fileDataSection, tableBody) {
    // Clear loading message
    pivotContainer.innerHTML = '';

    const fields = ['(None)'].concat(headers);
    pivotContainer.innerHTML = `
  <h4 style="margin-bottom: 10px; color: #4facfe;">ðŸ“Š Pivot Table Builder</h4>
  <div style="display: grid; gap: 10px; grid-template-columns: 1fr 1fr;">
    <!-- Row, Column, Value Fields -->
    <div><label>Row Field:</label>
      <select class="pivot-row-field" style="width: 100%; padding: 6px; border-radius: 4px; background: rgba(255,255,255,0.1); color: #88888;">${fields.map(f => `<option value="${f}">${f}</option>`).join('')}</select>
    </div>
    <div><label>Column Field (Optional):</label>
      <select class="pivot-col-field" style="width: 100%; padding: 6px; border-radius: 4px; background: rgba(255,255,255,0.1); color: #88888;">${fields.map(f => `<option value="${f}">${f}</option>`).join('')}</select>
    </div>
    <div><label>Value Field:</label>
      <select class="pivot-value-field" style="width: 100%; padding: 6px; border-radius: 4px; background: rgba(255,255,255,0.1); color: #88888;">${fields.map(f => `<option value="${f}">${f}</option>`).join('')}</select>
    </div>
    <div><label>Aggregations:</label>
      <div class="pivot-aggregations" style="display: flex; flex-direction: column; gap: 6px; margin-top: 4px;">
        <label style="font-size: 0.9rem;"><input type="checkbox" value="count" checked> Count</label>
        <label style="font-size: 0.9rem;"><input type="checkbox" value="sum" checked> Sum</label>
        <label style="font-size: 0.9rem;"><input type="checkbox" value="avg"> Average</label>
        <label style="font-size: 0.9rem;"><input type="checkbox" value="min"> Min</label>
        <label style="font-size: 0.9rem;"><input type="checkbox" value="max"> Max</label>
      </div>
    </div>
  </div>
  <button class="apply-pivot" style="background: #4facfe; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; margin-top: 10px;">Generate Pivot</button>

  <!-- Export Buttons -->
  <div class="pivot-export-controls" style="margin-top: 10px; display: flex; gap: 10px;">
    <button class="export-pivot-csv" style="background: #28a745; color: white; border: none; padding: 6px 10px; border-radius: 4px; cursor: pointer; font-size: 0.9rem;">ðŸ“¥ Export as CSV</button>
    <button class="export-pivot-pdf" style="background: #dc3545; color: white; border: none; padding: 6px 10px; border-radius: 4px; cursor: pointer; font-size: 0.9rem;">ðŸ“„ Export as Editable PDF</button>
  </div>

  <!-- Pivot Output -->
  <div class="pivot-output" style="margin-top: 15px; overflow: auto;"></div>
`;

    // Reattach event listeners
pivotContainer.querySelector('.apply-pivot').addEventListener('click', () => {
    generatePivotTable(headers, pivotContainer, fileDataSection, tableBody);
});

// === Attach Export Handlers for Pivot Table ===
const exportCsvBtn = pivotContainer.querySelector('.export-pivot-csv');
const exportPdfBtn = pivotContainer.querySelector('.export-pivot-pdf');

// === Export Pivot as CSV ===
exportCsvBtn?.addEventListener('click', () => {
    const outputDiv = pivotContainer.querySelector('.pivot-output');
    const table = outputDiv?.querySelector('table');
    if (!table) {
        showStatus('No pivot table to export.', 'error');
        return;
    }

    let csv = '';
    
    // Extract and clean headers
    const headerRow = table.querySelector('thead tr');
    const rawHeaders = Array.from(headerRow.querySelectorAll('th')).map(th => th.textContent.trim());
    const cleanedHeaders = rawHeaders.map(cleanHeaderName);
    csv += cleanedHeaders.join(',') + '\n';

    // Extract data rows
    const rows = table.querySelectorAll('tbody tr');
    rows.forEach(row => {
        const cells = row.querySelectorAll('td');
        const rowData = Array.from(cells).map(td => {
            let cellText = td.textContent.trim();
            // Escape commas and wrap in quotes if needed
            if (cellText.includes(',') || cellText.includes('"')) {
                cellText = `"${cellText.replace(/"/g, '""')}"`;
            }
            return cellText;
        });
        csv += rowData.join(',') + '\n';
    });

    // Trigger download
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.setAttribute('href', url);
    link.setAttribute('download', `pivot_export_${new Date().toISOString().slice(0,10)}.csv`);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
    showStatus('Pivot table exported as CSV successfully.', 'success');
});

// === Export Pivot as Editable PDF ===
exportPdfBtn?.addEventListener('click', () => {
    const outputDiv = pivotContainer.querySelector('.pivot-output');
    const table = outputDiv?.querySelector('table');
    if (!table) {
        showStatus('No pivot table to export.', 'error');
        return;
    }

    if (typeof window.jspdf === 'undefined') {
        alert('jsPDF library not loaded. Cannot export to PDF.');
        return;
    }
    const { jsPDF } = window.jspdf;

    // Extract and clean headers
    const rawHeaders = Array.from(table.querySelectorAll('thead th')).map(th => th.textContent.trim());
    const cleanedHeaders = rawHeaders.map(cleanHeaderName);

    const rows = [];
    table.querySelectorAll('tbody tr').forEach(tr => {
        const cells = Array.from(tr.querySelectorAll('td')).map(td => td.textContent.trim());
        rows.push(cells);
    });

    const pdf = new jsPDF('l', 'mm', 'a4');
    pdf.autoTable({
        head: [cleanedHeaders],  // Use cleaned headers
        body: rows,
        startY: 20,
        theme: 'striped',
        styles: { fontSize: 10, cellPadding: 3 },
        headStyles: { fillColor: [79, 172, 254], textColor: [255, 255, 255] },
        margin: { top: 15 }
    });

    pdf.setFontSize(16);
    pdf.text('Pivot Table Export', 14, 15);
    pdf.save(`pivot_export_${new Date().toISOString().slice(0,10)}.pdf`);
    showStatus('Pivot table exported as PDF successfully.', 'success');
});

// Update on any change: row, col, value, or aggregation checkbox
[rowSelect, colSelect, valSelect].forEach(sel => {
    sel.addEventListener('change', () => {
        generatePivotTable(headers, pivotContainer, fileDataSection, tableBody);
    });
});

// Add event listeners to aggregation checkboxes
pivotContainer.querySelectorAll('.pivot-aggregations input').forEach(cb => {
    cb.addEventListener('change', () => {
        generatePivotTable(headers, pivotContainer, fileDataSection, tableBody);
    });
});

    // Set default values safely
    const rowSelect = pivotContainer.querySelector('.pivot-row-field');
    const colSelect = pivotContainer.querySelector('.pivot-col-field');
    const valSelect = pivotContainer.querySelector('.pivot-value-field');

    rowSelect.value = fields[1] || '(None)';
    colSelect.value = '(None)';
    valSelect.value = fields[1] || '(None)';

    // Reattach event listeners
    pivotContainer.querySelector('.apply-pivot').addEventListener('click', () => {
        generatePivotTable(headers, pivotContainer, fileDataSection, tableBody);
    });

    [rowSelect, colSelect, valSelect].forEach(sel => {
        sel.addEventListener('change', () => {
            generatePivotTable(headers, pivotContainer, fileDataSection, tableBody);
        });
    });

    pivotContainer.querySelector('.pivot-aggregate').addEventListener('change', () => {
        generatePivotTable(headers, pivotContainer, fileDataSection, tableBody);
    });
}

function generatePivotTable(headers, pivotContainer, fileDataSection, tableBody) {
    const rowField = pivotContainer.querySelector('.pivot-row-field').value;
    const colField = pivotContainer.querySelector('.pivot-col-field').value;
    const valueField = pivotContainer.querySelector('.pivot-value-field').value;
    const aggregations = Array.from(pivotContainer.querySelectorAll('.pivot-aggregations input:checked')).map(cb => cb.value);

    if (rowField === '(None)' || valueField === '(None)' || aggregations.length === 0) {
        pivotContainer.querySelector('.pivot-output').innerHTML =
            '<p style="color: yellow;">Select Row, Value fields, and at least one aggregation.</p>';
        return;
    }

    const dataRows = fileDataSection.filteredRows?.length > 0
        ? fileDataSection.filteredRows
        : Array.from(tableBody.querySelectorAll('tr'));

    // Build pivot map: { rowKey: { colKey: { count, sum, values } } }
    const pivotMap = {};
    const columnKeys = new Set();
    const hasColField = colField !== '(None)';

    dataRows.forEach(rowEl => {
        const tds = rowEl.querySelectorAll('td');
        const rowData = {};
        headers.forEach((h, idx) => {
            rowData[h] = tds[idx]?.textContent.trim() || '';
        });

        const rowKey = rowData[rowField];
        const colKey = hasColField ? (rowData[colField] || '(Blank)') : 'Total';
        const valText = rowData[valueField];
        let valNum = parseFloat(valText.replace(/[$,%]/g, ''));
        if (isNaN(valNum)) valNum = 0;

        if (!pivotMap[rowKey]) pivotMap[rowKey] = {};
        if (!pivotMap[rowKey][colKey]) {
            pivotMap[rowKey][colKey] = { count: 0, sum: 0, values: [] };
        }

        const cell = pivotMap[rowKey][colKey];
        cell.count++;
        cell.sum += valNum;
        cell.values.push(valNum);

        columnKeys.add(colKey);
    });

    // Sort column keys and define aggregation pairs
    const sortedColKeys = hasColField ? [...columnKeys].sort() : ['Total'];
    const colAggPairs = [];
    sortedColKeys.forEach(colKey => {
        aggregations.forEach(agg => {
            colAggPairs.push({ colKey, agg });
        });
    });

    // === NEW: Add Total column for each aggregation ===
    aggregations.forEach(agg => {
        colAggPairs.push({ colKey: 'Total', agg, isTotal: true });
    });

    // Convert pivotMap to array for sorting
    const pivotRows = Object.keys(pivotMap).map(rowKey => {
        const rowData = { rowKey, cells: [] };

        colAggPairs.forEach(({ colKey, agg, isTotal }) => {
            let displayValue = '0.00';

            if (isTotal) {
                // Compute total across all columns for this row
                let totalSum = 0, totalCount = 0, allValues = [];

                Object.values(pivotMap[rowKey]).forEach(cell => {
                    totalSum += cell.sum;
                    totalCount += cell.count;
                    allValues = allValues.concat(cell.values);
                });

                switch (agg) {
                    case 'sum': displayValue = totalSum.toFixed(2); break;
                    case 'count': displayValue = totalCount; break;
                    case 'avg': displayValue = (totalCount ? (totalSum / totalCount).toFixed(2) : '0.00'); break;
                    case 'min': displayValue = allValues.length ? Math.min(...allValues).toFixed(2) : '0.00'; break;
                    case 'max': displayValue = allValues.length ? Math.max(...allValues).toFixed(2) : '0.00'; break;
                    default: displayValue = '0.00';
                }
            } else {
                const cell = pivotMap[rowKey][colKey];
                if (cell) {
                    switch (agg) {
                        case 'sum': displayValue = cell.sum.toFixed(2); break;
                        case 'count': displayValue = cell.count; break;
                        case 'avg': displayValue = (cell.count ? (cell.sum / cell.count).toFixed(2) : '0.00'); break;
                        case 'min': displayValue = Math.min(...cell.values).toFixed(2); break;
                        case 'max': displayValue = Math.max(...cell.values).toFixed(2); break;
                        default: displayValue = '0.00';
                    }
                }
            }

            rowData.cells.push(displayValue);
        });

        return rowData;
    });

    // Initialize sort state if not present
    if (!fileDataSection.pivotSortState) {
        fileDataSection.pivotSortState = { columnIndex: 0, direction: 'asc' };
    }

    // Sort the pivot rows
    const sortIndex = fileDataSection.pivotSortState.columnIndex;
    const sortDirection = fileDataSection.pivotSortState.direction;

    pivotRows.sort((a, b) => {
        let valueA, valueB;

        if (sortIndex === 0) {
            valueA = a.rowKey || '';
            valueB = b.rowKey || '';
            return sortDirection === 'asc'
                ? valueA.localeCompare(valueB)
                : valueB.localeCompare(valueA);
        } else {
            const pairIndex = sortIndex - 1;
            if (pairIndex < colAggPairs.length) {
                valueA = parseFloat(a.cells[pairIndex]) || 0;
                valueB = parseFloat(b.cells[pairIndex]) || 0;
                return sortDirection === 'asc' ? valueA - valueB : valueB - valueA;
            }
        }
        return 0;
    });

    // Pagination
    const rowsPerPage = parseInt(pivotContainer.querySelector('.pivot-rows-per-page')?.value) || 10;
    const currentPage = parseInt(pivotContainer.dataset.currentPage) || 1;
    const totalPivotRowCount = pivotRows.length;
    const totalPages = Math.ceil(totalPivotRowCount / rowsPerPage);
    const startIndex = (currentPage - 1) * rowsPerPage;
    const paginatedRows = pivotRows.slice(startIndex, startIndex + rowsPerPage);

    // Generate table HTML
    let tableHTML = `<div style="margin-bottom: 10px; font-size: 0.9em; opacity: 0.9;">
        <strong>Grouped Rows:</strong> ${totalPivotRowCount} |
        <strong>Page:</strong> ${currentPage} of ${totalPages || 1}
    </div>`;

    tableHTML += `<table style="width: 100%; border-collapse: collapse;"><thead><tr>
        <th style="padding: 6px; border: 1px solid #333; background: #1a2a6c; color: #4facfe; cursor: pointer;" data-sort-index="0">
            ${rowField}
            <span class="sort-indicator">
                ${fileDataSection.pivotSortState.columnIndex === 0 && fileDataSection.pivotSortState.direction === 'asc' ? 'â–²' :
                  fileDataSection.pivotSortState.columnIndex === 0 && fileDataSection.pivotSortState.direction === 'desc' ? 'â–¼' : ''}
            </span>
        </th>`;

    colAggPairs.forEach(({ colKey, agg, isTotal }, index) => {
        const sortIndex = index + 1;
        const aggLabel = agg === 'count' ? 'Count' :
                         agg === 'sum' ? 'Sum' :
                         agg === 'avg' ? 'Avg' :
                         agg === 'min' ? 'Min' : 'Max';

        const thStyle = `style="padding: 6px; border: 1px solid #333; background: #1a2a6c; color: #4facfe; cursor: pointer;"`;
        const displayColKey = isTotal ? 'Total' : (colKey === 'Total' ? '' : colKey);

        tableHTML += `<th ${thStyle} data-sort-index="${sortIndex}">
            ${displayColKey} ${aggLabel}
            <span class="sort-indicator">
                ${fileDataSection.pivotSortState.columnIndex === sortIndex && fileDataSection.pivotSortState.direction === 'asc' ? 'â–²' :
                  fileDataSection.pivotSortState.columnIndex === sortIndex && fileDataSection.pivotSortState.direction === 'desc' ? 'â–¼' : ''}
            </span>
        </th>`;
    });

    tableHTML += `</tr></thead><tbody>`;

    paginatedRows.forEach(rowData => {
        tableHTML += `<tr><td style="padding: 6px; border: 1px solid #ddd;">${rowData.rowKey}</td>`;
        rowData.cells.forEach(cell => {
            tableHTML += `<td style="padding: 6px; border: 1px solid #ddd; text-align: right;">${cell}</td>`;
        });
        tableHTML += `</tr>`;
    });

    // Add totals row (overall grand totals)
    if (aggregations.some(a => ['sum', 'count', 'avg'].includes(a))) {
        tableHTML += `<tr style="font-weight: bold; background: #2a3a5a; color: white;">
            <td style="padding: 6px;">Total</td>`;

        colAggPairs.forEach(({ colKey, agg, isTotal }) => {
            let total = 0;
            let totalCount = 0;

            if (isTotal) {
                // Total of totals per row â€” we already computed per-row totals, now sum across rows
                pivotRows.forEach(r => {
                    const val = parseFloat(r.cells[colAggPairs.findIndex(p => p.colKey === colKey && p.agg === agg && p.isTotal)] || 0);
                    total += isNaN(val) ? 0 : val;
                });
                displayValue = agg === 'count' ? total : total.toFixed(2);
            } else {
                // Aggregate across all row keys for this column+agg
                Object.values(pivotMap).forEach(row => {
                    const cell = row[colKey];
                    if (cell) {
                        if (agg === 'sum') total += cell.sum;
                        else if (agg === 'count') total += cell.count;
                        else if (agg === 'avg') { total += cell.sum; totalCount += cell.count; }
                    }
                });
                const displayValue = agg === 'avg' && totalCount ? (total / totalCount).toFixed(2) : total.toFixed(2);
                tableHTML += `<td style="padding: 6px; text-align: right;">${displayValue}</td>`;
                return;
            }

            tableHTML += `<td style="padding: 6px; text-align: right;">${displayValue}</td>`;
        });

        tableHTML += `</tr>`;
    }

    tableHTML += `</tbody></table>`;

    // Pagination controls
    const paginationHTML = `
        <div style="margin-top: 10px; display: flex; justify-content: space-between; align-items: center;">
            <select class="pivot-rows-per-page" style="padding: 4px; border-radius: 4px;">
                <option value="10" ${rowsPerPage === 10 ? 'selected' : ''}>10 rows</option>
                <option value="25" ${rowsPerPage === 25 ? 'selected' : ''}>25 rows</option>
                <option value="50" ${rowsPerPage === 50 ? 'selected' : ''}>50 rows</option>
                <option value="100" ${rowsPerPage === 100 ? 'selected' : ''}>100 rows</option>
            </select>
            <div>
                <button class="pivot-prev-page" ${currentPage <= 1 ? 'disabled' : ''} style="padding: 4px 8px;">â—€ Prev</button>
                <button class="pivot-next-page" ${currentPage >= totalPages ? 'disabled' : ''} style="margin-left: 5px; padding: 4px 8px;">Next â–¶</button>
            </div>
        </div>`;

    const outputContainer = pivotContainer.querySelector('.pivot-output');
    outputContainer.innerHTML = tableHTML + paginationHTML;

    // Reattach event listeners
    const prevBtn = outputContainer.querySelector('.pivot-prev-page');
    const nextBtn = outputContainer.querySelector('.pivot-next-page');
    const rowsSelect = outputContainer.querySelector('.pivot-rows-per-page');

    prevBtn?.addEventListener('click', () => {
        if (currentPage > 1) {
            pivotContainer.dataset.currentPage = currentPage - 1;
            generatePivotTable(headers, pivotContainer, fileDataSection, tableBody);
        }
    });

    nextBtn?.addEventListener('click', () => {
        if (currentPage < totalPages) {
            pivotContainer.dataset.currentPage = parseInt(pivotContainer.dataset.currentPage) + 1;
            generatePivotTable(headers, pivotContainer, fileDataSection, tableBody);
        }
    });

    rowsSelect?.addEventListener('change', () => {
        pivotContainer.dataset.currentPage = 1;
        generatePivotTable(headers, pivotContainer, fileDataSection, tableBody);
    });

    // Reattach sort listeners
    outputContainer.querySelectorAll('th[data-sort-index]').forEach(th => {
        th.addEventListener('click', function () {
            const columnIndex = parseInt(this.getAttribute('data-sort-index'));
            const currentState = fileDataSection.pivotSortState;

            if (currentState.columnIndex === columnIndex) {
                currentState.direction = currentState.direction === 'asc' ? 'desc' : 'asc';
            } else {
                currentState.columnIndex = columnIndex;
                currentState.direction = 'asc';
            }

            generatePivotTable(headers, pivotContainer, fileDataSection, tableBody);
        });
    });
}

}

function cleanHeaderName(header) {
    if (!header) return 'Column';
    return header
        .trim()                          // Remove leading/trailing whitespace
        .replace(/[^a-zA-Z0-9\s_]/g, '') // Remove all non-alphanumeric except spaces and underscores
        .replace(/\s+/g, '_')            // Replace spaces with underscores
        .replace(/_+/g, '_')             // Replace multiple underscores with single
        .replace(/^_|_$/g, '');          // Remove leading/trailing underscores
}

    // Initialize the application
    function init() {
        setupEventListeners();
        setupUrlEventListener(); // Add this line
        addJoinTablesFeature();

        document.querySelectorAll('.file-data-section').forEach(section => {
        if (!section._formulaControlsAdded) {
            addFormulaColumnControls(section);
            section._formulaControlsAdded = true;
        }
        if (!section._dateTimeFormattingAdded) {
            addDateTimeFormattingControls(section);
            section._dateTimeFormattingAdded = true;
        }
    });
    integrateDateTimeFormatting();
        
   }
    
    function setupEventListeners() {
        fileInput.addEventListener('change', handleFileSelect);
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.style.borderColor = '#4facfe';
            dropZone.style.backgroundColor = 'rgba(0, 0, 0, 0.4)';
        });
        dropZone.addEventListener('dragleave', () => {
            dropZone.style.borderColor = 'rgba(255, 255, 255, 0.3)';
            dropZone.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';
        });
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.style.borderColor = 'rgba(255, 255, 255, 0.3)';
            dropZone.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';
            if (e.dataTransfer.files.length) {
                fileInput.files = e.dataTransfer.files;
                handleFileSelect();
            }
        });
        uploadBtn.addEventListener('click', processFiles);
        clearAllBtn.addEventListener('click', clearAllData);
    }
    
    function handleFileSelect() {
        const files = fileInput.files;
        if (files.length > 0) {
            fileText.textContent = `${files.length} file(s) selected`;
            uploadBtn.disabled = false;
            statusDiv.textContent = '';
            statusDiv.className = 'status';
            updateFileList();
        } else {
            fileText.textContent = 'Drag & drop files here or click to browse';
            uploadBtn.disabled = true;
            fileList.innerHTML = '';
        }
    }
    
    function updateFileList() {
        fileList.innerHTML = '';
        Array.from(fileInput.files).forEach((file, index) => {
            const fileItem = document.createElement('div');
            fileItem.className = 'file-item';
            const fileName = document.createElement('div');
            fileName.className = 'file-name';
            fileName.textContent = file.name;
            const removeBtn = document.createElement('button');
            removeBtn.className = 'remove-file';
            removeBtn.innerHTML = '&times;';
            removeBtn.addEventListener('click', () => removeFile(index));
            fileItem.appendChild(fileName);
            fileItem.appendChild(removeBtn);
            fileList.appendChild(fileItem);
        });
    }
    
    function removeFile(index) {
        const dt = new DataTransfer();
        const files = fileInput.files;
        for (let i = 0; i < files.length; i++) {
            if (i !== index) {
                dt.items.add(files[i]);
            }
        }
        fileInput.files = dt.files;
        handleFileSelect();
    }
    
    function processFiles() {
        const files = fileInput.files;
        if (files.length === 0) return;
        showStatus('Processing files...', 'success');
        uploadBtn.disabled = true;
        processFileBatch(Array.from(files), 0);
        
    }
    
    async function processFileBatch(files, index) {
        if (index >= files.length) {
            showStatus(`Processed ${files.length} files successfully!`, 'success');
            uploadBtn.disabled = false;
            return;
        }
        const file = files[index];
        try {
            showStatus(`Analyzing formats for ${file.name}...`, 'success');
            const dateTimeInfo = await detectDateTimeFormats(file);
            console.log(`Date/Time Info for ${file.name}:`, dateTimeInfo);
            const reader = new FileReader();
            reader.onload = async function(e) {
                try {
                    const arrayBuffer = e.target.result;
                    const fileDataSectionFragment = fileDataSectionTemplate.content.cloneNode(true);
                    const fileDataSection = fileDataSectionFragment.querySelector('.file-data-section');
                    fileDataSection.fileName = file.name;
                    fileDataSection.dateTimeInfo = dateTimeInfo;
                    const deleteBtn = fileDataSection.querySelector('.delete-section-btn');
                    deleteBtn.addEventListener('click', () => deleteFileSection(fileDataSection));
                    const fileTitle = fileDataSection.querySelector('.file-title');
                    fileTitle.textContent = `Data from: ${file.name}`;
                    
                    const sheetTabsContainer = fileDataSection.querySelector('.sheet-tabs');
                    const table = fileDataSection.querySelector('table');
                    const tableHeader = table.querySelector('thead');
                    const tableBody = table.querySelector('tbody');
                    const noDataMessage = fileDataSection.querySelector('.no-data');
                    const columnControls = fileDataSection.querySelector('.column-controls');
                    
                    if (!hidden[file.name]) hidden[file.name] = {};
                    if (!sortingState[file.name]) sortingState[file.name] = {};
                    
                    // Store raw ArrayBuffer for lazy loading
                    fileDataSection.fileDataArrayBuffer = arrayBuffer;
                    fileDataSection.workbook = null; // Will be parsed on demand
                    
                    // Read workbook structure to get sheet names
                    const tempWorkbook = XLSX.read(arrayBuffer, { type: 'array', bookSheets: true , cellDates: true });
                    const sheetNames = tempWorkbook.SheetNames;
                    
                    if (sheetNames.length === 0) {
                        noDataMessage.style.display = 'block';
                        table.style.display = 'none';
                        columnControls.style.display = 'none';
                    } else {
                        noDataMessage.style.display = 'none';
                        table.style.display = 'table';
                        columnControls.style.display = 'flex';
                        
                        // Create tabs
                        sheetNames.forEach((sheetName, tabIndex) => {
                            const tab = document.createElement('div');
                            tab.className = 'sheet-tab';
                            if (tabIndex === 0) tab.classList.add('active');
                            tab.textContent = sheetName;
                            tab.addEventListener('click', function () {
                                // === CLOSE PIVOT TABLE WHEN SWITCHING TABS ===
                                const pivotContainer = fileDataSection.querySelector('.pivot-container');
                                const togglePivotBtn = fileDataSection.querySelector('.toggle-pivot-btn');

                                if (pivotContainer && togglePivotBtn) {
                                    pivotContainer.style.display = 'none';
                                    togglePivotBtn.textContent = 'ðŸ“Š Pivot Analyzer';
                                }

                                // Lazy load sheet data when tab is clicked
                                loadSheetData(sheetName, fileDataSection, sheetTabsContainer, tableHeader, tableBody, columnControls, file.name);
                            });
                            sheetTabsContainer.appendChild(tab);
                        });
                        
                        // Load first sheet immediately
                        loadSheetData(sheetNames[0], fileDataSection, sheetTabsContainer, tableHeader, tableBody, columnControls, file.name);
                    }
                    
                    dataSectionContainer.appendChild(fileDataSection);
                    processFileBatch(files, index + 1);
                    addFormattingControls(fileDataSection);
                    
                    
                    
                } catch (err) {
                    console.error('Error parsing file:', err);
                    showStatus(`Error processing ${file.name}.`, 'error');
                    processFileBatch(files, index + 1);
                }
            };
            reader.onerror = () => {
                showStatus(`Error reading ${file.name}.`, 'error');
                processFileBatch(files, index + 1);
            };
            reader.readAsArrayBuffer(file);
        } catch (err) {
            console.error('Error detecting formats:', err);
            showStatus(`Error analyzing ${file.name}. Skipping.`, 'error');
            processFileBatch(files, index + 1);
        }
      
    }
    
    function resetAdvancedFilter(fileDataSection) {
    const advancedSearchContainer = fileDataSection.querySelector('.advanced-search-container');
    const conditions = advancedSearchContainer.querySelectorAll('.condition-group');
    conditions.forEach((conditionGroup, index) => {
        if (index === 0) {
            conditionGroup.querySelector('.value').value = '';
            conditionGroup.seenValues = {}; // Reset unique tracking
        } else {
            if (conditionGroup.parentNode) {
                conditionGroup.remove();
            }
        }
    });
    const tableBody = fileDataSection.querySelector('tbody');
    const bodyRows = tableBody.querySelectorAll('tr');
    bodyRows.forEach(row => {
        row.style.display = '';
    });
    
    // Properly notify the pagination system about the reset
    if (fileDataSection && typeof fileDataSection.currentFilterCallback === 'function') {
        const allRows = Array.from(tableBody.querySelectorAll('tr'));
        fileDataSection.currentFilterCallback(allRows);
    } else {
        // Fallback behavior
        const visibleCount = Array.from(tableBody.querySelectorAll('tr')).length;
        showStatus('Advanced filter reset', 'success');
    }
   
}
    
    function addAdvancedSearchControls(fileDataSection) {
        // Create advanced search container
        const advancedSearchContainer = document.createElement('div');
        advancedSearchContainer.className = 'advanced-search-container';
        advancedSearchContainer.style.cssText = `
            margin: 15px 0;
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            display: none; /* Hidden by default */
        `;
        
        // Create toggle button
        const toggleBtn = document.createElement('button');
        toggleBtn.className = 'toggle-advanced-search';
        toggleBtn.textContent = 'Toggle Advanced Search';
        toggleBtn.style.cssText = `
            background: rgba(79, 172, 254, 0.3);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            margin-bottom: 10px;
            font-size: 0.9rem;
        `;
        
        // Advanced search form
        advancedSearchContainer.innerHTML = `
            <div class="search-conditions" style="margin-bottom: 10px; max-height: 200px; overflow-y: auto;">
                <div class="condition-group" style="margin-bottom: 10px; padding: 10px; background: rgba(0, 0, 0, 0.2); border-radius: 5px;">
                    <select class="condition-type" style="padding: 5px; margin-right: 5px; background: rgba(255, 255, 255, 0.1); color: #888888; border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 4px;">
                        <option value="AND">AND</option>
                        <option value="OR">OR</option>
                    </select>
                    <select class="column-name" style="padding: 5px; margin-right: 5px; background: rgba(255, 255, 255, 0.1); color: #888888; border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 4px; flex: 1;"></select>
                    <select class="operator" style="padding: 5px; margin-right: 5px; background: rgba(255, 255, 255, 0.1); color: #888888; border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 4px;">
                        <option value="equals">=</option>
                        <option value="not-equals">!=</option>
                        <option value="greater-than">></option>
                        <option value="less-than"><</option>
                        <option value="greater-than-equal">>=</option>
                        <option value="less-than-equal"><=</option>
                        <option value="between">Between</option>
                        <option value="is-null">Is Empty</option>
                        <option value="is-not-null">Is Not Empty</option>
                        <option value="contains">Contains (Text)</option>
                        <option value="starts-with">Starts With</option>
                        <option value="ends-with">Ends With</option>
                        <option value="like">LIKE</option>
                        <option value="unique">Unique Values</option>
                    </select>
                    <input type="text" class="value" placeholder="eg. 05/30/2024" style="flex: 1; padding: 5px; border-radius: 4px; border: 1px solid rgba(255, 255, 255, 0.3); background-color: rgba(255, 255, 255, 0.1); color: white;">
                    <button class="remove-condition" style="background: rgba(255, 0, 0, 0.3); color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer; margin-left: 5px;">âœ•</button>
                </div>
            </div>
            <div style="display: flex; gap: 10px;">
                <button class="add-condition-btn" style="flex: 1; background: rgba(79, 172, 254, 0.3); color: white; border: 1px solid rgba(255, 255, 255, 0.3); padding: 8px; border-radius: 5px; cursor: pointer;">
                    + Add Condition
                </button>
                <button class="apply-advanced-filter" style="flex: 1; background: linear-gradient(to right, #4facfe, #00f2fe); color: white; border: none; padding: 8px; border-radius: 5px; cursor: pointer;">
                    Apply Filter
                </button>
                <button class="reset-advanced-filter" style="flex: 1; background: rgba(255, 0, 0, 0.3); color: white; border: none; padding: 8px; border-radius: 5px; cursor: pointer;">
                    Reset
                </button>
            </div>
        `;
        
        // Add the controls to the file data section
        const sheetData = fileDataSection.querySelector('.sheet-data');
        sheetData.parentNode.insertBefore(advancedSearchContainer, sheetData);
        sheetData.parentNode.insertBefore(toggleBtn, advancedSearchContainer);
        
        // Setup event listeners
        toggleBtn.addEventListener('click', () => {
            advancedSearchContainer.style.display = advancedSearchContainer.style.display === 'none' ? 'block' : 'none';
        });
        
        // Add initial condition event listeners
        setupConditionEvents(advancedSearchContainer, fileDataSection);
        
        // Add condition button
        const addConditionBtn = advancedSearchContainer.querySelector('.add-condition-btn');
        addConditionBtn.addEventListener('click', () => {
            const conditionGroup = document.createElement('div');
            conditionGroup.className = 'condition-group';
            conditionGroup.style.cssText = 'margin-bottom: 10px; padding: 10px; background: rgba(0, 0, 0, 0.2); border-radius: 5px;';
            conditionGroup.innerHTML = `
                <select class="condition-type" style="padding: 5px; margin-right: 5px; background: rgba(255, 255, 255, 0.1); color: #888888; border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 4px;">
                    <option value="AND">AND</option>
                    <option value="OR">OR</option>
                </select>
                <select class="column-name" style="padding: 5px; margin-right: 5px; background: rgba(255, 255, 255, 0.1); color: #888888; border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 4px; flex: 1;"></select>
                <select class="operator" style="padding: 5px; margin-right: 5px; background: rgba(255, 255, 255, 0.1); color: #888888; border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 4px;">
                    <option value="equals">=</option>
                    <option value="not-equals">!=</option>
                    <option value="greater-than">></option>
                    <option value="less-than"><</option>
                    <option value="greater-than-equal">>=</option>
                    <option value="less-than-equal"><=</option>
                    <option value="between">Between</option>
                    <option value="is-null">Is Empty</option>
                    <option value="is-not-null">Is Not Empty</option>
                    <option value="contains">Contains (Text)</option>
                    <option value="starts-with">Starts With</option>
                    <option value="ends-with">Ends With</option>
                    <option value="like">LIKE</option>
                    <option value="unique">Unique Values</option>
                </select>
                <input type="text" class="value" placeholder="eg. 05/30/2024" style="flex: 1; padding: 5px; border-radius: 4px; border: 1px solid rgba(255, 255, 255, 0.3); background-color: rgba(255, 255, 255, 0.1); color: white;">
                <button class="remove-condition" style="background: rgba(255, 0, 0, 0.3); color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer; margin-left: 5px;">âœ•</button>
            `;
            advancedSearchContainer.querySelector('.search-conditions').appendChild(conditionGroup);
            setupConditionEvents(advancedSearchContainer, fileDataSection);
            populateColumnNames(fileDataSection, conditionGroup);
        });
        
        // Apply filter button
        const applyFilterBtn = advancedSearchContainer.querySelector('.apply-advanced-filter');
        applyFilterBtn.addEventListener('click', () => {
            applyAdvancedFilter(fileDataSection);
        });
        
        // Reset filter button
        const resetFilterBtn = advancedSearchContainer.querySelector('.reset-advanced-filter');
        resetFilterBtn.addEventListener('click', () => {
            resetAdvancedFilter(fileDataSection);
        });
        
        return advancedSearchContainer;
    }
    
    function setupConditionEvents(advancedSearchContainer, fileDataSection) {
        // Remove condition button
        const removeButtons = advancedSearchContainer.querySelectorAll('.remove-condition');
        removeButtons.forEach(btn => {
            btn.onclick = null; // Remove any existing listeners
            btn.addEventListener('click', function() {
                if (advancedSearchContainer.querySelectorAll('.condition-group').length > 1) {
                    this.closest('.condition-group').remove();
                } else {
                    // Clear values instead of removing the last condition
                    const group = this.closest('.condition-group');
                    group.querySelector('.value').value = '';
                }
            });
        });
        
        // Populate column names for all condition groups
        const conditionGroups = advancedSearchContainer.querySelectorAll('.condition-group');
        conditionGroups.forEach(group => {
            populateColumnNames(fileDataSection, group);
        });
    }
    
    function populateColumnNames(fileDataSection, conditionGroup) {
        const columnNameSelect = conditionGroup.querySelector('.column-name');
        const previouslySelectedValue = columnNameSelect.value; // Save the current selection
        columnNameSelect.innerHTML = ''; // Clear existing options
        
        // Get headers from the current active sheet
        const tableHeader = fileDataSection.querySelector('thead');
        if (tableHeader) {
            const headers = tableHeader.querySelectorAll('th');
            headers.forEach(th => {
                const headerText = th.textContent.split('\n')[0]; // Extract just the header text
                const option = document.createElement('option');
                option.value = headerText;
                option.textContent = headerText;
                columnNameSelect.appendChild(option);
            });
            // Restore the previously selected value if it still exists
            if (previouslySelectedValue && Array.from(columnNameSelect.options).some(opt => opt.value === previouslySelectedValue)) {
                columnNameSelect.value = previouslySelectedValue;
            }
        }
    }
    
    
    // Enhanced version of applyAdvancedFilter with improved logic
    function applyAdvancedFilter(fileDataSection) {
        const advancedSearchContainer = fileDataSection.querySelector('.advanced-search-container');
        fileDataSection.currentAdvancedFilterActive = true;
        const conditions = Array.from(advancedSearchContainer.querySelectorAll('.condition-group'));
        const tableBody = fileDataSection.querySelector('tbody');
        const bodyRows = Array.from(tableBody.querySelectorAll('tr'));
        const seenComposites = {}; // For unique tracking
        
        // Reset all rows to visible
        bodyRows.forEach(row => {
            row.style.display = '';
        });
        
        // Get current sheet name and date/time info
        const activeTab = fileDataSection.querySelector('.sheet-tab.active');
        if (!activeTab) return;
        const sheetName = activeTab.textContent;
        const dateTimeInfo = fileDataSection.dateTimeInfo?.[sheetName];
        const dateCols = new Set(dateTimeInfo?.dateColumns || []);
        const timeCols = new Set(dateTimeInfo?.timeColumns || []);
        
        // Apply each condition
        conditions.forEach((conditionGroup, index) => {
            const columnName = conditionGroup.querySelector('.column-name').value;
            const operator = conditionGroup.querySelector('.operator').value;
            const inputVal = conditionGroup.querySelector('.value').value.trim();
            const conditionType = conditionGroup.querySelector('.condition-type').value;
            
            // Skip empty value fields unless operator is null-related or unique
            if (!['unique', 'is-null', 'is-not-null'].includes(operator) && !inputVal) return;
            
            // Get column index
            const tableHeader = fileDataSection.querySelector('thead');
            const headers = Array.from(tableHeader.querySelectorAll('th'));
            const colIndex = headers.findIndex(th => {
                const headerText = th.textContent.split('\n')[0];
                return headerText === columnName;
            });
            if (colIndex === -1) return;
            
            // Determine if this column is a date/time column
            const isDateColumn = dateCols.has(colIndex);
            
            // Parse input value if needed
            let inputDate = null;
            let parsedInputValue = null;
            let isInputNumeric = false;
            if (isDateColumn && ['equals', 'not-equals', 'greater-than', 'less-than', 'greater-than-equal', 'less-than-equal', 'between'].includes(operator)) {
                inputDate = parseDate(inputVal);
                if (!inputDate && operator !== 'between') {
                    showStatus(`Invalid date format: "${inputVal}"`, 'error');
                    return;
                }
            } else if (!['unique', 'is-null', 'is-not-null', 'between'].includes(operator)) {
                parsedInputValue = parseFormattedNumber(inputVal);
                isInputNumeric = parsedInputValue !== null;
            }
            
            bodyRows.forEach((row, rowIndex) => {
                if (row.style.display === 'none' && conditionType === 'AND') return;
                const cell = row.cells[colIndex];
                if (!cell) return;
                const cellText = cell.textContent.trim();
                let matches = false;
                
                if (isDateColumn) {
                    const cellDate = parseDate(cellText);
                    if (operator === 'is-null') {
                        matches = !cellDate && !cellText;
                    } else if (operator === 'is-not-null') {
                        matches = !!cellDate;
                    } else if (operator === 'between') {
                        const [from, to] = inputVal.split(',').map(v => parseDate(v.trim())).filter(Boolean);
                        if (from && to) {
                            matches = cellDate && cellDate >= from && cellDate <= to;
                        } else {
                            matches = false;
                        }
                    } else if (cellDate) {
                        switch (operator) {
                            case 'equals':
                                matches = cellDate.toDateString() === inputDate.toDateString();
                                break;
                            case 'not-equals':
                                matches = cellDate.toDateString() !== inputDate.toDateString();
                                break;
                            case 'greater-than':
                                matches = cellDate > inputDate;
                                break;
                            case 'less-than':
                                matches = cellDate < inputDate;
                                break;
                            case 'greater-than-equal':
                                matches = cellDate >= inputDate;
                                break;
                            case 'less-than-equal':
                                matches = cellDate <= inputDate;
                                break;
                            default:
                                matches = false;
                        }
                    }
                } else {
                    let cellValue = cellText;
                    let cellNumeric = parseFormattedNumber(cellText);
                    let useNumeric = isInputNumeric && cellNumeric !== null;
                    
                    switch (operator) {
                        case 'is-null':
                            matches = !cellText;
                            break;
                        case 'is-not-null':
                            matches = !!cellText;
                            break;
                        case 'equals':
                            matches = useNumeric
                                ? Math.abs(cellNumeric - parsedInputValue) < 1e-9
                                : cellText.toLowerCase() === inputVal.toLowerCase();
                            break;
                        case 'not-equals':
                            matches = useNumeric
                                ? Math.abs(cellNumeric - parsedInputValue) > 1e-9
                                : cellText.toLowerCase() !== inputVal.toLowerCase();
                            break;
                        case 'contains':
                            matches = cellText.toLowerCase().includes(inputVal.toLowerCase());
                            break;
                        case 'starts-with':
                            matches = cellText.toLowerCase().startsWith(inputVal.toLowerCase());
                            break;
                        case 'ends-with':
                            matches = cellText.toLowerCase().endsWith(inputVal.toLowerCase());
                            break;
                        case 'greater-than':
                            matches = useNumeric ? cellNumeric > parsedInputValue : false;
                            break;
                        case 'less-than':
                            matches = useNumeric ? cellNumeric < parsedInputValue : false;
                            break;
                        case 'greater-than-equal':
                            matches = useNumeric ? cellNumeric >= parsedInputValue : false;
                            break;
                        case 'less-than-equal':
                            matches = useNumeric ? cellNumeric <= parsedInputValue : false;
                            break;
                        case 'like':
                            const escaped = inputVal.replace(/[-\\^$*+?.()|[\]{}]/g, '\\$&');
                            const pattern = '^' + escaped.replace(/%/g, '.*').replace(/_/g, '.') + '$';
                            matches = new RegExp(pattern, 'i').test(cellText);
                            break;
                        case 'unique':
                            // Handle unique across multiple columns
                            const selectedColumns = conditions
                                .filter(c => c.querySelector('.operator').value === 'unique')
                                .map(c => c.querySelector('.column-name').value);
                            if (selectedColumns.length === 0) {
                                matches = true;
                            } else {
                                const keyParts = selectedColumns.map(colName => {
                                    const idx = headers.findIndex(th => {
                                        const headerText = th.textContent.split('\n')[0];
                                        return headerText === colName;
                                    });
                                    return idx !== -1 ? row.cells[idx]?.textContent.trim() : '';
                                });
                                const compositeKey = keyParts.join('|||'); // Delimiter to avoid collisions
                                if (conditionType === 'AND' && index > 0) {
                                    // Only keep if previously visible AND unique
                                    matches = !seenComposites[compositeKey];
                                } else {
                                    matches = !seenComposites[compositeKey];
                                }
                                if (matches) {
                                    seenComposites[compositeKey] = true;
                                }
                            }
                            break;
                        default:
                            matches = false;
                    }
                }
                
                // Apply logic based on condition index and type
                if (index === 0) {
                    if (!matches) row.style.display = 'none';
                } else {
                    if (conditionType === 'AND') {
                        if (!matches) row.style.display = 'none';
                    } else { // OR
                        if (matches) row.style.display = '';
                    }
                }
            });
        });
        // Notify pagination system
if (fileDataSection && typeof fileDataSection.currentFilterCallback === 'function') {
    const visibleRows = Array.from(tableBody.querySelectorAll('tr')).filter(r => r.style.display !== 'none');
    fileDataSection.currentFilterCallback(visibleRows);
} else {
    // Fallback
    const visibleCount = Array.from(tableBody.querySelectorAll('tr')).filter(r => r.style.display !== 'none').length;
    showStatus(`Advanced filter applied: ${visibleCount} rows`, 'success');
}
    }

    
    function resetAdvancedFilter(fileDataSection) {
    const advancedSearchContainer = fileDataSection.querySelector('.advanced-search-container');
    fileDataSection.currentAdvancedFilterActive = false;
    const conditions = advancedSearchContainer.querySelectorAll('.condition-group');
    
    // Reset all condition groups
    conditions.forEach((conditionGroup, index) => {
        if (index === 0) {
            conditionGroup.querySelector('.value').value = '';
            conditionGroup.seenValues = {}; // Reset unique tracking
        } else {
            if (conditionGroup.parentNode) {
                conditionGroup.remove();
            }
        }
    });

    const tableBody = fileDataSection.querySelector('tbody');
    const allRows = Array.from(tableBody.querySelectorAll('tr')); // Get all rows

    // Show all rows
    allRows.forEach(row => {
        row.style.display = '';
    });

    // âœ… Notify pagination system that filter is reset
    if (fileDataSection && typeof fileDataSection.currentFilterCallback === 'function') {
        fileDataSection.currentFilterCallback(allRows); // Pass all rows
    }

    showStatus('Advanced filter reset', 'success');
}

    function parseFormattedNumber(value) {
        if (typeof value !== 'string') value = String(value);
        value = value.trim();
        // Handle percentage: convert to decimal
        if (value.includes('%')) {
            const numericPart = value.replace(/[%$â‚¬Â£Â¥â‚¹,]/g, '');
            const num = parseFloat(numericPart);
            return isNaN(num) ? null : num / 100;
        }
        // Extract number from currency/commas
        const numericPart = value.replace(/[$â‚¬Â£Â¥â‚¹,]/g, '');
        const num = parseFloat(numericPart);
        return isNaN(num) ? null : num;
    }
    
    // --- NEW: Sorting Functions ---
    function sortTableData(fileDataSection, columnIndex, sheetName) {
    const table = fileDataSection.querySelector('table');
    const tableHeader = table.querySelector('thead');
    const tableBody = table.querySelector('tbody');

    // Get current search filters
    const searchTerms = {};
    const headers = tableHeader.querySelectorAll('th');
    headers.forEach((th, idx) => {
        const input = th.querySelector('input');
        if (input && input.value.trim()) {
            searchTerms[idx] = input.value.trim().toLowerCase();
        }
    });

    // Get the current sort state
    const currentState = sortingState[fileDataSection.fileName]?.[sheetName]?.[columnIndex] || 'none';
    const nextSortState = currentState === 'none' || currentState === 'desc' ? 'asc' : 'desc';

    // Update sort state
    if (!sortingState[fileDataSection.fileName]) sortingState[fileDataSection.fileName] = {};
    if (!sortingState[fileDataSection.fileName][sheetName]) sortingState[fileDataSection.fileName][sheetName] = {};
    sortingState[fileDataSection.fileName][sheetName][columnIndex] = nextSortState;

    // Reset header indicators
    headers.forEach(th => {
        th.classList.remove('sorted-asc', 'sorted-desc');
    });
    headers[columnIndex]?.classList.add(nextSortState === 'asc' ? 'sorted-asc' : 'sorted-desc');

    // Get column type info
    const dateTimeInfo = fileDataSection.dateTimeInfo?.[sheetName];
    const isDateColumn = dateTimeInfo?.dateColumns?.includes(columnIndex);

    // --- Get all rows (including hidden ones) ---
    const allRows = Array.from(tableBody.querySelectorAll('tr'));

    // Sort all rows
    const sortedRows = allRows.sort((a, b) => {
        const cellA = a.cells[columnIndex];
        const cellB = b.cells[columnIndex];
        if (!cellA || !cellB) return 0;

        const valA = cellA.textContent.trim();
        const valB = cellB.textContent.trim();
        let comparison = 0;

        if (isDateColumn) {
            const dateA = parseDate(valA);
            const dateB = parseDate(valB);
            if (dateA && dateB) {
                comparison = dateA - dateB;
            } else if (dateA) {
                comparison = 1;
            } else if (dateB) {
                comparison = -1;
            } else {
                comparison = valA.localeCompare(valB);
            }
        } else if (valA !== '' && valB !== '') {
            const numA = parseFormattedNumber(valA);
            const numB = parseFormattedNumber(valB);
            if (numA !== null && numB !== null) {
                comparison = numA - numB;
            } else {
                const floatA = parseFloat(valA);
                const floatB = parseFloat(valB);
                if (!isNaN(floatA) && !isNaN(floatB)) {
                    comparison = floatA - floatB;
                } else {
                    comparison = valA.localeCompare(valB);
                }
            }
        } else {
            if (valA === '' && valB === '') comparison = 0;
            else if (valA === '') comparison = 1;
            else comparison = -1;
        }

        return nextSortState === 'desc' ? -comparison : comparison;
    });

    // Re-append sorted rows to update DOM order
    sortedRows.forEach(row => tableBody.appendChild(row));

    // âœ… Re-apply the current filter after sorting
    if (Object.keys(searchTerms).length > 0) {
        // Simulate filter re-apply using existing function
        filterTableData(fileDataSection.fileName, sheetName, table, searchTerms, fileDataSection);
    } else if (fileDataSection.currentAdvancedFilterActive) {
        // If advanced filter was applied, re-apply it
        applyAdvancedFilter(fileDataSection);
    } else {
        // No filter: just notify pagination system with all sorted rows
        if (typeof fileDataSection.currentFilterCallback === 'function') {
            fileDataSection.currentFilterCallback(sortedRows);
        }
    }

    showStatus(`Sorted column ${columnIndex + 1} ${nextSortState === 'asc' ? 'ascending' : 'descending'}`, 'success');
}

    function loadSheetData(sheetName, fileDataSection, sheetTabsContainer, tableHeader, tableBody, columnControls, fileName) {
    // 1. Update active tab
    updateActiveTab(sheetTabsContainer, sheetName);

    

    // 2. Lazy-load workbook if not already parsed
    if (!fileDataSection.workbook) {
        try {
            fileDataSection.workbook = XLSX.read(fileDataSection.fileDataArrayBuffer, {
                type: 'array',
                cellDates: false,
                cellNF: true,
                cellText: true
            });
        } catch (err) {
            showStatus(`Failed to parse workbook for ${fileName}.`, 'error');
            return;
        }
    }
    const workbook = fileDataSection.workbook;
    const worksheet = workbook.Sheets[sheetName];
    if (!worksheet) {
        tableBody.innerHTML = '<tr><td colspan="100">Sheet data not found.</td></tr>';
        return;
    }

    // 3. Extract data
    const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: '' });
    if (jsonData.length === 0) {
        renderEmptyState(tableHeader, tableBody, columnControls);
        return;
    }

    const headers = jsonData[0];

    // 4. Render UI Components
    renderTableHeader(headers, tableHeader, fileDataSection, fileName, sheetName);
    renderTableBody(headers, jsonData, worksheet, tableBody);
    initializeColumnControls(headers, columnControls, fileName, sheetName, tableHeader, tableBody);

    // 5. Apply visibility, sorting, and filtering
    applyHiddenColumns(fileName, sheetName, tableHeader, tableBody);
    applySavedSortState(headers, tableHeader, fileDataSection, fileName, sheetName);
    reapplyFilters(fileDataSection, fileName, sheetName, tableHeader, tableBody);

    // 6. Setup Pagination & Stats
    setupPaginationAndStats(fileDataSection, tableBody);

    // 7. Setup Advanced Search (rebind or create)
    setupAdvancedSearch(fileDataSection, headers);

    // 8. Add Export Controls (if not already present)
    if (!fileDataSection.querySelector('.export-controls')) {
        addExportControls(fileDataSection);
    }
    // 9. Setup Charting
    setupCharting(fileDataSection);

   

    
    setupStatsPanel(fileDataSection, headers, tableBody);

    
    


    if (!fileDataSection.querySelector('.toggle-pivot-btn')) {
        setupPivotAnalyzer(fileDataSection, headers, tableBody);
    }

    if (!fileDataSection._formulaControlsAdded) {
        addFormulaColumnControls(fileDataSection);
        fileDataSection._formulaControlsAdded = true;
    }
    if (!fileDataSection._dateTimeFormattingAdded) {
            addDateTimeFormattingControls(fileDataSection);
            fileDataSection._dateTimeFormattingAdded = true;
        }
    if (!fileDataSection._dataCleaningAdded) {
        addDataCleaningControls(fileDataSection);
        fileDataSection._dataCleaningAdded = true;
    }
}

function updateActiveTab(sheetTabsContainer, sheetName) {
    sheetTabsContainer.querySelectorAll('.sheet-tab').forEach(tab => {
        tab.classList.toggle('active', tab.textContent === sheetName);
    });
}
function renderEmptyState(tableHeader, tableBody, columnControls) {
    tableHeader.innerHTML = '';
    tableBody.innerHTML = '<tr><td colspan="100">No data available</td></tr>';
    columnControls.innerHTML = '';
}
function renderTableHeader(headers, tableHeader, fileDataSection, fileName, sheetName) {
    tableHeader.innerHTML = '';
    const headerRow = document.createElement('tr');
    const searchTerms = {};

    headers.forEach((header, index) => {
        const th = document.createElement('th');
        th.dataset.columnIndex = index;

        const headerContainer = document.createElement('div');
        headerContainer.style.display = 'flex';
        headerContainer.style.flexDirection = 'column';

        const headerText = document.createElement('div');
        headerText.textContent = header || `Column ${index}`;
        headerContainer.appendChild(headerText);

        const searchInput = document.createElement('input');
        searchInput.type = 'text';
        searchInput.placeholder = 'Search...';
        searchInput.style.cssText = `
            width: 100%; padding: 5px; margin-top: 5px; border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background-color: rgba(255, 255, 255, 0.1); color: white;
        `;
        searchInput.addEventListener('input', function () {
            const colIndex = parseInt(th.dataset.columnIndex);
            if (this.value.trim() === '') {
                delete searchTerms[colIndex];
            } else {
                searchTerms[colIndex] = this.value;
            }
            filterTableData(fileName, sheetName, tableHeader.closest('table'), searchTerms, fileDataSection);
        });
        headerContainer.appendChild(searchInput);
        th.appendChild(headerContainer);

        // Sort on click
        th.addEventListener('click', function (e) {
            if (e.target !== searchInput) {
                sortTableData(fileDataSection, index, sheetName);
            }
        });

        headerRow.appendChild(th);
    });
    tableHeader.appendChild(headerRow);
}
function renderTableBody(headers, jsonData, worksheet, tableBody) {
    tableBody.innerHTML = '';
    for (let i = 1; i < jsonData.length; i++) {
        const row = document.createElement('tr');
        const rowData = jsonData[i];
        headers.forEach((_, cellIndex) => {
            const td = document.createElement('td');
            let displayText = '';
            const cellAddress = XLSX.utils.encode_cell({ r: i, c: cellIndex });
            const cell = worksheet[cellAddress];
            if (cell) {
                displayText = cell.w !== undefined ? cell.w : cell.v;
            } else {
                displayText = rowData[cellIndex] || '';
            }
            td.textContent = displayText;
            row.appendChild(td);
        });
        tableBody.appendChild(row);
    }
}
function initializeColumnControls(headers, columnControls, fileName, sheetName, tableHeader, tableBody) {
    if (!hidden[fileName][sheetName]) hidden[fileName][sheetName] = [];
    columnControls.innerHTML = '';
    headers.forEach((header, index) => {
        const headerText = header || `Column ${index}`;
        const btn = document.createElement('button');
        btn.className = 'column-control-btn';
        btn.textContent = headerText;
        btn.dataset.columnIndex = index;
        if (hidden[fileName][sheetName].includes(headerText)) btn.classList.add('hidden');
        btn.addEventListener('click', function () {
            toggleColumnVisibility(index, headerText, fileName, sheetName, tableHeader, tableBody);
            this.classList.toggle('hidden');
        });
        columnControls.appendChild(btn);
    });
}
function applySavedSortState(headers, tableHeader, fileDataSection, fileName, sheetName) {
    const sortState = sortingState[fileName]?.[sheetName];
    if (!sortState) return;

    Object.keys(sortState).forEach(colIndexStr => {
        const colIndex = parseInt(colIndexStr);
        const state = sortState[colIndex];
        const th = tableHeader.querySelector(`th[data-column-index="${colIndex}"]`);
        if (th) {
            th.classList.remove('sorted-asc', 'sorted-desc');
            th.classList.add(state === 'asc' ? 'sorted-asc' : 'sorted-desc');
        }
    });
}
function reapplyFilters(fileDataSection, fileName, sheetName, tableHeader, tableBody) {
    const searchInputs = tableHeader.querySelectorAll('input');
    const searchTerms = {};
    searchInputs.forEach(input => {
        const th = input.parentElement.parentElement;
        const colIndex = th.dataset.columnIndex;
        if (input.value.trim()) {
            searchTerms[colIndex] = input.value;
        }
    });

    if (Object.keys(searchTerms).length > 0) {
        filterTableData(fileName, sheetName, tableHeader.closest('table'), searchTerms, fileDataSection);
    } else if (fileDataSection.currentAdvancedFilterActive) {
        applyAdvancedFilter(fileDataSection);
    } else {
        const allRows = Array.from(tableBody.querySelectorAll('tr'));
        if (typeof fileDataSection.currentFilterCallback === 'function') {
            fileDataSection.currentFilterCallback(allRows);
        }
    }
}
function setupPaginationAndStats(fileDataSection, tableBody) {
    const tableStats = fileDataSection.querySelector('.table-stats');
    const rowCountEl = tableStats.querySelector('.row-count');
    const paginationControls = tableStats.querySelector('.pagination-controls');
    const prevBtn = paginationControls.querySelector('.prev-page');
    const nextBtn = paginationControls.querySelector('.next-page');
    const pageInfo = paginationControls.querySelector('.page-info');

    const allRows = Array.from(tableBody.querySelectorAll('tr'));
    let filteredRows = [...allRows];
    let currentPage = 1;
    const rowsPerPage = 25;

    function updateStats() {
        const total = allRows.length;
        const visible = filteredRows.length;
        const totalPages = Math.ceil(visible / rowsPerPage);
        const start = (currentPage - 1) * rowsPerPage + 1;
        const end = Math.min(start + rowsPerPage - 1, visible);
        rowCountEl.textContent = `Total: ${total} | Displayed: ${visible}`;
        pageInfo.textContent = visible === 0 ? 'Page 0' : `Page ${currentPage} of ${totalPages} (${start}â€“${end})`;
        prevBtn.disabled = currentPage === 1;
        nextBtn.disabled = currentPage === totalPages || totalPages === 0;
    }

    function renderPage() {
        allRows.forEach(row => (row.style.display = 'none'));
        const start = (currentPage - 1) * rowsPerPage;
        const end = start + rowsPerPage;
        filteredRows.slice(start, end).forEach(row => (row.style.display = ''));
        updateStats();
    }

    function onFilterChange(filteredVisibleRows) {
        filteredRows = filteredVisibleRows;
        fileDataSection.filteredRows = filteredVisibleRows; // For export
        currentPage = 1;
        renderPage();
    }

    fileDataSection.currentFilterCallback = onFilterChange;

    prevBtn.addEventListener('click', () => {
        if (currentPage > 1) {
            currentPage--;
            renderPage();
        }
    });

    nextBtn.addEventListener('click', () => {
        const totalPages = Math.ceil(filteredRows.length / rowsPerPage);
        if (currentPage < totalPages) {
            currentPage++;
            renderPage();
        }
    });

    updateStats();
    renderPage();
}
function setupAdvancedSearch(fileDataSection, headers) {
    const advancedSearchContainer = fileDataSection.querySelector('.advanced-search-container');
    if (!advancedSearchContainer) {
        addAdvancedSearchControls(fileDataSection);
        return;
    }

    const conditionGroups = advancedSearchContainer.querySelectorAll('.condition-group');
    conditionGroups.forEach(group => {
        const select = group.querySelector('.column-name');
        if (select) {
            const prevValue = select.value;
            select.innerHTML = '';
            headers.forEach(h => {
                const opt = document.createElement('option');
                opt.value = h;
                opt.textContent = h;
                select.appendChild(opt);
            });
            if (Array.from(select.options).some(o => o.value === prevValue)) {
                select.value = prevValue;
            }
        }
    });

    setupConditionEvents(advancedSearchContainer, fileDataSection);
}

    function clearAllData() {
        dataSectionContainer.innerHTML = '';
        hidden = {};
        sortingState = {};
        fileInput.value = '';
        fileText.textContent = 'Drag & drop files here or click to browse';
        uploadBtn.disabled = true;
        fileList.innerHTML = '';
        showStatus('All data cleared', 'success');
    }
    
    function toggleColumnVisibility(columnIndex, columnName, fileName, sheetName, tableHeader, tableBody) {
        if (!hidden[fileName][sheetName]) hidden[fileName][sheetName] = [];
        const idx = hidden[fileName][sheetName].indexOf(columnName);
        if (idx > -1) {
            hidden[fileName][sheetName].splice(idx, 1);
        } else {
            hidden[fileName][sheetName].push(columnName);
        }
        applyHiddenColumns(fileName, sheetName, tableHeader, tableBody);
        showStatus(`Column "${columnName}" ${hidden[fileName][sheetName].includes(columnName) ? 'hidden' : 'shown'}`, 'success');
    }
    
    function applyHiddenColumns(fileName, sheetName, tableHeader, tableBody) {
        const headerCells = Array.from(tableHeader.querySelectorAll('th'));
        const bodyRows = tableBody.querySelectorAll('tr');
        bodyRows.forEach(row => row.querySelectorAll('td').forEach(td => td.classList.remove('hidden-column')));
        headerCells.forEach(th => th.classList.remove('hidden-column'));
        
        if (hidden[fileName] && hidden[fileName][sheetName]) {
            hidden[fileName][sheetName].forEach(colName => {
                const colIndex = headerCells.findIndex(th => th.textContent.trim() === colName);
                if (colIndex !== -1) {
                    headerCells[colIndex].classList.add('hidden-column');
                    bodyRows.forEach(row => {
                        const cells = row.querySelectorAll('td');
                        if (cells[colIndex]) cells[colIndex].classList.add('hidden-column');
                    });
                }
            });
        }
    }
    
    

function filterTableData(fileName, sheetName, table, searchTerms, fileDataSection) {
  
    const bodyRows = Array.from(table.querySelector('tbody').querySelectorAll('tr'));
    const headers = Array.from(table.querySelector('thead').querySelectorAll('th'));
    const lowerCaseSearchTerms = {};
    Object.keys(searchTerms).forEach(k => {
        if (searchTerms[k]) lowerCaseSearchTerms[k] = searchTerms[k].toLowerCase();
    });

    const filteredRows = bodyRows.filter(row => {
        const cells = row.querySelectorAll('td');
        let matches = true;
        Object.keys(lowerCaseSearchTerms).forEach(colIndex => {
            const term = lowerCaseSearchTerms[colIndex];
            if (colIndex < cells.length) {
                const text = (cells[colIndex].textContent || '').toLowerCase();
                if (!text.includes(term)) matches = false;
            }
        });
        return matches;
    });

    // Hide all rows first
    bodyRows.forEach(row => (row.style.display = 'none'));

    // Notify pagination system
    if (fileDataSection && typeof fileDataSection.currentFilterCallback === 'function') {
        fileDataSection.currentFilterCallback(filteredRows);
    } else {
        // Fallback: just show filtered
        filteredRows.forEach(row => (row.style.display = ''));
    }
    
    showStatus(`Filtered: ${filteredRows.length} rows match`, 'success');
}
    function showStatus(message, type) {
        statusDiv.textContent = message;
        statusDiv.className = `status ${type}`;
    }

    function addExportControls(fileDataSection) {
        // Create export controls container
        const exportControls = document.createElement('div');
        exportControls.className = 'export-controls';
        exportControls.style.cssText = `
            display: flex;
            gap: 10px;
            margin: 15px 0;
            flex-wrap: wrap;
        `;
        
        // Export full file button
        const exportFullBtn = document.createElement('button');
        exportFullBtn.className = 'export-btn full-data';
        exportFullBtn.textContent = 'Export Full File';
        exportFullBtn.style.cssText = `
            background: linear-gradient(to right, #4facfe, #00f2fe);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
        `;
        
        // Export visible data button
        const exportVisibleBtn = document.createElement('button');
        exportVisibleBtn.className = 'export-btn visible-data';
        exportVisibleBtn.textContent = 'Export Visible Data as CSV';
        exportVisibleBtn.style.cssText = `
            background: rgba(79, 172, 254, 0.3);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
        `;
        
        // Add buttons to container
        exportControls.appendChild(exportFullBtn);
        exportControls.appendChild(exportVisibleBtn);


        // Inside addExportControls(), after exportVisibleBtn
        const exportPdfBtn = document.createElement('button');
        exportPdfBtn.className = 'export-btn export-pdf';
        exportPdfBtn.textContent = 'Export Table as PDF';
        exportPdfBtn.style.cssText = `
        background: #dc3545;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 0.9rem;
        `;
        exportControls.appendChild(exportPdfBtn);

        // Attach event listener
        exportPdfBtn.addEventListener('click', () => {
        exportFullTableAsPDF(fileDataSection);
        });
        
        // Add event listeners
        exportFullBtn.addEventListener('click', () => {
            exportFileData(fileDataSection, 'full');
        });
        
        exportVisibleBtn.addEventListener('click', () => {
            exportFileData(fileDataSection, 'visible');
        });
        
        // Add export controls to the file data section
        const sheetData = fileDataSection.querySelector('.sheet-data');
        sheetData.parentNode.insertBefore(exportControls, sheetData);
        
        return exportControls;
    }

    function exportFullTableAsPDF(fileDataSection) {
    const fileName = fileDataSection.fileName || 'table_export';
    const activeTab = fileDataSection.querySelector('.sheet-tab.active');
    if (!activeTab) {
        showStatus('No active sheet to export.', 'error');
        return;
    }
    const sheetName = activeTab.textContent;

    // Get headers (only non-hidden columns) - FIXED: get full text
    const tableHeader = fileDataSection.querySelector('thead');
    const headerCells = Array.from(tableHeader.querySelectorAll('th'))
        .filter(th => !th.classList.contains('hidden-column'))
        .map(th => {
            // Correctly extract full column name, ignoring search inputs
            const headerTextElement = th.querySelector('.header-text') || th; // if you have a class for text
            return th.textContent.trim(); // Safe: modern browsers preserve full text even with inputs
        });

    // Use filteredRows if available, otherwise use all visible rows
    const tableBody = fileDataSection.querySelector('tbody');
    let dataRows = [];

    const rows = fileDataSection.filteredRows && Array.isArray(fileDataSection.filteredRows)
        ? fileDataSection.filteredRows
        : Array.from(tableBody.querySelectorAll('tr'));

    dataRows = rows.map(row => {
        return Array.from(row.cells)
            .filter((_, index) => {
                const header = tableHeader.querySelector(`th:nth-child(${index + 1})`);
                return header && !header.classList.contains('hidden-column');
            })
            .map(cell => cell.textContent.trim());
    });

    if (dataRows.length === 0) {
        showStatus('No data available to export.', 'error');
        return;
    }

    // Load jsPDF and autoTable
    if (typeof window.jspdf === 'undefined') {
        alert('jsPDF not loaded. Cannot export to PDF.');
        return;
    }
    const { jsPDF } = window.jspdf;

    // Create PDF (landscape to fit wide tables)
    const pdf = new jsPDF('l', 'mm', 'a4');
    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();

    // Add title
    pdf.setFontSize(16);
    pdf.text(`Data Export: ${fileName} - ${sheetName}`, 10, 15);

    // Generate table
    pdf.autoTable({
        head: [headerCells],
        body: dataRows,
        startY: 25,
        theme: 'striped',
        styles: { fontSize: 9, cellPadding: 3 },
        headStyles: { fillColor: [79, 172, 254], textColor: 255 },
        margin: { top: 15, left: 5, right: 5 },
        didDrawPage: function (data) {
            // Add footer
            const footerText = `Page ${pdf.getCurrentPageInfo?.().pageNumber || 1}`;
            const textWidth = pdf.getStringUnitWidth(footerText) * pdf.internal.getFontSize() / pdf.internal.scaleFactor;
            pdf.text(footerText, pageWidth - textWidth - 10, pageHeight - 10);
        }
    });

    // Save the PDF
    const dateStr = new Date().toISOString().slice(0, 10);
    pdf.save(`${fileName}_${sheetName}_table_export_${dateStr}.pdf`);
    showStatus(`Exported ${dataRows.length} rows as PDF successfully.`, 'success');
}

    function exportFileData(fileDataSection, exportType) {
    const fileName = fileDataSection.fileName;
    const sheetName = fileDataSection.querySelector('.sheet-tab.active')?.textContent;

    if (!sheetName) return;

    try {
        if (exportType === 'visible') {
            exportVisibleDataAsCSV(fileDataSection, sheetName, fileName);
        } else {
            // Pass fileDataSection so we can check for cleaned/edited state
            exportFullFile(fileDataSection.workbook, fileName, fileDataSection);
        }
    } catch (error) {
        console.error('Export error:', error);
        showStatus(`Export failed: ${error.message}`, 'error');
    }
}

    function exportVisibleDataAsCSV(fileDataSection, sheetName, originalFileName) {
    const tableBody = fileDataSection.querySelector('tbody');
    const tableHeader = fileDataSection.querySelector('thead');

    // Get headers (only non-hidden columns)
    const headers = Array.from(tableHeader.querySelectorAll('th'))
        .filter(th => !th.classList.contains('hidden-column'))
        .map(th => {
            const text = th.textContent.split('\n')[0]; // Remove search input line
            return text.trim();
        });

    // âœ… Use the full filteredRows list instead of DOM visibility
    let filteredRows = Array.from(tableBody.querySelectorAll('tr'));
    
    // Check if pagination system has a filtered list
    if (fileDataSection.filteredRows && Array.isArray(fileDataSection.filteredRows)) {
        filteredRows = fileDataSection.filteredRows;
    } else {
        // Fallback: use all rows (unfiltered)
        console.warn("No filteredRows found, exporting all data.");
    }

    // Extract data from all filtered rows
    const csvData = [];
    csvData.push(headers); // Header row

    filteredRows.forEach(row => {
        const rowData = [];
        const cells = row.querySelectorAll('td');
        Array.from(tableHeader.querySelectorAll('th')).forEach((th, index) => {
            if (!th.classList.contains('hidden-column') && cells[index]) {
                rowData.push(cells[index].textContent.trim());
            }
        });
        csvData.push(rowData);
    });

    // Convert to CSV string
    const csvString = csvData.map(row =>
        row.map(cell => {
            // Escape quotes and wrap if needed
            const escaped = String(cell).replace(/"/g, '""');
            return /[",\r\n]/.test(escaped) ? `"${escaped}"` : escaped;
        }).join(',')
    ).join('\n');

    // Create download
    const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    const url = URL.createObjectURL(blob);
    const baseName = originalFileName.replace(/\.[^/.]+$/, "");
    link.setAttribute('href', url);
    link.setAttribute('download', `${baseName}_${sheetName}_filtered_data.csv`);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);

    showStatus(`Exported ${filteredRows.length} filtered/sorted rows as CSV`, 'success');
}

    function exportFullFile(workbook, originalFileName, fileDataSection) {
    try {
        // Since there is no data editing functionality implemented,
        // we always export the original workbook.
        const finalWorkbook = workbook;

        // Generate file and trigger download
        const wbout = XLSX.write(finalWorkbook, { bookType: 'xlsx', type: 'array', cellDates: true });
        const blob = new Blob([wbout], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
        const link = document.createElement('a');
        const url = URL.createObjectURL(blob);
        link.setAttribute('href', url);
        link.setAttribute('download', originalFileName);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
        showStatus('Full file exported successfully', 'success');
    } catch (error) {
        console.error('Full file export error:', error);
        showStatus('Failed to export full file', 'error');
    }
}

function addChartControls(fileDataSection, headers) {
    const sheetData = fileDataSection.querySelector('.sheet-data');

    // Create toggle button
    const toggleChartBtn = document.createElement('button');
    toggleChartBtn.className = 'toggle-chart-btn';
    toggleChartBtn.textContent = 'Show Chart';
    toggleChartBtn.dataset.expanded = 'false';

    // Chart controls container
    const chartControls = document.createElement('div');
    chartControls.className = 'chart-controls';
    chartControls.innerHTML = `
        <div style="display: grid; gap: 10px; grid-template-columns: 1fr 1fr;">
            <div>
                <label>Chart Type:</label>
                <select class="chart-type">
                    <option value="bar">Bar</option>
                    <option value="line">Line</option>
                    <option value="pie">Pie</option>
                    <option value="doughnut">Doughnut</option>
                    <option value="radar">Radar</option>
                    <option value="polarArea">Polar Area</option>
                </select>
            </div>
            <div>
                <label>X-Axis Column:</label>
                <select class="x-axis-select"></select>
            </div>
        </div>
        <div>
            <label>Y-Axis Columns:</label>
            <div class="y-axis-container" style="display: flex; flex-wrap: wrap; gap: 8px; margin-top: 8px; max-height: 150px; overflow-y: auto; border: 1px solid rgba(255,255,255,0.3); border-radius: 6px; padding: 10px; background: rgba(0,0,0,0.1);">
                <!-- Y-axis column buttons will be inserted here -->
            </div>
        </div>
        <div class="chart-actions">
            <button class="generate-chart-btn">Generate Chart</button>
            <button class="export-chart-pdf-btn" style="background: #dc3545; color: white; border: none; padding: 6px 10px; border-radius: 4px; cursor: pointer; font-size: 0.9rem;">ðŸ“„ Export Chart as PDF</button>
        </div>
    `;

    // Chart container
    const chartWrapper = document.createElement('div');
    chartWrapper.className = 'chart-container-wrapper';
    chartWrapper.style.display = 'none';
    chartWrapper.innerHTML = `<canvas class="chart-canvas"></canvas>`;

    // Append elements
    sheetData.parentNode.insertBefore(toggleChartBtn, sheetData.nextSibling);
    sheetData.parentNode.insertBefore(chartControls, toggleChartBtn.nextSibling);
    sheetData.parentNode.insertBefore(chartWrapper, chartControls.nextSibling);

    // Populate X-Axis dropdown
    const xAxisSelect = chartControls.querySelector('.x-axis-select');
    headers.forEach(header => {
        const opt = document.createElement('option');
        opt.value = header;
        opt.textContent = header;
        xAxisSelect.appendChild(opt);
    });
    if (headers.length > 0) xAxisSelect.value = headers[0];

    // Populate Y-Axis as toggle buttons
    const yAxisContainer = chartControls.querySelector('.y-axis-container');
    headers.forEach(header => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'y-axis-btn';
        btn.dataset.value = header;
        btn.style.cssText = `
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        `;
        btn.textContent = header;

        // Toggle selection on click
        btn.addEventListener('click', function () {
            const isSelected = this.classList.toggle('selected');
            this.style.background = isSelected ? '#4facfe' : 'rgba(255, 255, 255, 0.1)';
            this.style.color = isSelected ? 'white' : '#ddd';
        });

        yAxisContainer.appendChild(btn);
    });

    // Store references
    fileDataSection.chartControls = chartControls;
    fileDataSection.chartWrapper = chartWrapper;
    fileDataSection.toggleChartBtn = toggleChartBtn;

    // Toggle visibility
    toggleChartBtn.addEventListener('click', () => {
        const isExpanded = toggleChartBtn.dataset.expanded === 'true';
        chartControls.style.display = isExpanded ? 'none' : 'block';
        chartWrapper.style.display = isExpanded ? 'none' : 'block';
        toggleChartBtn.textContent = isExpanded ? 'Show Chart' : 'Hide Chart';
        toggleChartBtn.dataset.expanded = isExpanded ? 'false' : 'true';
        if (!isExpanded) {
            setTimeout(() => {
                if (fileDataSection.chartInstance) {
                    fileDataSection.chartInstance.resize();
                }
            }, 100);
        }
    });

    // Generate chart button
    chartControls.querySelector('.generate-chart-btn').addEventListener('click', () => {
        renderChart(fileDataSection);
    });
    // Export Chart as PDF
chartControls.querySelector('.export-chart-pdf-btn').addEventListener('click', () => {
  if (!fileDataSection.chartInstance) {
    showStatus('No chart to export.', 'error');
    return;
  }

  // Dynamically load jsPDF if not available
  if (typeof window.jspdf === 'undefined') {
    alert('jsPDF not loaded. Cannot export chart.');
    return;
  }

  const { jsPDF } = window.jspdf;
  const canvas = chartWrapper.querySelector('.chart-canvas');

  // Confirm chart is visible and canvas exists
  if (!canvas) {
    showStatus('Chart canvas not found.', 'error');
    return;
  }

  // Extract image from canvas
  canvas.toBlob(function (blob) {
    if (!blob) {
      showStatus('Failed to generate chart image.', 'error');
      return;
    }

    // Create file reader to convert blob to data URL
    const reader = new FileReader();
    reader.onload = function () {
      const imgData = reader.result;

      // Create PDF (landscape for charts)
      const pdf = new jsPDF('l', 'mm', 'a4');
      const pdfWidth = pdf.internal.pageSize.getWidth();
      const pdfHeight = pdf.internal.pageSize.getHeight();

      // Calculate image dimensions (maintain aspect ratio)
      const imgProps = pdf.getImageProperties(imgData);
      const ratio = imgProps.height / imgProps.width;
      const imgWidth = pdfWidth - 20; // 10mm margin left/right
      const imgHeight = imgWidth * ratio;

      // Add image to PDF
      pdf.addImage(imgData, 'PNG', 10, 40, imgWidth, imgHeight);

      // Optional: Add title
      const fileName = fileDataSection.fileName || 'Chart';
      const sheetName = fileDataSection.querySelector('.sheet-tab.active')?.textContent || '';
      pdf.setFontSize(16);
      pdf.text(`Chart Export: ${fileName} - ${sheetName}`, 10, 30);

      // Save the PDF
      pdf.save(`chart_export_${new Date().toISOString().slice(0,10)}.pdf`);
    };
    reader.readAsDataURL(blob);
  });
});
}

function renderChart(fileDataSection) {
    const chartWrapper = fileDataSection.chartWrapper;
    const canvas = chartWrapper.querySelector('.chart-canvas');
    const chartType = fileDataSection.chartControls.querySelector('.chart-type').value;
    const xAxisCol = fileDataSection.chartControls.querySelector('.x-axis-select').value;

    // Get selected Y-axis columns from buttons
    const selectedYButtons = fileDataSection.chartControls.querySelectorAll('.y-axis-btn.selected');
    const yAxisCols = Array.from(selectedYButtons).map(btn => btn.dataset.value);

    if (!xAxisCol || yAxisCols.length === 0) {
        showStatus('Please select X and at least one Y column.', 'error');
        return;
    }

    // Destroy old chart
    destroyChart(fileDataSection);

    // Get current filtered/sorted rows
    let dataRows = fileDataSection.filteredRows || Array.from(fileDataSection.querySelector('tbody').querySelectorAll('tr'));
    if (dataRows.length === 0) {
        showStatus('No data to chart.', 'error');
        return;
    }

    // Get headers
    const headers = Array.from(fileDataSection.querySelector('thead').querySelectorAll('th'))
        .map(th => th.textContent.split('\n')[0].trim());
    const xIndex = headers.indexOf(xAxisCol);
    const yIndices = yAxisCols.map(col => headers.indexOf(col)).filter(idx => idx !== -1);

    if (xIndex === -1 || yIndices.length === 0) {
        showStatus('Invalid column selection.', 'error');
        return;
    }

    // Extract data
    const dataMap = new Map();
    const pieData = [];

    dataRows.forEach(row => {
        const cells = row.querySelectorAll('td');
        const xVal = cells[xIndex]?.textContent.trim() || 'Unknown';

        if (chartType === 'pie' || chartType === 'doughnut') {
            if (yIndices.length !== 1) {
                showStatus('Pie/Doughnut charts require exactly one Y column.', 'error');
                return;
            }
            const yVal = parseFloat(parseFormattedNumber(cells[yIndices[0]]?.textContent.trim()) || 0);
            pieData.push({ label: xVal, value: yVal });
        } else {
            if (!dataMap.has(xVal)) {
                dataMap.set(xVal, {});
            }
            const entry = dataMap.get(xVal);
            yIndices.forEach((yIdx, i) => {
                const key = yAxisCols[i];
                const val = parseFloat(parseFormattedNumber(cells[yIdx]?.textContent.trim()) || 0);
                entry[key] = (entry[key] || 0) + val;
            });
        }
    });

    // Prepare datasets
    let labels, datasets;
    if (chartType === 'pie' || chartType === 'doughnut') {
        labels = pieData.map(d => d.label);
        datasets = [{
            data: pieData.map(d => d.value),
            backgroundColor: generateColors(pieData.length)
        }];
    } else {
        labels = Array.from(dataMap.keys());
        datasets = yIndices.map((yIdx, i) => ({
            label: yAxisCols[i],
            data: labels.map(label => {
                const entry = dataMap.get(label);
                return entry ? entry[yAxisCols[i]] || 0 : 0;
            }),
            backgroundColor: `hsla(${(i * 137) % 360}, 70%, 60%, 0.7)`,
            borderColor: `hsla(${(i * 137) % 360}, 70%, 60%, 1)`,
            borderWidth: 1
        }));
    }

    // Show chart
    chartWrapper.style.display = 'block';
    const ctx = canvas.getContext('2d');

    fileDataSection.chartInstance = new Chart(ctx, {
  type: chartType,
  data: { labels, datasets },
  options: {
    responsive: true,
    maintainAspectRatio: false,
    plugins: {
      legend: { position: 'top' },
      title: { display: true, text: `Chart: ${xAxisCol} vs ${yAxisCols.join(', ')}` },
      datalabels: {
        color: '#fff',
        formatter: (value, context) => {
          const sum = context.dataset.data.reduce((acc, val) => acc + val, 0);
          const percentage = ((value / sum) * 100).toFixed(1) + '%';
          const label = context.chart.data.labels[context.dataIndex];
          return `${label}\n${percentage}`;
        },
        font: { weight: 'bold', size: 10 },
        textAlign: 'center',
        anchor: 'center'
      }
    },
    scales: (chartType === 'pie' || chartType === 'doughnut') ? {} : { y: { beginAtZero: true } }
  },
  plugins: [ChartDataLabels] // Only if plugin is global
});
}

function destroyChart(fileDataSection) {
    if (fileDataSection.chartInstance) {
        fileDataSection.chartInstance.destroy();
        fileDataSection.chartInstance = null;
    }
}

function generateColors(count) {
    return Array(count).fill().map((_, i) => `hsla(${(i * 360 / count) % 360}, 70%, 60%, 0.8)`);
}

// --- Hook into existing systems ---

// Modify setupPaginationAndStats to expose filteredRows
// Already done: fileDataSection.filteredRows is set

// Modify reapplyFilters to trigger chart update
const originalReapplyFilters = reapplyFilters;
window.reapplyFilters = function(fileDataSection, fileName, sheetName, tableHeader, tableBody) {
    originalReapplyFilters(fileDataSection, fileName, sheetName, tableHeader, tableBody);
    // Trigger chart update if visible
    if (fileDataSection.chartInstance && fileDataSection.toggleChartBtn?.dataset.expanded === 'true') {
        renderChart(fileDataSection);
    }
};

// Modify setupAdvancedSearch to trigger chart update
const originalApplyAdvancedFilter = applyAdvancedFilter;
window.applyAdvancedFilter = function(fileDataSection) {
    originalApplyAdvancedFilter(fileDataSection);
    if (fileDataSection.chartInstance && fileDataSection.toggleChartBtn?.dataset.expanded === 'true') {
        renderChart(fileDataSection);
    }

    
};

// Modify sortTableData to trigger chart update
const originalSortTableData = sortTableData;
window.sortTableData = function(fileDataSection, columnIndex, sheetName) {
    originalSortTableData(fileDataSection, columnIndex, sheetName);
    if (fileDataSection.chartInstance && fileDataSection.toggleChartBtn?.dataset.expanded === 'true') {
        setTimeout(() => renderChart(fileDataSection), 100); // Wait for DOM update
    }
    
};

function setupCharting(fileDataSection) {
    const sheetData = fileDataSection.querySelector('.sheet-data');
    const table = sheetData.querySelector('table');
    const tableHeader = table.querySelector('thead');
    const headers = Array.from(tableHeader.querySelectorAll('th')).map(th => {
        return th.textContent.split('\n')[0].trim();
    });

    const chartControls = fileDataSection.chartControls;
    const chartWrapper = fileDataSection.chartWrapper;
    const toggleChartBtn = fileDataSection.toggleChartBtn;

    if (!chartControls || !chartWrapper || !toggleChartBtn) {
        addChartControls(fileDataSection, headers);
        return;
    }

    // Update X-axis dropdown
    const xAxisSelect = chartControls.querySelector('.x-axis-select');
    const previousX = xAxisSelect.value;
    xAxisSelect.innerHTML = '';
    headers.forEach(header => {
        const opt = document.createElement('option');
        opt.value = header;
        opt.textContent = header;
        xAxisSelect.appendChild(opt);
    });
    xAxisSelect.value = headers.includes(previousX) ? previousX : (headers[0] || '');

    // Rebuild Y-axis buttons
    const yAxisContainer = chartControls.querySelector('.y-axis-container');
    const selectedValues = new Set(
        Array.from(yAxisContainer.querySelectorAll('.y-axis-btn.selected')).map(btn => btn.dataset.value)
    );
    yAxisContainer.innerHTML = '';

    headers.forEach(header => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'y-axis-btn';
        btn.dataset.value = header;
        btn.textContent = header;
        btn.style.cssText = `
            background: ${selectedValues.has(header) ? '#4facfe' : 'rgba(255,255,255,0.1)'};
            color: ${selectedValues.has(header) ? 'white' : 'white'};
            border: 1px solid rgba(255,255,255,0.3);
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        `;
        if (selectedValues.has(header)) {
            btn.classList.add('selected');
        }
        btn.addEventListener('click', function () {
            const isSelected = this.classList.toggle('selected');
            this.style.background = isSelected ? '#4facfe' : 'rgba(255,255,255,0.1)';
            this.style.color = isSelected ? 'white' : '#ddd';
        });
        yAxisContainer.appendChild(btn);
    });
}

// === MODIFIED setupStatsPanel ===
function setupStatsPanel(fileDataSection, initialHeaders, initialTableBody) {
    const statsPanel = fileDataSection.querySelector('.stats-panel');
    const toggleBtn = fileDataSection.querySelector('.stats-toggle-btn');
    // Prevent duplicate setup
    if (fileDataSection._statsSetupDone) return;
    fileDataSection._statsSetupDone = true;

    // Initialize storage for user-selected date formats for this file
    if (!fileDataSection.userSelectedDateFormats) {
        fileDataSection.userSelectedDateFormats = {};
    }

    toggleBtn.addEventListener('click', () => {
        const isHidden = statsPanel.style.display === 'none' || !statsPanel.style.display;
        statsPanel.style.display = isHidden ? 'block' : 'none';
        toggleBtn.textContent = isHidden ? 'Hide Statistics' : 'Show Statistics';
        if (isHidden) return;
        // Re-compute stats for current sheet/view
        updateStatsForCurrentSheet(fileDataSection);
    });

    // Central function to compute stats for the current sheet and filter state
    function updateStatsForCurrentSheet(section) {
        const activeTab = section.querySelector('.sheet-tab.active');
        if (!activeTab) return;
        const sheetName = activeTab.textContent;
        const tableBody = section.querySelector('tbody');
        const tableHeader = section.querySelector('thead');
        if (!tableBody || !tableHeader) return;

        // Get current headers (from DOM, not cached)
        const headers = Array.from(tableHeader.querySelectorAll('th'))
            .map(th => th.textContent.split('\n')[0].trim());

        // Get all rows (original full list)
        const allRows = Array.from(tableBody.querySelectorAll('tr'));

        // Determine which rows to use
        let rowsForStats = allRows;
        if (section.currentAdvancedFilterActive && Array.isArray(section.filteredRows)) {
            rowsForStats = section.filteredRows;
        } else {
            // Check if any search input has value
            const searchInputs = tableHeader.querySelectorAll('input');
            const hasSearch = Array.from(searchInputs).some(input => input.value.trim() !== '');
            if (hasSearch && Array.isArray(section.filteredRows)) {
                rowsForStats = section.filteredRows;
            }
        }

        // --- NEW: Check for Date Columns and Render Format Selectors ---
        const dateTimeInfo = section.dateTimeInfo?.[sheetName] || {};
        const dateCols = new Set(dateTimeInfo.dateColumns || []);

        // Create or clear the format selector container
        let formatSelectorContainer = statsPanel.querySelector('.date-format-selectors');
        if (!formatSelectorContainer) {
            formatSelectorContainer = document.createElement('div');
            formatSelectorContainer.className = 'date-format-selectors';
            formatSelectorContainer.style.cssText = `
                margin-bottom: 15px;
                padding: 15px;
                background: rgba(0, 0, 0, 0.3);
                border-radius: 8px;
                display: none; /* Will be shown if date columns exist */
            `;
            formatSelectorContainer.innerHTML = `<h4 style="margin-bottom: 10px; color: #00f2fe;">Select Date Formats</h4>`;
            statsPanel.insertBefore(formatSelectorContainer, statsPanel.querySelector('#statsGrid'));
        } else {
            formatSelectorContainer.innerHTML = `<h4 style="margin-bottom: 10px; color: #00f2fe;">Select Date Formats</h4>`;
        }

        // Flag to track if we found any date columns
        let hasDateColumns = false;

        // For each header, if it's a date column, add a selector
        headers.forEach((header, colIndex) => {
            if (dateCols.has(colIndex)) {
                hasDateColumns = true;

                const selectorDiv = document.createElement('div');
                selectorDiv.style.marginBottom = '10px';

                const label = document.createElement('label');
                label.textContent = `${header}: `;
                label.style.display = 'block';
                label.style.marginBottom = '5px';

                const select = document.createElement('select');
                select.className = 'date-format-selector';
                select.dataset.columnIndex = colIndex;
                select.dataset.columnName = header;

                // Define format options
                const formatOptions = [
                    { value: 'auto', label: 'Auto-Detect' },
                    { value: 'MM/DD/YYYY', label: 'MM/DD/YYYY (e.g., 01/04/2024)' },
                    { value: 'DD/MM/YYYY', label: 'DD/MM/YYYY (e.g., 04/01/2024)' },
                    { value: 'YYYY-MM-DD', label: 'YYYY-MM-DD (e.g., 2024-01-04)' },
                    
                ];

                formatOptions.forEach(opt => {
                    const option = document.createElement('option');
                    option.value = opt.value;
                    option.textContent = opt.label;
                    // Set selected value from user preference or default to 'auto'
                    if (section.userSelectedDateFormats[sheetName]?.[header] === opt.value) {
                        option.selected = true;
                    }
                    select.appendChild(option);
                });

                // Add event listener to store user selection
                select.addEventListener('change', function() {
                    if (!section.userSelectedDateFormats[sheetName]) {
                        section.userSelectedDateFormats[sheetName] = {};
                    }
                    section.userSelectedDateFormats[sheetName][header] = this.value;
                    // Recompute stats immediately on change
                    computeColumnStats(section, headers, rowsForStats, sheetName);
                });

                selectorDiv.appendChild(label);
                selectorDiv.appendChild(select);
                formatSelectorContainer.appendChild(selectorDiv);
            }
        });

        // Show or hide the format selector container
        formatSelectorContainer.style.display = hasDateColumns ? 'block' : 'none';

        // Recompute stats
        computeColumnStats(section, headers, rowsForStats, sheetName);
    }

    // ... (Rest of the existing setupStatsPanel code for hooks and listeners remains unchanged) ...
    // Hook into filter/sort updates, etc.
    const originalCallback = fileDataSection.currentFilterCallback;
    fileDataSection.currentFilterCallback = function (filteredRows) {
        if (typeof originalCallback === 'function') originalCallback(filteredRows);
        if (statsPanel.style.display === 'block') {
            updateStatsForCurrentSheet(fileDataSection);
        }
    };

    // Wrap sort function
    const originalSort = window.sortTableData;
    window.sortTableData = function (section, col, sheet) {
        originalSort(section, col, sheet);
        if (section === fileDataSection && statsPanel.style.display === 'block') {
            setTimeout(() => updateStatsForCurrentSheet(fileDataSection), 150);
        }
    };

    // Listen for sheet tab changes
    const sheetTabsContainer = fileDataSection.querySelector('.sheet-tabs');
    if (sheetTabsContainer) {
        sheetTabsContainer.addEventListener('click', function (e) {
            if (!e.target.classList.contains('sheet-tab')) return;
            // Wait for new sheet to load
            setTimeout(() => updateStatsForCurrentSheet(fileDataSection), 100);
        });
    }

    // Listen for column visibility changes
    const columnControls = fileDataSection.querySelector('.column-controls');
    if (columnControls) {
        columnControls.addEventListener('click', function (e) {
            if (e.target.classList.contains('column-control-btn') && statsPanel.style.display === 'block') {
                setTimeout(() => updateStatsForCurrentSheet(fileDataSection), 100);
            }
        });
    }
}

// === MODIFIED computeColumnStats ===
function computeColumnStats(fileDataSection, headers, dataRows, sheetName) {
    const statsGrid = fileDataSection.querySelector('#statsGrid');
    if (!statsGrid) return;
    statsGrid.innerHTML = '';

    // Add sheet header
    const sheetHeader = document.createElement('div');
    sheetHeader.style.cssText = 'grid-column: 1 / -1; font-weight: bold; color: #00f2fe; margin-bottom: 10px; padding-bottom: 5px; border-bottom: 1px solid rgba(255,255,255,0.3);';
    sheetHeader.textContent = `Sheet: ${sheetName}`;
    statsGrid.appendChild(sheetHeader);

    const fileName = fileDataSection.fileName;
    const dateTimeInfo = fileDataSection.dateTimeInfo?.[sheetName] || {};
    const dateCols = new Set(dateTimeInfo.dateColumns || {});

    // Get current visibility (from both hidden array and DOM)
    const tableHeader = fileDataSection.querySelector('thead');
    const headerCells = tableHeader?.querySelectorAll('th') || [];
    const hiddenColumns = new Set(hidden[fileName]?.[sheetName] || []);
    const columnVisibility = new Map();
    headers.forEach((header, idx) => {
        const th = headerCells[idx];
        const isHiddenByClass = th?.classList.contains('hidden-column');
        const isHiddenByName = hiddenColumns.has(header);
        columnVisibility.set(header, !(isHiddenByClass || isHiddenByName));
    });

    // Compute stats per visible column
    headers.forEach((header, colIndex) => {
        if (!columnVisibility.get(header)) return;

        const cellValues = dataRows
            .map(row => {
                const cell = row.cells[colIndex];
                return cell ? cell.textContent.trim() : '';
            })
            .filter(val => val !== '');

        const isDateCol = dateCols.has(colIndex);
        const statItem = document.createElement('div');
        statItem.className = 'stat-item';
        statItem.innerHTML = `<div class="stat-label">${header}</div>`;

        if (isDateCol) {
            // --- NEW: Get user-selected format for this column ---
            let formatHint = 'auto'; // Default
            if (fileDataSection.userSelectedDateFormats?.[sheetName]?.[header]) {
                formatHint = fileDataSection.userSelectedDateFormats[sheetName][header];
            }

            // If 'auto' is selected, pass null to use existing logic
            const actualFormatHint = formatHint === 'auto' ? null : formatHint;

            // Parse dates using the format hint
            const dates = cellValues.map(val => parseDate(val, actualFormatHint)).filter(d => d);

            if (dates.length > 0) {
                const minDate = new Date(Math.min(...dates));
                const maxDate = new Date(Math.max(...dates));
                const avgTime = dates.reduce((sum, d) => sum + d.getTime(), 0) / dates.length;
                const avgDate = new Date(avgTime);

                statItem.innerHTML += `
                    <div class="stat-value">Min: ${minDate.toLocaleDateString()}</div>
                    <div class="stat-value">Max: ${maxDate.toLocaleDateString()}</div>
                    <div class="stat-value">Avg: ${avgDate.toLocaleDateString()}</div>
                    <div class="stat-value">Range: ${minDate.toLocaleDateString()} â†’ ${maxDate.toLocaleDateString()}</div>
                    <div class="stat-value">Count: ${dates.length}</div>
                    <div class="stat-value">Span: ${Math.ceil((maxDate - minDate) / (24 * 60 * 60 * 1000))} days</div>
                `;
            } else {
                statItem.innerHTML += `<div class="stat-value">No valid dates</div>`;
            }
        } else {
            // ... (Existing logic for non-date columns remains unchanged) ...
            const parsedNumbers = cellValues
                .map(v => parseFormattedNumber(v))
                .filter(n => n !== null && !isNaN(n));
            if (parsedNumbers.length > 0) {
                const sum = parsedNumbers.reduce((a, b) => a + b, 0);
                const avg = sum / parsedNumbers.length;
                const sorted = [...parsedNumbers].sort((a, b) => a - b);
                const median = sorted.length % 2 === 0
                    ? (sorted[sorted.length / 2 - 1] + sorted[sorted.length / 2]) / 2
                    : sorted[Math.floor(sorted.length / 2)];
                const variance = parsedNumbers.reduce((acc, val) => acc + Math.pow(val - avg, 2), 0) / parsedNumbers.length;
                const stdDev = Math.sqrt(variance);
                statItem.innerHTML += `
                    <div class="stat-value">Avg: ${avg.toFixed(2)}</div>
                    <div class="stat-value">Sum: ${sum.toFixed(2)}</div>
                    <div class="stat-value">Min: ${sorted[0].toFixed(2)} | Max: ${sorted[sorted.length - 1].toFixed(2)}</div>
                    <div class="stat-value">Median: ${median.toFixed(2)}</div>
                    <div class="stat-value">Std Dev: ${stdDev.toFixed(2)}</div>
                    <div class="stat-value">Count: ${parsedNumbers.length}</div>
                `;
            } else {
                const uniqueValues = new Set(cellValues);
                statItem.innerHTML += `
                    <div class="stat-value">Unique: ${uniqueValues.size}</div>
                    <div class="stat-value">Total: ${cellValues.length}</div>
                `;
            }
        }
        statsGrid.appendChild(statItem);
    });
}
// Add this function to extract the Google Sheets ID from URL
function getGoogleSheetsId(url) {
    // Handle various Google Sheets URL formats
    const patterns = [
        /docs\.google\.com\/spreadsheets\/d\/([a-zA-Z0-9-_]+)/,
        /spreadsheets\/d\/([a-zA-Z0-9-_]+)/,
        /key=([a-zA-Z0-9-_]+)/
    ];
    
    for (const pattern of patterns) {
        const match = url.match(pattern);
        if (match && match[1]) {
            return match[1];
        }
    }
    return null;
}

// Add this function to handle loading from URL
async function loadFromUrl() {
    const url = urlInput.value.trim();
    if (!url) {
        showStatus('Please enter a URL', 'error');
        return;
    }
    
    showStatus('Processing URL...', 'success');
    loadUrlBtn.disabled = true;
    
    try {
        let arrayBuffer;
        let fileName = 'web_file.xlsx';
        
        // Check if it's a Google Sheets URL
        const googleSheetsId = getGoogleSheetsId(url);
        if (googleSheetsId) {
            // Convert Google Sheets URL to export URL
            const exportUrl = `https://docs.google.com/spreadsheets/d/${googleSheetsId}/export?format=xlsx`;
            fileName = `google_sheet_${googleSheetsId}.xlsx`;
            
            showStatus('Fetching Google Sheet...', 'success');
            const response = await fetch(exportUrl);
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            arrayBuffer = await response.arrayBuffer();
        } else {
            // Assume it's a direct file URL
            showStatus('Fetching file...', 'success');
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            // Try to get filename from URL or headers
            const contentDisposition = response.headers.get('content-disposition');
            if (contentDisposition) {
                const filenameMatch = contentDisposition.match(/filename[^;=\n]*=.*((['"]).*?\2|[^;\n]*)/);
                if (filenameMatch && filenameMatch[1]) {
                    fileName = filenameMatch[1].replace(/['"]/g, '');
                }
            } else {
                // Extract filename from URL path
                const urlParts = url.split('/');
                const lastPart = urlParts[urlParts.length - 1];
                if (lastPart && lastPart.includes('.')) {
                    fileName = lastPart.split('?')[0]; // Remove query parameters
                }
            }
            
            arrayBuffer = await response.arrayBuffer();
        }
        
        // Process the fetched file just like uploaded files
        await processSingleUrlFile(arrayBuffer, fileName);
        showStatus(`Successfully loaded ${fileName}`, 'success');
    } catch (error) {
        showStatus(`Error loading URL: ${error.message}`, 'error');
        console.error('URL loading error:', error);
    } finally {
        loadUrlBtn.disabled = false;
    }
}

// Add this function to process a single file from URL
async function processSingleUrlFile(arrayBuffer, fileName) {
    try {
        showStatus(`Analyzing formats for ${fileName}...`, 'success');
        // Create a blob from the array buffer to use with detectDateTimeFormats
        const blob = new Blob([arrayBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
        
        // Create a File object
        const file = new File([blob], fileName, { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
        
        const dateTimeInfo = await detectDateTimeFormats(file);
        console.log(`Date/Time Info for ${fileName}:`, dateTimeInfo);
        
        const fileDataSectionFragment = fileDataSectionTemplate.content.cloneNode(true);
        const fileDataSection = fileDataSectionFragment.querySelector('.file-data-section');
        fileDataSection.fileName = fileName;
        fileDataSection.dateTimeInfo = dateTimeInfo;
        const deleteBtn = fileDataSection.querySelector('.delete-section-btn');
        deleteBtn.addEventListener('click', () => deleteFileSection(fileDataSection));
        const fileTitle = fileDataSection.querySelector('.file-title');
        fileTitle.textContent = `Data from: ${fileName}`;
        const sheetTabsContainer = fileDataSection.querySelector('.sheet-tabs');
        const table = fileDataSection.querySelector('table');
        const tableHeader = table.querySelector('thead');
        const tableBody = table.querySelector('tbody');
        const noDataMessage = fileDataSection.querySelector('.no-data');
        const columnControls = fileDataSection.querySelector('.column-controls');
        if (!hidden[fileName]) hidden[fileName] = {};
        if (!sortingState[fileName]) sortingState[fileName] = {};
        
        // Store the array buffer directly
        fileDataSection.fileDataArrayBuffer = arrayBuffer;
        fileDataSection.workbook = null; // Will be parsed on demand
        
        // Read workbook structure to get sheet names
        const tempWorkbook = XLSX.read(arrayBuffer, { type: 'array', bookSheets: true, cellDates: true });
        const sheetNames = tempWorkbook.SheetNames;
        if (sheetNames.length === 0) {
            noDataMessage.style.display = 'block';
            table.style.display = 'none';
            columnControls.style.display = 'none';
        } else {
            noDataMessage.style.display = 'none';
            table.style.display = 'table';
            columnControls.style.display = 'flex';
            // Create tabs
            sheetNames.forEach((sheetName, tabIndex) => {
                const tab = document.createElement('div');
                tab.className = 'sheet-tab';
                if (tabIndex === 0) tab.classList.add('active');
                tab.textContent = sheetName;
                tab.addEventListener('click', function () {
                    // Lazy load sheet data when tab is clicked
                    loadSheetData(sheetName, fileDataSection, sheetTabsContainer, tableHeader, tableBody, columnControls, fileName, () => {
                    });
                      // === CLOSE PIVOT TABLE WHEN SWITCHING TABS ===
                                const pivotContainer = fileDataSection.querySelector('.pivot-container');
                                const togglePivotBtn = fileDataSection.querySelector('.toggle-pivot-btn');

                                if (pivotContainer && togglePivotBtn) {
                                    pivotContainer.style.display = 'none';
                                    togglePivotBtn.textContent = 'ðŸ“Š Pivot Analyzer';
                                }
                });
                sheetTabsContainer.appendChild(tab);
            });
            // Load first sheet immediately
            loadSheetData(sheetNames[0], fileDataSection, sheetTabsContainer, tableHeader, tableBody, columnControls, fileName);
        }
        dataSectionContainer.appendChild(fileDataSection);
        addFormattingControls(fileDataSection);
        

    } catch (err) {
        console.error('Error processing file from URL:', err);
        showStatus(`Error processing ${fileName}.`, 'error');
    }
}

// Add event listener for the URL input
function setupUrlEventListener() {
    loadUrlBtn.addEventListener('click', loadFromUrl);
    
    // Allow pressing Enter in the URL input
    urlInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            loadFromUrl();
        }
    });
}






// Add new function to create formatting controls
function addFormattingControls(fileDataSection) {
    const sheetData = fileDataSection.querySelector('.sheet-data');

    // Create format button
    const formatBtn = document.createElement('button');
    formatBtn.className = 'format-btn';
    formatBtn.textContent = 'ðŸŽ¨ Format Rows';
    formatBtn.style.cssText = `background: rgba(79, 172, 254, 0.3);color: white;border: 1px solid rgba(255, 255, 255, 0.3);padding: 8px 16px;border-radius: 5px;cursor: pointer;margin-bottom: 10px;font-size: 0.9rem;`;

    // Create modal container
    const modal = document.createElement('div');
    modal.className = 'format-modal';
    modal.style.cssText = `display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.7);`;

    // Modal content
    modal.innerHTML = `
        <div style="background: #1e1e1e; margin: 10% auto; padding: 20px; border-radius: 8px; width: 80%; max-width: 600px; color: white; border: 1px solid #444;">
            <h3>Format Rows</h3>
            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px;">Apply to:</label>
                <select class="format-apply-select" style="width: 100%; padding: 8px; background: #333; color: white; border: 1px solid #555; border-radius: 4px;">
                    <option value="all">All Rows</option>
                    <option value="visible">Visible Rows Only</option>
                </select>
            </div>
            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px;">Column:</label>
                <select class="format-column-select" style="width: 100%; padding: 8px; background: #333; color: white; border: 1px solid #555; border-radius: 4px;"></select>
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                <div>
                    <label style="display: block; margin-bottom: 5px;">Text Color:</label>
                    <input type="color" class="format-text-color" value="#ffffff" style="width: 100%; height: 35px;">
                </div>
                <div>
                    <label style="display: block; margin-bottom: 5px;">Background Color:</label>
                    <input type="color" class="format-bg-color" value="#000000" style="width: 100%; height: 35px;">
                </div>
            </div>
            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 20px;">
                <label style="display: flex; align-items: center;">
                    <input type="checkbox" class="format-bold" style="margin-right: 8px;">
                    Bold
                </label>
                <label style="display: flex; align-items: center;">
                    <input type="checkbox" class="format-italic" style="margin-right: 8px;">
                    Italic
                </label>
                <label style="display: flex; align-items: center;">
                    <input type="checkbox" class="format-underline" style="margin-right: 8px;">
                    Underline
                </label>
            </div>
            <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
                <button class="clear-all-format" style="background: rgba(255, 165, 0, 0.3);color: white;border: none;padding: 8px 16px;border-radius: 4px;cursor: pointer;">Clear All Format</button>
                <button class="cancel-format" style="background: rgba(255, 0, 0, 0.3);color: white;border: none;padding: 8px 16px;border-radius: 4px;cursor: pointer;">Cancel</button>
                <button class="apply-format" style="background: linear-gradient(to right, #4facfe, #00f2fe);color: white;border: none;padding: 8px 16px;border-radius: 4px;cursor: pointer;">Apply Format</button>
            </div>
        </div>
    `;

    // Add event listeners
    formatBtn.addEventListener('click', () => {
        populateColumnSelect();
        modal.style.display = 'block';
    });

    modal.querySelector('.cancel-format').addEventListener('click', () => {
        modal.style.display = 'none';
    });

    modal.querySelector('.clear-all-format').addEventListener('click', () => {
        if (!confirm('Are you sure you want to clear all formatting from this table?')) return;
        const tableBody = fileDataSection.querySelector('tbody');
        if (!tableBody) {
            showStatus('No table data found to clear.', 'error');
            return;
        }
        tableBody.querySelectorAll('td').forEach(cell => {
            cell.style.removeProperty('color');
            cell.style.removeProperty('background-color');
            cell.style.removeProperty('font-weight');
            cell.style.removeProperty('font-style');
            cell.style.removeProperty('text-decoration');
        });
        fileDataSection.rowFormatting = [];
        modal.style.display = 'none';
        showStatus('All formatting cleared.', 'success');
    });

    // Add elements to DOM
    sheetData.parentNode.insertBefore(formatBtn, sheetData);
    document.body.appendChild(modal);

    // Populate column dropdown
    function populateColumnSelect() {
        const select = modal.querySelector('.format-column-select');
        select.innerHTML = '';
        const thead = fileDataSection.querySelector('thead');
        if (!thead) return;
        const headers = thead.querySelectorAll('th');
        headers.forEach((th, index) => {
            if (th.style.display !== 'none') {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = th.textContent.trim();
                select.appendChild(option);
            }
        });
    }

    // Apply formatting
    modal.querySelector('.apply-format').addEventListener('click', () => {
        const columnIndex = parseInt(modal.querySelector('.format-column-select').value);
        const applyTo = modal.querySelector('.format-apply-select').value;
        const textColor = modal.querySelector('.format-text-color').value;
        const bgColor = modal.querySelector('.format-bg-color').value;
        const isBold = modal.querySelector('.format-bold').checked;
        const isItalic = modal.querySelector('.format-italic').checked;
        const isUnderline = modal.querySelector('.format-underline').checked;

        const fontWeight = isBold ? 'bold' : 'normal';
        const fontStyle = isItalic ? 'italic' : 'normal';
        const textDecoration = isUnderline ? 'underline' : 'none';

        const tableBody = fileDataSection.querySelector('tbody');
        if (!tableBody) {
            showStatus('No table data found.', 'error');
            return;
        }

        let rowsToFormat;
        if (applyTo === 'visible') {
            rowsToFormat = Array.from(tableBody.querySelectorAll('tr')).filter(row => 
                row.style.display !== 'none'
            );
        } else {
            rowsToFormat = Array.from(tableBody.querySelectorAll('tr'));
        }

        // Apply formatting to selected column cells
        rowsToFormat.forEach((row, rowIndex) => {
            const cell = row.cells[columnIndex];
            if (cell) {
                cell.style.color = textColor;
                cell.style.backgroundColor = bgColor;
                cell.style.fontWeight = fontWeight;
                cell.style.fontStyle = fontStyle;
                cell.style.textDecoration = textDecoration;
                
                // Store formatting information in a data attribute for persistence
                const formatInfo = {
                    rowIndex: rowIndex,
                    columnIndex: columnIndex,
                    textColor: textColor,
                    bgColor: bgColor,
                    fontWeight: fontWeight,
                    fontStyle: fontStyle,
                    textDecoration: textDecoration
                };
                
                // Store in cell's dataset
                cell.dataset.formatInfo = JSON.stringify(formatInfo);
            }
        });

        // Store formatting in a data attribute for persistence
        if (!fileDataSection.rowFormatting) {
            fileDataSection.rowFormatting = [];
        }

        // Save this formatting rule
        const formatRule = {
            column: columnIndex,
            textColor,
            bgColor,
            fontWeight,
            fontStyle,
            textDecoration,
            applyTo
        };
        fileDataSection.rowFormatting.push(formatRule);

        modal.style.display = 'none';
        showStatus(`Formatted ${rowsToFormat.length} rows`, 'success');
    });
}


// Add a parameter to hint the expected format or use a global/user setting
function parseDate(value, formatHint = null) {
    if (!value || typeof value !== 'string') return null;
    value = value.trim();

    // Handle ISO formats (most reliable)
    if (/^\d{4}-\d{2}-\d{2}/.test(value)) {
        const date = new Date(value);
        if (!isNaN(date.getTime())) return date;
    }

    // Handle common formats: MM/DD/YYYY, DD/MM/YYYY, MM-DD-YYYY, etc.
    const dateParts = value.split(/[/\-.\s]+/);
    if (dateParts.length >= 3) {
        let [p1, p2, p3] = dateParts.map(Number);
        const meridiemMatch = value.match(/(AM|PM)/i);
        let hours = 0, minutes = 0;

        // Extract time if present
        const timeMatch = value.match(/(\d{1,2}):(\d{2})(?::(\d{2}))?\s*(AM|PM)?/i);
        if (timeMatch) {
            hours = parseInt(timeMatch[1], 10);
            minutes = parseInt(timeMatch[2], 10);
            // const seconds = timeMatch[3] ? parseInt(timeMatch[3], 10) : 0; // Not used here
            const isPM = timeMatch[4] ? timeMatch[4].toUpperCase() === 'PM' : false;
            if (isPM && hours < 12) hours += 12;
            if (!isPM && hours === 12) hours = 0;
        }

        // --- Improved Format Guessing Logic ---
        // 1. Use formatHint if provided (e.g., 'MM/DD/YYYY' or 'DD/MM/YYYY')
        if (formatHint === 'MM/DD/YYYY' || formatHint === 'MM-DD-YYYY') {
            if (p1 >= 1 && p1 <= 12 && p2 >= 1 && p2 <= 31) { // Basic range check
                const month = p1 - 1; // JS months are 0-indexed
                const day = p2;
                let year = p3;
                if (year < 100) year += 2000; // Assume 20xx for 2-digit years
                const date = new Date(year, month, day, hours, minutes);
                if (date.getDate() === day && date.getMonth() === month && date.getFullYear() === year) {
                    return date;
                }
            }
        } else if (formatHint === 'DD/MM/YYYY' || formatHint === 'DD-MM-YYYY') {
             if (p2 >= 1 && p2 <= 12 && p1 >= 1 && p1 <= 31) { // Basic range check
                const day = p1;
                const month = p2 - 1; // JS months are 0-indexed
                let year = p3;
                if (year < 100) year += 2000; // Assume 20xx for 2-digit years
                const date = new Date(year, month, day, hours, minutes);
                 if (date.getDate() === day && date.getMonth() === month && date.getFullYear() === year) {
                    return date;
                }
            }
        }
        // 2. If no hint, fallback to existing (imperfect) logic or default
        else {
            if (p1 > 31) return null; // Invalid day/month
            if (p3 < 100) p3 += 2000; // 2-digit year

            let year, month, day;

            // Try MM/DD/YYYY or DD/MM/YYYY based on values (existing logic)
            if (p1 <= 12 && p2 > 12) {
                // Likely MM/DD/YYYY
                [month, day, year] = [p1 - 1, p2, p3]; // Adjust month for JS Date
            } else if (p2 <= 12 && p1 > 12) {
                // Likely DD/MM/YYYY
                [day, month, year] = [p1, p2 - 1, p3]; // Adjust month for JS Date
            } else if (p1 <= 12 && p2 <= 31) {
                // Ambiguous â€” assume MM/DD/YYYY (or make configurable)
                [month, day, year] = [p1 - 1, p2, p3]; // Adjust month for JS Date
            } else {
                return null; // Cannot determine format
            }

            const date = new Date(year, month, day, hours, minutes);
            // Validate the constructed date (e.g., Jan 32 becomes Feb 1)
            if (date.getFullYear() === year && date.getMonth() === month && date.getDate() === day) {
                return date;
            }
        }

         // Handle textual months: Jan, Feb, etc. (existing logic, could also be improved)
        const monthNames = {
            jan: 0, feb: 1, mar: 2, apr: 3, may: 4, jun: 5,
            jul: 6, aug: 7, sep: 8, oct: 9, nov: 10, dec: 11
        };
        const monthRegex = new RegExp(Object.keys(monthNames).join('|'), 'i');
        if (monthRegex.test(value)) {
            // ... (existing logic for textual months) ...
            // Ensure this also constructs a valid Date object correctly
        }
    }
    return null; // Parsing failed
}


// Add this new function to handle table joins
function addJoinTablesFeature() {
    // Create join tables button in the controls section
    const controlsSection = document.querySelector('.controls');
    const joinTablesBtn = document.createElement('button');
    joinTablesBtn.className = 'join-tables-btn';
    joinTablesBtn.textContent = 'ðŸ”— Join Tables';
    joinTablesBtn.style.cssText = `
        background: rgba(106, 27, 154, 0.3);
        color: white;
        border: 1px solid rgba(255, 255, 255, 0.3);
        padding: 8px 16px;
        border-radius: 5px;
        cursor: pointer;
        margin-left: 10px;
        font-size: 0.9rem;
    `;
    
    // Insert after clearAllBtn
    if (controlsSection) {
        controlsSection.appendChild(joinTablesBtn);
    }
    
    // Create modal for join interface
    const joinModal = document.createElement('div');
    joinModal.className = 'join-modal';
    joinModal.style.cssText = `
        display: none;
        position: fixed;
        z-index: 1001;
        left: 0; top: 0;
        width: 100%; height: 100%;
        background-color: rgba(0,0,0,0.5);
        justify-content: center;
        align-items: center;
    `;
    
    joinModal.innerHTML = `
        <div style="background-color: #2d2d2d; margin: auto; padding: 20px; border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; width: 90%; max-width: 800px; max-height: 90vh; overflow-y: auto; color: white;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h3>Join Tables</h3>
                <span class="close-join-modal" style="font-size: 24px; cursor: pointer;">&times;</span>
            </div>
            
            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px;">Left Table (From):</label>
                <select class="left-table-select" style="width: 100%; padding: 8px; border-radius: 4px; background-color: rgba(255, 255, 255, 0.1); color: white; border: 1px solid rgba(255, 255, 255, 0.3);">
                    <option value="">Select a table</option>
                </select>
            </div>
            
            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px;">Right Table (Join With):</label>
                <select class="right-table-select" style="width: 100%; padding: 8px; border-radius: 4px; background-color: rgba(255, 255, 255, 0.1); color: white; border: 1px solid rgba(255, 255, 255, 0.3);">
                    <option value="">Select a table</option>
                </select>
            </div>
            
            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px;">Join Type:</label>
                <select class="join-type-select" style="width: 100%; padding: 8px; border-radius: 4px; background-color: rgba(255, 255, 255, 0.1); color: white; border: 1px solid rgba(255, 255, 255, 0.3);">
                    <option value="inner">INNER JOIN (Only matching rows)</option>
                    <option value="left">LEFT JOIN (All from left, matching from right)</option>
                    <option value="right">RIGHT JOIN (All from right, matching from left)</option>
                    <option value="full">FULL OUTER JOIN (All rows from both tables)</option>
                </select>
            </div>
            
            <div class="join-columns-container" style="margin-bottom: 15px; padding: 15px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                <h4>Join Conditions</h4>
                <p style="margin-bottom: 10px; font-size: 0.9rem; opacity: 0.8;">Select columns to match between tables</p>
                <div class="join-condition" style="display: flex; gap: 10px; margin-bottom: 10px; align-items: center;">
                    <select class="left-column-select" style="flex: 1; padding: 8px; border-radius: 4px; background-color: rgba(255, 255, 255, 0.1); color: white; border: 1px solid rgba(255, 255, 255, 0.3);">
                        <option value="">Select left column</option>
                    </select>
                    <span style="font-weight: bold;">=</span>
                    <select class="right-column-select" style="flex: 1; padding: 8px; border-radius: 4px; background-color: rgba(255, 255, 255, 0.1); color: white; border: 1px solid rgba(255, 255, 255, 0.3);">
                        <option value="">Select right column</option>
                    </select>
                    <button class="add-join-condition" style="background: rgba(79, 172, 254, 0.3); color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer;">+</button>
                </div>
                <div class="additional-join-conditions"></div>
            </div>
            
            <div class="preview-section" style="margin-bottom: 15px; padding: 15px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
                <h4>Preview</h4>
                <div class="preview-table-container" style="max-height: 200px; overflow-y: auto; margin-top: 10px;">
                    <table class="preview-table" style="width: 100%; border-collapse: collapse; background: rgba(0, 0, 0, 0.3);">
                        <thead>
                            <tr>
                                <th style="padding: 8px; text-align: left; border-bottom: 1px solid rgba(255, 255, 255, 0.3);">Select tables and columns to preview</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td style="padding: 8px; text-align: left;">No data to preview</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <div class="preview-stats" style="margin-top: 10px; font-size: 0.9rem; opacity: 0.8;">
                    Rows: 0
                </div>
            </div>
            
            <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
                <button class="cancel-join" style="background: rgba(255, 0, 0, 0.3); color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">Cancel</button>
                <button class="apply-join" style="background: linear-gradient(to right, #4facfe, #00f2fe); color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">Apply Join</button>
            </div>
        </div>
    `;
    
    document.body.appendChild(joinModal);
    
    // Add event listeners
    joinTablesBtn.addEventListener('click', () => {
        populateTableSelects();
        joinModal.style.display = 'flex';
    });
    
    joinModal.querySelector('.close-join-modal').addEventListener('click', () => {
        joinModal.style.display = 'none';
    });
    
    joinModal.querySelector('.cancel-join').addEventListener('click', () => {
        joinModal.style.display = 'none';
    });
    
    // Populate table selects when modal opens
    function populateTableSelects() {
        const leftSelect = joinModal.querySelector('.left-table-select');
        const rightSelect = joinModal.querySelector('.right-table-select');
        
        leftSelect.innerHTML = '<option value="">Select a table</option>';
        rightSelect.innerHTML = '<option value="">Select a table</option>';
        
        // Get all file data sections
        const fileSections = document.querySelectorAll('.file-data-section');
        fileSections.forEach(section => {
            const fileName = section.fileName;
            const sheetTabs = section.querySelectorAll('.sheet-tab');
            
            sheetTabs.forEach(tab => {
                const sheetName = tab.textContent;
                const optionValue = `${fileName}|||${sheetName}`;
                const optionText = `${fileName} - ${sheetName}`;
                
                const leftOption = document.createElement('option');
                leftOption.value = optionValue;
                leftOption.textContent = optionText;
                leftSelect.appendChild(leftOption);
                
                const rightOption = document.createElement('option');
                rightOption.value = optionValue;
                rightOption.textContent = optionText;
                rightSelect.appendChild(rightOption);
            });
        });
        
        // Reset column selects
        joinModal.querySelector('.left-column-select').innerHTML = '<option value="">Select left column</option>';
        joinModal.querySelector('.right-column-select').innerHTML = '<option value="">Select right column</option>';
        joinModal.querySelector('.additional-join-conditions').innerHTML = '';
    }
    
    // Update column selects when tables are selected
    joinModal.querySelector('.left-table-select').addEventListener('change', updateColumnSelects);
    joinModal.querySelector('.right-table-select').addEventListener('change', updateColumnSelects);
    
    function updateColumnSelects() {
        const leftTableSelect = joinModal.querySelector('.left-table-select');
        const rightTableSelect = joinModal.querySelector('.right-table-select');
        const leftColumnSelect = joinModal.querySelector('.left-column-select');
        const rightColumnSelect = joinModal.querySelector('.right-column-select');
        
        // Clear existing options
        leftColumnSelect.innerHTML = '<option value="">Select left column</option>';
        rightColumnSelect.innerHTML = '<option value="">Select right column</option>';
        
        // Get selected tables
        const leftTableValue = leftTableSelect.value;
        const rightTableValue = rightTableSelect.value;
        
        if (!leftTableValue || !rightTableValue) return;
        
        // Parse table info
        const [leftFileName, leftSheetName] = leftTableValue.split('|||');
        const [rightFileName, rightSheetName] = rightTableValue.split('|||');
        
        // Get table headers for left table
        const leftSection = Array.from(document.querySelectorAll('.file-data-section')).find(s => s.fileName === leftFileName);
        if (leftSection) {
            const leftTab = Array.from(leftSection.querySelectorAll('.sheet-tab')).find(t => t.textContent === leftSheetName);
            if (leftTab && leftTab.classList.contains('active')) {
                // Table is already loaded, get headers from DOM
                updateColumnSelectFromSection(leftSection, leftColumnSelect);
            } else if (leftSection.workbook && leftSection.workbook.Sheets[leftSheetName]) {
                // Load headers from workbook
                const worksheet = leftSection.workbook.Sheets[leftSheetName];
                const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: '' });
                if (jsonData.length > 0) {
                    const headers = jsonData[0];
                    headers.forEach((header, index) => {
                        const option = document.createElement('option');
                        option.value = index;
                        option.textContent = header || `Column ${index + 1}`;
                        leftColumnSelect.appendChild(option);
                    });
                }
            }
        }
        
        // Get table headers for right table
        const rightSection = Array.from(document.querySelectorAll('.file-data-section')).find(s => s.fileName === rightFileName);
        if (rightSection) {
            const rightTab = Array.from(rightSection.querySelectorAll('.sheet-tab')).find(t => t.textContent === rightSheetName);
            if (rightTab && rightTab.classList.contains('active')) {
                // Table is already loaded, get headers from DOM
                updateColumnSelectFromSection(rightSection, rightColumnSelect);
            } else if (rightSection.workbook && rightSection.workbook.Sheets[rightSheetName]) {
                // Load headers from workbook
                const worksheet = rightSection.workbook.Sheets[rightSheetName];
                const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: '' });
                if (jsonData.length > 0) {
                    const headers = jsonData[0];
                    headers.forEach((header, index) => {
                        const option = document.createElement('option');
                        option.value = index;
                        option.textContent = header || `Column ${index + 1}`;
                        rightColumnSelect.appendChild(option);
                    });
                }
            }
        }
    }
    
    function updateColumnSelectFromSection(section, selectElement) {
        const tableHeader = section.querySelector('thead');
        if (tableHeader) {
            const headers = tableHeader.querySelectorAll('th');
            headers.forEach((th, index) => {
                // Skip hidden columns
                if (th.classList.contains('hidden-column')) return;
                
                const headerText = th.textContent.split('\n')[0].trim();
                const option = document.createElement('option');
                option.value = index;
                option.textContent = headerText || `Column ${index + 1}`;
                selectElement.appendChild(option);
            });
        }
    }
    
        // Add additional join condition (using event delegation for dynamic elements)
    joinModal.addEventListener('click', (e) => {
        if (e.target.classList.contains('add-join-condition')) {
            const additionalConditions = joinModal.querySelector('.additional-join-conditions');
            const conditionDiv = document.createElement('div');
            conditionDiv.className = 'join-condition';
            conditionDiv.style.cssText = 'display: flex; gap: 10px; margin-bottom: 10px; align-items: center;';
            conditionDiv.innerHTML = `
                <select class="left-column-select" style="flex: 1; padding: 8px; border-radius: 4px; background-color: rgba(255, 255, 255, 0.1); color: white; border: 1px solid rgba(255, 255, 255, 0.3);">
                    <option value="">Select left column</option>
                </select>
                <span style="font-weight: bold;">=</span>
                <select class="right-column-select" style="flex: 1; padding: 8px; border-radius: 4px; background-color: rgba(255, 255, 255, 0.1); color: white; border: 1px solid rgba(255, 255, 255, 0.3);">
                    <option value="">Select right column</option>
                </select>
                <button class="remove-join-condition" style="background: rgba(255, 0, 0, 0.3); color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer;">âœ•</button>
            `;

            // Get the MAIN (first) condition's selects to copy options from
            const mainLeftSelect = joinModal.querySelector('.join-condition:first-of-type .left-column-select');
            const mainRightSelect = joinModal.querySelector('.join-condition:first-of-type .right-column-select');
            const newLeftSelect = conditionDiv.querySelector('.left-column-select');
            const newRightSelect = conditionDiv.querySelector('.right-column-select');

            // Copy options for LEFT column
            if (mainLeftSelect) {
                Array.from(mainLeftSelect.options).forEach(option => {
                    const newOption = document.createElement('option');
                    newOption.value = option.value;
                    newOption.textContent = option.textContent;
                    newLeftSelect.appendChild(newOption);
                });
            }

            // Copy options for RIGHT column
            if (mainRightSelect) {
                Array.from(mainRightSelect.options).forEach(option => {
                    const newOption = document.createElement('option');
                    newOption.value = option.value;
                    newOption.textContent = option.textContent;
                    newRightSelect.appendChild(newOption);
                });
            }

            // Add remove button event (using delegation, but attaching directly here is fine)
            conditionDiv.querySelector('.remove-join-condition').addEventListener('click', () => {
                conditionDiv.remove();
                updatePreview(); // Update preview when a condition is removed
            });

            additionalConditions.appendChild(conditionDiv);
        }
    });
    // Preview join result
    joinModal.querySelector('.left-table-select').addEventListener('change', updatePreview);
    joinModal.querySelector('.right-table-select').addEventListener('change', updatePreview);
    joinModal.querySelector('.join-type-select').addEventListener('change', updatePreview);
    joinModal.querySelector('.left-column-select').addEventListener('change', updatePreview);
    joinModal.querySelector('.right-column-select').addEventListener('change', updatePreview);
    
    // Also listen for changes in additional conditions
    joinModal.querySelector('.additional-join-conditions').addEventListener('change', (e) => {
        if (e.target.classList.contains('left-column-select') || e.target.classList.contains('right-column-select')) {
            updatePreview();
        }
    });
    
    function updatePreview() {
        const leftTableSelect = joinModal.querySelector('.left-table-select');
        const rightTableSelect = joinModal.querySelector('.right-table-select');
        const leftColumnSelect = joinModal.querySelector('.left-column-select');
        const rightColumnSelect = joinModal.querySelector('.right-column-select');
        const joinTypeSelect = joinModal.querySelector('.join-type-select');
        
        // Check if required fields are selected
        if (!leftTableSelect.value || !rightTableSelect.value || !leftColumnSelect.value || !rightColumnSelect.value) {
            showPreviewMessage('Select tables and at least one join condition to preview');
            return;
        }
        
        try {
            // Get join conditions
            const joinConditions = [];
            const mainCondition = {
                leftColIndex: parseInt(leftColumnSelect.value),
                rightColIndex: parseInt(rightColumnSelect.value)
            };
            joinConditions.push(mainCondition);
            
            // Get additional conditions
            const additionalConditions = joinModal.querySelectorAll('.additional-join-conditions .join-condition');
            additionalConditions.forEach(condition => {
                const leftCol = condition.querySelector('.left-column-select');
                const rightCol = condition.querySelector('.right-column-select');
                if (leftCol.value && rightCol.value) {
                    joinConditions.push({
                        leftColIndex: parseInt(leftCol.value),
                        rightColIndex: parseInt(rightCol.value)
                    });
                }
            });
            
            // Get table data
            const [leftFileName, leftSheetName] = leftTableSelect.value.split('|||');
            const [rightFileName, rightSheetName] = rightTableSelect.value.split('|||');
            
            const leftSection = Array.from(document.querySelectorAll('.file-data-section')).find(s => s.fileName === leftFileName);
            const rightSection = Array.from(document.querySelectorAll('.file-data-section')).find(s => s.fileName === rightFileName);
            
            if (!leftSection || !rightSection) {
                showPreviewMessage('Error: Could not find table data');
                return;
            }
            
            // Get data from sections
            let leftData = getTableData(leftSection, leftSheetName);
            let rightData = getTableData(rightSection, rightSheetName);
            
            if (!leftData || !rightData) {
                showPreviewMessage('Error: Could not extract table data');
                return;
            }
            
            // Perform join
            const joinType = joinTypeSelect.value;
            const joinedData = performJoin(leftData, rightData, joinConditions, joinType);
            
            // Show preview (limited to first 5 rows)
            showPreviewData(joinedData, 5);
        } catch (error) {
            console.error('Error updating preview:', error);
            showPreviewMessage(`Error: ${error.message}`);
        }
    }
    
    function getTableData(section, sheetName) {
        // Try to get data from active sheet in DOM first
        const activeTab = section.querySelector('.sheet-tab.active');
        if (activeTab && activeTab.textContent === sheetName) {
            const table = section.querySelector('table');
            const headers = Array.from(table.querySelectorAll('thead th')).map(th => {
                return th.textContent.split('\n')[0].trim();
            });
            
            const rows = Array.from(table.querySelectorAll('tbody tr')).map(row => {
                return Array.from(row.querySelectorAll('td')).map(td => td.textContent.trim());
            });
            
            return {
                headers: headers,
                rows: rows
            };
        } 
        // Otherwise, get from workbook
        else if (section.workbook && section.workbook.Sheets[sheetName]) {
            const worksheet = section.workbook.Sheets[sheetName];
            const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: '' });
            if (jsonData.length === 0) return null;
            
            const headers = jsonData[0];
            const rows = jsonData.slice(1);
            
            return {
                headers: headers,
                rows: rows
            };
        }
        
        return null;
    }
    
    function performJoin(leftData, rightData, joinConditions, joinType) {
        const resultHeaders = [
            ...leftData.headers.map((h, i) => `Left_${i >= 0 ? h : `Column${i+1}`}`),
            ...rightData.headers.map((h, i) => `Right_${i >= 0 ? h : `Column${i+1}`}`)
        ];
        
        const resultRows = [];
        
        // Create a map for right table rows by join key
        const rightMap = new Map();
        
        // Process right table rows
        rightData.rows.forEach((rightRow, rightIndex) => {
            // Create composite key from all join conditions
            const keyParts = joinConditions.map(condition => {
                const value = rightRow[condition.rightColIndex];
                return value !== undefined ? String(value) : '';
            });
            const compositeKey = keyParts.join('|||');
            
            if (!rightMap.has(compositeKey)) {
                rightMap.set(compositeKey, []);
            }
            rightMap.get(compositeKey).push({row: rightRow, index: rightIndex});
        });
        
        // Process left table rows
        if (joinType === 'inner' || joinType === 'left' || joinType === 'full') {
            leftData.rows.forEach(leftRow => {
                // Create composite key for left row
                const keyParts = joinConditions.map(condition => {
                    const value = leftRow[condition.leftColIndex];
                    return value !== undefined ? String(value) : '';
                });
                const compositeKey = keyParts.join('|||');
                
                const matchingRightRows = rightMap.get(compositeKey) || [];
                
                if (matchingRightRows.length > 0) {
                    // Add rows for each match
                    matchingRightRows.forEach(({row: rightRow}) => {
                        resultRows.push([...leftRow, ...rightRow]);
                    });
                } else if (joinType === 'left' || joinType === 'full') {
                    // Add row with nulls for right table
                    resultRows.push([...leftRow, ...rightData.headers.map(() => '')]);
                }
            });
        }
        
        // Process right table rows for right join and full outer join
        if (joinType === 'right' || joinType === 'full') {
            const processedKeys = new Set();
            
            // First, mark all keys that were already processed in left join
            if (joinType === 'full') {
                leftData.rows.forEach(leftRow => {
                    const keyParts = joinConditions.map(condition => {
                        const value = leftRow[condition.leftColIndex];
                        return value !== undefined ? String(value) : '';
                    });
                    const compositeKey = keyParts.join('|||');
                    processedKeys.add(compositeKey);
                });
            }
            
            // Add unmatched right rows
            rightMap.forEach((rightRows, compositeKey) => {
                if (joinType === 'right' || !processedKeys.has(compositeKey)) {
                    rightRows.forEach(({row: rightRow}) => {
                        resultRows.push([...leftData.headers.map(() => ''), ...rightRow]);
                    });
                }
            });
        }
        
        return {
            headers: resultHeaders,
            rows: resultRows
        };
    }
    
    function showPreviewData(joinedData, maxRows = 5) {
        const previewTable = joinModal.querySelector('.preview-table');
        const previewStats = joinModal.querySelector('.preview-stats');
        
        // Clear existing table
        previewTable.innerHTML = '';
        
        // Create header row
        const thead = document.createElement('thead');
        const headerRow = document.createElement('tr');
        
        // Limit number of columns shown in preview to avoid overflow
        const maxCols = 10;
        const displayHeaders = joinedData.headers.slice(0, maxCols);
        if (joinedData.headers.length > maxCols) {
            displayHeaders.push('...');
        }
        
        displayHeaders.forEach(header => {
            const th = document.createElement('th');
            th.textContent = header;
            th.style.cssText = 'padding: 8px; text-align: left; border-bottom: 1px solid rgba(255, 255, 255, 0.3); font-size: 0.8rem;';
            th.title = header; // Show full header on hover
            headerRow.appendChild(th);
        });
        
        thead.appendChild(headerRow);
        previewTable.appendChild(thead);
        
        // Create body rows
        const tbody = document.createElement('tbody');
        
        // Limit rows for preview
        const displayRows = joinedData.rows.slice(0, maxRows);
        displayRows.forEach(row => {
            const tr = document.createElement('tr');
            
            // Limit columns
            const displayRow = row.slice(0, maxCols);
            if (row.length > maxCols) {
                displayRow.push('...');
            }
            
            displayRow.forEach(cell => {
                const td = document.createElement('td');
                td.textContent = cell;
                td.style.cssText = 'padding: 8px; text-align: left; font-size: 0.8rem;';
                td.title = cell; // Show full content on hover
                tr.appendChild(td);
            });
            
            tbody.appendChild(tr);
        });
        
        // Add message if no rows
        if (displayRows.length === 0) {
            const tr = document.createElement('tr');
            const td = document.createElement('td');
            td.textContent = 'No matching rows found';
            td.colSpan = displayHeaders.length;
            td.style.cssText = 'padding: 8px; text-align: center; font-style: italic;';
            tr.appendChild(td);
            tbody.appendChild(tr);
        }
        
        // Add info row if we have more data
        if (joinedData.rows.length > maxRows) {
            const tr = document.createElement('tr');
            const td = document.createElement('td');
            td.textContent = `... and ${joinedData.rows.length - maxRows} more rows`;
            td.colSpan = displayHeaders.length;
            td.style.cssText = 'padding: 8px; text-align: center; font-style: italic; background: rgba(255, 255, 255, 0.1);';
            tr.appendChild(td);
            tbody.appendChild(tr);
        }
        
        previewTable.appendChild(tbody);
        
        // Update stats
        previewStats.textContent = `Rows: ${joinedData.rows.length} | Columns: ${joinedData.headers.length}`;
    }
    
    function showPreviewMessage(message) {
        const previewTable = joinModal.querySelector('.preview-table');
        previewTable.innerHTML = `
            <thead>
                <tr>
                    <th style="padding: 8px; text-align: left; border-bottom: 1px solid rgba(255, 255, 255, 0.3);">Preview</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td style="padding: 8px; text-align: left;">${message}</td>
                </tr>
            </tbody>
        `;
        
        const previewStats = joinModal.querySelector('.preview-stats');
        previewStats.textContent = 'Rows: 0';
    }
    
    // Apply join
    joinModal.querySelector('.apply-join').addEventListener('click', () => {
        const leftTableSelect = joinModal.querySelector('.left-table-select');
        const rightTableSelect = joinModal.querySelector('.right-table-select');
        const leftColumnSelect = joinModal.querySelector('.left-column-select');
        const rightColumnSelect = joinModal.querySelector('.right-column-select');
        const joinTypeSelect = joinModal.querySelector('.join-type-select');
        
        // Validate inputs
        if (!leftTableSelect.value || !rightTableSelect.value) {
            showStatus('Please select both tables', 'error');
            return;
        }
        
        if (!leftColumnSelect.value || !rightColumnSelect.value) {
            showStatus('Please select at least one join condition', 'error');
            return;
        }
        
        try {
            // Get join conditions
            const joinConditions = [];
            const mainCondition = {
                leftColIndex: parseInt(leftColumnSelect.value),
                rightColIndex: parseInt(rightColumnSelect.value)
            };
            joinConditions.push(mainCondition);
            
            // Get additional conditions
            const additionalConditions = joinModal.querySelectorAll('.additional-join-conditions .join-condition');
            additionalConditions.forEach(condition => {
                const leftCol = condition.querySelector('.left-column-select');
                const rightCol = condition.querySelector('.right-column-select');
                if (leftCol.value && rightCol.value) {
                    joinConditions.push({
                        leftColIndex: parseInt(leftCol.value),
                        rightColIndex: parseInt(rightCol.value)
                    });
                }
            });
            
            // Get table data
            const [leftFileName, leftSheetName] = leftTableSelect.value.split('|||');
            const [rightFileName, rightSheetName] = rightTableSelect.value.split('|||');
            
            const leftSection = Array.from(document.querySelectorAll('.file-data-section')).find(s => s.fileName === leftFileName);
            const rightSection = Array.from(document.querySelectorAll('.file-data-section')).find(s => s.fileName === rightFileName);
            
            if (!leftSection || !rightSection) {
                showStatus('Error: Could not find table data', 'error');
                return;
            }
            
            // Get data from sections
            let leftData = getTableData(leftSection, leftSheetName);
            let rightData = getTableData(rightSection, rightSheetName);
            
            if (!leftData || !rightData) {
                showStatus('Error: Could not extract table data', 'error');
                return;
            }
            
            // Perform join
            const joinType = joinTypeSelect.value;
            const joinedData = performJoin(leftData, rightData, joinConditions, joinType);
            
            // Create new file section for the joined data
            createJoinedTableSection(joinedData, leftFileName, rightFileName, joinType);
            
            // Close modal
            joinModal.style.display = 'none';
            
            showStatus(`Successfully joined tables: ${joinedData.rows.length} rows created`, 'success');
        } catch (error) {
            console.error('Error applying join:', error);
            showStatus(`Error: ${error.message}`, 'error');
        }
    });
    
    function createJoinedTableSection(joinedData, leftFileName, rightFileName, joinType) {
        // Create a new file section using the template
        const fileDataSectionFragment = fileDataSectionTemplate.content.cloneNode(true);
        const fileDataSection = fileDataSectionFragment.querySelector('.file-data-section');
        
        // Set file name for the joined table
        const joinTypeName = {
            'inner': 'Inner Join',
            'left': 'Left Join',
            'right': 'Right Join',
            'full': 'Full Outer Join'
        }[joinType] || 'Join';
        
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        fileDataSection.fileName = `Join_${leftFileName}_with_${rightFileName}_${timestamp}.xlsx`;
        
        // Set title
        const fileTitle = fileDataSection.querySelector('.file-title');
        fileTitle.textContent = `Data from: Join of ${leftFileName} and ${rightFileName}`;
        
        // Add delete button event
        const deleteBtn = fileDataSection.querySelector('.delete-section-btn');
        deleteBtn.addEventListener('click', () => deleteFileSection(fileDataSection));
        
        // Create a workbook for the joined data
        // Convert joined data to 2D array format for XLSX
        const worksheetData = [joinedData.headers, ...joinedData.rows];
        const worksheet = XLSX.utils.aoa_to_sheet(worksheetData);
        const workbook = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(workbook, worksheet, "Joined Data");
        
        // Store in section
        fileDataSection.workbook = workbook;

        // --- NEW: Analyze the joined data to populate dateTimeInfo ---
        // Create a temporary File object from the workbook to use with detectDateTimeFormats
        const wbout = XLSX.write(workbook, { bookType: 'xlsx', type: 'array', cellDates: true });
        const blob = new Blob([wbout], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
        const tempFile = new File([blob], fileDataSection.fileName, { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });

        // Detect date/time formats for the newly created joined data
        detectDateTimeFormats(tempFile)
            .then(dateTimeInfo => {
                fileDataSection.dateTimeInfo = dateTimeInfo;
                console.log(`Date/Time Info detected for joined table:`, dateTimeInfo);
                // Optionally, you could trigger a stats panel refresh here if it's already open
            })
            .catch(err => {
                console.error('Failed to detect date/time formats for joined table:', err);
                fileDataSection.dateTimeInfo = {}; // Fallback to empty
            });
        // --- END NEW ---
        // Initialize hidden and sorting state
        if (!hidden[fileDataSection.fileName]) hidden[fileDataSection.fileName] = {};
        if (!sortingState[fileDataSection.fileName]) sortingState[fileDataSection.fileName] = {};
        
        // Create sheet tab (only one sheet for joined data)
        const sheetTabsContainer = fileDataSection.querySelector('.sheet-tabs');
        const sheetTab = document.createElement('div');
        sheetTab.className = 'sheet-tab active';
        sheetTab.textContent = 'Joined Data';
        sheetTabsContainer.appendChild(sheetTab);
        
        // Get table elements
        const table = fileDataSection.querySelector('table');
        const tableHeader = table.querySelector('thead');
        const tableBody = table.querySelector('tbody');
        const columnControls = fileDataSection.querySelector('.column-controls');
        const noDataMessage = fileDataSection.querySelector('.no-data');
        
        // Hide no data message
        noDataMessage.style.display = 'none';
        table.style.display = 'table';
        columnControls.style.display = 'flex';
        
        // Render the table
        renderTableHeader(joinedData.headers, tableHeader, fileDataSection, fileDataSection.fileName, 'Joined Data');
        renderTableBody(joinedData.headers, [joinedData.headers, ...joinedData.rows], worksheet, tableBody);
        initializeColumnControls(joinedData.headers, columnControls, fileDataSection.fileName, 'Joined Data', tableHeader, tableBody);
        
        // Setup other features
        setupPaginationAndStats(fileDataSection, tableBody);
        setupAdvancedSearch(fileDataSection, joinedData.headers);
        setupCharting(fileDataSection);
        setupStatsPanel(fileDataSection, joinedData.headers, tableBody);
        setupPivotAnalyzer(fileDataSection, joinedData.headers, tableBody);
        addExportControls(fileDataSection);
        addFormulaColumnControls(fileDataSection);
        addFormattingControls(fileDataSection);
        addDateTimeFormattingControls(fileDataSection);
        
        
        // Add to DOM
        dataSectionContainer.appendChild(fileDataSection);
        
        // Store the joined data for future reference
        fileDataSection.joinedDataInfo = {
            leftFileName,
            rightFileName,
            joinType,
            joinConditions: joinConditions,
            createdAt: new Date().toISOString()
        };
    }
    
    // Add click event outside modal to close it
    joinModal.addEventListener('click', (e) => {
        if (e.target === joinModal) {
            joinModal.style.display = 'none';
        }
    });
    
    // Return the join function for use elsewhere if needed
    return {
        showJoinModal: () => {
            populateTableSelects();
            joinModal.style.display = 'flex';
        }
    };
}


// === NEW: Add Formula Column Functionality ===
/**
 * Adds a formula column button and modal interface to a file data section.
 * This allows users to create new columns based on formulas with nested IF statements and math operations.
 * @param {HTMLElement} fileDataSection - The container for the file's data.
 */
function addFormulaColumnControls(fileDataSection) {
    const sheetData = fileDataSection.querySelector('.sheet-data');
    
    // Create formula button
    const formulaBtn = document.createElement('button');
    formulaBtn.className = 'formula-btn';
    formulaBtn.textContent = 'ðŸ§® Add Formula Column';
    formulaBtn.style.cssText = `
        background: rgba(139, 92, 246, 0.3);
        color: white;
        border: 1px solid rgba(255, 255, 255, 0.3);
        padding: 8px 16px;
        border-radius: 5px;
        cursor: pointer;
        margin-bottom: 10px;
        margin-left: 10px; /* Add some space from other buttons */
        font-size: 0.9rem;
    `;
    
    // Create modal container
    const modal = document.createElement('div');
    modal.className = 'formula-modal';
    modal.style.cssText = `
        display: none;
        position: fixed;
        z-index: 1002;
        left: 0; top: 0;
        width: 100%; height: 100%;
        background-color: rgba(0,0,0,0.5);
        justify-content: center;
        align-items: center;
    `;
    
    // Modal content
    const modalContent = document.createElement('div');
    modalContent.style.cssText = `
        background-color: #2d2d2d;
        margin: auto;
        padding: 20px;
        border: 1px solid rgba(255,255,255,0.1);
        border-radius: 8px;
        width: 90%;
        max-width: 800px;
        max-height: 90vh;
        overflow-y: auto;
        color: white;
    `;
    modal.appendChild(modalContent);
    
    // Modal header
    const modalHeader = document.createElement('div');
    modalHeader.style.cssText = `display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;`;
    const modalTitle = document.createElement('h3');
    modalTitle.textContent = 'Add Formula Column';
    modalTitle.style.margin = '0';
    const closeBtn = document.createElement('span');
    closeBtn.innerHTML = '&times;';
    closeBtn.style.cssText = `font-size: 24px; cursor: pointer;`;
    modalHeader.appendChild(modalTitle);
    modalHeader.appendChild(closeBtn);
    modalContent.appendChild(modalHeader);
    
    // Formula input section
    const formulaInputDiv = document.createElement('div');
    formulaInputDiv.style.marginBottom = '15px';
    formulaInputDiv.innerHTML = `
        <div style="margin-bottom: 10px;">
            <label style="display: block; margin-bottom: 5px;">New Column Name:</label>
            <input type="text" class="formula-column-name" placeholder="e.g., Total Sales, Discounted Price" 
                   style="width: 100%; padding: 8px; border-radius: 4px; 
                          background-color: rgba(255, 255, 255, 0.1); color: white; border: 1px solid rgba(255, 255, 255, 0.3);">
        </div>
        
        <div style="margin-bottom: 10px;">
            <label style="display: block; margin-bottom: 5px;">Formula:</label>
            <textarea class="formula-input" placeholder="Enter formula using column names, operators, and functions. Examples:
- Simple math: [Price] * [Quantity]
- Nested IF: IF([Score] >= 90, \"A\", IF([Score] >= 80, \"B\", IF([Score] >= 70, \"C\", \"F\")))
- Math with functions: SUM([Sales1], [Sales2]) * 0.9
- Conditional math: IF([Status] = \"Active\", [Salary] * 1.1, [Salary])
- Complex: IF([Region] = \"North\", [Revenue] * 1.1, IF([Region] = \"South\", [Revenue] * 0.9, [Revenue]))"
                  style="width: 100%; height: 150px; padding: 8px; border-radius: 4px; 
                         background-color: rgba(255, 255, 255, 0.1); color: white; border: 1px solid rgba(255, 255, 255, 0.3); 
                         font-family: 'Courier New', Courier, monospace; margin-top: 5px;"></textarea>
        </div>
        
        <div style="margin-bottom: 10px;">
            <label style="display: block; margin-bottom: 5px;">Apply to:</label>
            <select class="formula-apply-to" style="width: 100%; padding: 8px; border-radius: 4px; 
                                                   background-color: rgba(255, 255, 255, 0.1); color: white; border: 1px solid rgba(255, 255, 255, 0.3);">
                <option value="all">All Rows</option>
                <option value="visible">Visible Rows Only</option> 
            </select>
        </div>
        
        <div style="margin-bottom: 10px;">
            <label style="display: block; margin-bottom: 5px;">Column Position:</label>
            <select class="formula-position" style="width: 100%; padding: 8px; border-radius: 4px; 
                                                    background-color: rgba(255, 255, 255, 0.1); color: white; border: 1px solid rgba(255, 255, 255, 0.3);">
                <option value="end">Add at End</option>
            
            </select>
            
            <div class="position-select-container" style="margin-top: 10px; display: none;">
                <label style="display: block; margin-bottom: 5px;">After which column?</label>
                <select class="after-column-select" style="width: 100%; padding: 8px; border-radius: 4px; 
                                                           background-color: rgba(255, 255, 255, 0.1); color: white; border: 1px solid rgba(255, 255, 255, 0.3);">
                    <option value="">Select a column</option>
                </select>
            </div>
        </div>
        
        <div style="margin-bottom: 10px;">
            <label style="display: block; margin-bottom: 5px;">Formula Help:</label>
            <div style="background: rgba(0, 0, 0, 0.2); padding: 10px; border-radius: 5px; font-size: 0.9rem;">
                <p><strong>Supported Functions:</strong></p>
                <ul style="margin: 5px 0; padding-left: 20px;">
                    <li><code>IF(condition, value_if_true, value_if_false)</code> - Nested IF statements supported</li>
                    <li><code>SUM(a, b, c, ...)</code> - Sum multiple values</li>
                    <li><code>AVERAGE(a, b, c, ...)</code> - Average of multiple values</li>
                    <li><code>MAX(a, b, c, ...)</code> - Maximum value</li>
                    <li><code>MIN(a, b, c, ...)</code> - Minimum value</li>
                    <li><code>ABS(value)</code> - Absolute value</li>
                    <li><code>ROUND(value, decimals)</code> - Round to specified decimals</li>
                    <li><code>LEN(text)</code> - Length of text string</li>
                    <li><code>UPPER(text)</code> - Convert to uppercase</li>
                    <li><code>LOWER(text)</code> - Convert to lowercase</li>
                    <li><code>TRIM(text)</code> - Remove extra whitespace</li>
                    <li><code>CONCAT(a, b, c, ...)</code> - Concatenate strings</li>
                    <li><code>CONTAINS(text, substring)</code> - Check if text contains substring</li>
                </ul>
                <p><strong>Column References:</strong> Use square brackets around column names, e.g., <code>[Price]</code></p>
                <p><strong>Operators:</strong> +, -, *, /, %, ^ (power), ==, !=, >, <, >=, <=</p>
                <p><strong>Logical Operators:</strong> AND, OR, NOT</p>
                <p><strong>Examples:</strong></p>
                <ul style="margin: 5px 0; padding-left: 20px;">
                    <li><code>IF([Sales] > 1000, [Sales] * 0.1, 0)</code> - Commission calculation</li>
                    <li><code>SUM([Q1], [Q2], [Q3], [Q4])</code> - Annual total</li>
                    <li><code>IF([Age] >= 65, \"Senior\", IF([Age] >= 18, \"Adult\", \"Minor\"))</code> - Age category</li>
                    <li><code>ROUND(AVERAGE([Test1], [Test2], [Test3]), 2)</code> - Rounded average</li>
                    <li><code>CONCAT([FirstName], \" \", [LastName])</code> - Full name</li>
                </ul>
            </div>
        </div>
    `;
    modalContent.appendChild(formulaInputDiv);
    
    // Preview section
    const previewDiv = document.createElement('div');
    previewDiv.style.marginBottom = '15px';
    previewDiv.innerHTML = `
        <div style="margin-bottom: 10px;">
            <h4>Preview</h4>
            <div class="preview-table-container" style="max-height: 200px; overflow-y: auto; margin-top: 10px;">
                <table class="preview-table" style="width: 100%; border-collapse: collapse; background: rgba(0, 0, 0, 0.3);">
                    <thead>
                        <tr>
                            <th style="padding: 8px; text-align: left; border-bottom: 1px solid rgba(255, 255, 255, 0.3);">Preview will appear here after entering formula</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td style="padding: 8px; text-align: left; font-style: italic;">Enter a formula to see preview</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
    `;
    modalContent.appendChild(previewDiv);
    
    // Apply and cancel buttons
    const buttonContainer = document.createElement('div');
    buttonContainer.style.display = 'flex';
    buttonContainer.style.gap = '10px';
    buttonContainer.style.justifyContent = 'flex-end';
    buttonContainer.style.marginTop = '20px';
    
    const cancelBtn = document.createElement('button');
    cancelBtn.textContent = 'Cancel';
    cancelBtn.style.cssText = `
        background: rgba(255, 0, 0, 0.3);
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 4px;
        cursor: pointer;
    `;
    
    const applyBtn = document.createElement('button');
    applyBtn.textContent = 'Apply Formula';
    applyBtn.style.cssText = `
        background: linear-gradient(to right, #4facfe, #00f2fe);
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 4px;
        cursor: pointer;
    `;
    
    buttonContainer.appendChild(cancelBtn);
    buttonContainer.appendChild(applyBtn);
    modalContent.appendChild(buttonContainer);
    
    // Add elements to DOM
    const formatBtn = fileDataSection.querySelector('.format-btn');
    if (formatBtn && formatBtn.parentNode) {
        formatBtn.parentNode.insertBefore(formulaBtn, formatBtn.nextSibling);
    } else {
        const cleanBtn = fileDataSection.querySelector('.clean-btn');
        if (cleanBtn && cleanBtn.parentNode) {
            cleanBtn.parentNode.insertBefore(formulaBtn, cleanBtn.nextSibling);
        } else {
            sheetData.parentNode.insertBefore(formulaBtn, sheetData);
        }
    }
    document.body.appendChild(modal);
    
    // Event listeners
    formulaBtn.addEventListener('click', () => {
        populateColumnSelects();
        modal.style.display = 'flex';
        // Clear any previous preview
        const previewTableBody = modal.querySelector('.preview-table tbody');
        previewTableBody.innerHTML = '<tr><td style="padding: 8px; text-align: left; font-style: italic;">Enter a formula to see preview</td></tr>';
    });
    
    closeBtn.addEventListener('click', () => {
        modal.style.display = 'none';
    });
    
    cancelBtn.addEventListener('click', () => {
        modal.style.display = 'none';
    });
    
    // Show/hide after-column select based on position selection
    const positionSelect = modal.querySelector('.formula-position');
    const positionSelectContainer = modal.querySelector('.position-select-container');
    positionSelect.addEventListener('change', () => {
        if (positionSelect.value === 'after-selected') {
            positionSelectContainer.style.display = 'block';
            populateAfterColumnSelect();
        } else {
            positionSelectContainer.style.display = 'none';
        }
    });
    
    // Update preview when formula changes
    const formulaInput = modal.querySelector('.formula-input');
    const columnNameInput = modal.querySelector('.formula-column-name');
    formulaInput.addEventListener('input', updatePreview);
    columnNameInput.addEventListener('input', updatePreview);
    positionSelect.addEventListener('change', updatePreview);
    modal.querySelector('.formula-apply-to').addEventListener('change', updatePreview);
    
    // Update preview when column selections change
    function updatePreview() {
        const formula = formulaInput.value.trim();
        const columnName = columnNameInput.value.trim();
        const applyTo = modal.querySelector('.formula-apply-to').value;
        
        if (!formula || !columnName) {
            const previewTableBody = modal.querySelector('.preview-table tbody');
            previewTableBody.innerHTML = '<tr><td style="padding: 8px; text-align: left; font-style: italic;">Enter a formula and column name to see preview</td></tr>';
            return;
        }
        
        // Get active sheet data
        const activeTab = fileDataSection.querySelector('.sheet-tab.active');
        if (!activeTab) {
            const previewTableBody = modal.querySelector('.preview-table tbody');
            previewTableBody.innerHTML = '<tr><td style="padding: 8px; text-align: left; font-style: italic;">No active sheet</td></tr>';
            return;
        }
        
        const sheetName = activeTab.textContent;
        const headers = getHeadersFromActiveSheet(fileDataSection);
        if (!headers || headers.length === 0) {
            const previewTableBody = modal.querySelector('.preview-table tbody');
            previewTableBody.innerHTML = '<tr><td style="padding: 8px; text-align: left; font-style: italic;">No column headers found</td></tr>';
            return;
        }
        
        // Parse formula to extract referenced columns
        const referencedColumns = extractReferencedColumns(formula, headers);
        
        // If no valid columns referenced, show error
        if (referencedColumns.length === 0) {
            const previewTableBody = modal.querySelector('.preview-table tbody');
            previewTableBody.innerHTML = '<tr><td style="padding: 8px; text-align: left; font-style: italic;">No valid column references found in formula</td></tr>';
            return;
        }
        
        // Get current table data
        const tableBody = fileDataSection.querySelector('tbody');
        const allRows = Array.from(tableBody.querySelectorAll('tr'));
        
        // Filter rows based on applyTo setting
        let rowsToProcess;
        if (applyTo === 'visible') {
            rowsToProcess = allRows.filter(row => row.style.display !== 'none');
        } else {
            rowsToProcess = allRows;
        }
        
        // Limit preview to first 5 rows
        const previewRows = rowsToProcess.slice(0, 5);
        
        // Create preview table
        const previewTableBody = modal.querySelector('.preview-table tbody');
        previewTableBody.innerHTML = '';
        
        // Create header row for preview
        const previewHeaderRow = document.createElement('tr');
        headers.forEach(header => {
            const th = document.createElement('th');
            th.textContent = header;
            th.style.cssText = 'padding: 8px; text-align: left; border-bottom: 1px solid rgba(255, 255, 255, 0.3); font-size: 0.8rem;';
            previewHeaderRow.appendChild(th);
        });
        
        // Add formula column header
        const formulaHeaderTh = document.createElement('th');
        formulaHeaderTh.textContent = columnName;
        formulaHeaderTh.style.cssText = 'padding: 8px; text-align: left; border-bottom: 1px solid rgba(255, 255, 255, 0.3); font-size: 0.8rem; font-weight: bold;';
        previewHeaderRow.appendChild(formulaHeaderTh);
        previewTableBody.appendChild(previewHeaderRow);
        
        // Process each row
        previewRows.forEach(row => {
            const cells = Array.from(row.querySelectorAll('td'));
            const rowData = cells.map(cell => cell.textContent.trim());
            
            // Calculate formula result for this row
            const result = evaluateFormula(formula, rowData, headers);
            
            // Create row for preview
            const previewRow = document.createElement('tr');
            
            // Add existing cells
            cells.forEach(cell => {
                const td = document.createElement('td');
                td.textContent = cell.textContent.trim();
                td.style.cssText = 'padding: 8px; text-align: left; font-size: 0.8rem;';
                previewRow.appendChild(td);
            });
            
            // Add formula result
            const resultTd = document.createElement('td');
            resultTd.textContent = result !== undefined ? String(result) : '';
            resultTd.style.cssText = 'padding: 8px; text-align: left; font-size: 0.8rem; font-weight: bold; color: #4facfe;';
            previewRow.appendChild(resultTd);
            
            previewTableBody.appendChild(previewRow);
        });
        
        // Add message if there are more rows
        if (rowsToProcess.length > 5) {
            const moreRowsRow = document.createElement('tr');
            const moreRowsCell = document.createElement('td');
            moreRowsCell.colSpan = headers.length + 1;
            moreRowsCell.textContent = `... and ${rowsToProcess.length - 5} more rows`;
            moreRowsCell.style.cssText = 'padding: 8px; text-align: center; font-style: italic; background: rgba(255, 255, 255, 0.1);';
            moreRowsRow.appendChild(moreRowsCell);
            previewTableBody.appendChild(moreRowsRow);
        }
    }
    
    // Populate column selects for reference
    function populateColumnSelects() {
        const afterColumnSelect = modal.querySelector('.after-column-select');
        afterColumnSelect.innerHTML = '<option value="">Select a column</option>';
        
        const headers = getHeadersFromActiveSheet(fileDataSection);
        if (headers) {
            headers.forEach((header, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = header;
                afterColumnSelect.appendChild(option);
            });
        }
    }
    
    function populateAfterColumnSelect() {
        const afterColumnSelect = modal.querySelector('.after-column-select');
        afterColumnSelect.innerHTML = '<option value="">Select a column</option>';
        
        const headers = getHeadersFromActiveSheet(fileDataSection);
        if (headers) {
            headers.forEach((header, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = header;
                afterColumnSelect.appendChild(option);
            });
        }
    }
    
    // Extract column references from formula
    function extractReferencedColumns(formula, headers) {
        const referencedColumns = [];
        const columnRegex = /\[([^\]]+)\]/g;
        let match;
        
        while ((match = columnRegex.exec(formula)) !== null) {
            const colName = match[1];
            // Check if this column exists in headers
            if (headers.includes(colName) && !referencedColumns.includes(colName)) {
                referencedColumns.push(colName);
            }
        }
        
        return referencedColumns;
    }
    
    // --- REPLACE THE ENTIRE evaluateFormula FUNCTION WITH THIS FIXED VERSION ---

function evaluateFormula(formula, rowData, headers) {
    try {
        // Replace column references with actual values
        let processedFormula = formula;
        headers.forEach((header, index) => {
            const escapedHeader = header.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            const regex = new RegExp(`\\[${escapedHeader}\\]`, 'g');
            const value = rowData[index] !== undefined ? rowData[index] : '';
            let numericValue = parseFormattedNumber(value);
            if (numericValue !== null) {
                processedFormula = processedFormula.replace(regex, numericValue);
            } else {
                processedFormula = processedFormula.replace(regex, `"${value}"`);
            }
        });

        // Replace functions with JavaScript equivalents (same as before)
        processedFormula = processedFormula.replace(/\bSUM\(([^)]+)\)/g, (match, args) => {
            const argList = args.split(',').map(arg => arg.trim());
            let sum = 0;
            argList.forEach(arg => {
                const val = parseFloat(arg);
                if (!isNaN(val)) sum += val;
            });
            return sum.toString();
        });
        processedFormula = processedFormula.replace(/\bAVERAGE\(([^)]+)\)/g, (match, args) => {
            const argList = args.split(',').map(arg => arg.trim());
            let sum = 0;
            let count = 0;
            argList.forEach(arg => {
                const val = parseFloat(arg);
                if (!isNaN(val)) {
                    sum += val;
                    count++;
                }
            });
            return (count > 0 ? sum / count : 0).toString();
        });
        processedFormula = processedFormula.replace(/\bMAX\(([^)]+)\)/g, (match, args) => {
            const argList = args.split(',').map(arg => arg.trim());
            let maxVal = -Infinity;
            argList.forEach(arg => {
                const val = parseFloat(arg);
                if (!isNaN(val) && val > maxVal) maxVal = val;
            });
            return (maxVal === -Infinity ? 0 : maxVal).toString();
        });
        processedFormula = processedFormula.replace(/\bMIN\(([^)]+)\)/g, (match, args) => {
            const argList = args.split(',').map(arg => arg.trim());
            let minVal = Infinity;
            argList.forEach(arg => {
                const val = parseFloat(arg);
                if (!isNaN(val) && val < minVal) minVal = val;
            });
            return (minVal === Infinity ? 0 : minVal).toString();
        });
        processedFormula = processedFormula.replace(/\bABS\(([^)]+)\)/g, (match, arg) => {
            const val = parseFloat(arg.trim());
            return (isNaN(val) ? 0 : Math.abs(val)).toString();
        });
        processedFormula = processedFormula.replace(/\bROUND\(([^,]+),\s*([^)]+)\)/g, (match, arg1, arg2) => {
            const val = parseFloat(arg1.trim());
            const decimals = parseInt(arg2.trim());
            if (isNaN(val) || isNaN(decimals)) return "0";
            return (Math.round(val * Math.pow(10, decimals)) / Math.pow(10, decimals)).toString();
        });
        processedFormula = processedFormula.replace(/\bLEN\(([^)]+)\)/g, (match, arg) => {
            let text = arg.trim();
            if (text.startsWith('"') && text.endsWith('"')) {
                text = text.substring(1, text.length - 1);
            }
            return text.length.toString();
        });
        processedFormula = processedFormula.replace(/\bUPPER\(([^)]+)\)/g, (match, arg) => {
            let text = arg.trim();
            if (text.startsWith('"') && text.endsWith('"')) {
                text = text.substring(1, text.length - 1);
            }
            return `"${text.toUpperCase()}"`;
        });
        processedFormula = processedFormula.replace(/\bLOWER\(([^)]+)\)/g, (match, arg) => {
            let text = arg.trim();
            if (text.startsWith('"') && text.endsWith('"')) {
                text = text.substring(1, text.length - 1);
            }
            return `"${text.toLowerCase()}"`;
        });
        processedFormula = processedFormula.replace(/\bTRIM\(([^)]+)\)/g, (match, arg) => {
            let text = arg.trim();
            if (text.startsWith('"') && text.endsWith('"')) {
                text = text.substring(1, text.length - 1);
            }
            return `"${text.trim()}"`;
        });
        processedFormula = processedFormula.replace(/\bCONCAT\(([^)]+)\)/g, (match, args) => {
            const argList = args.split(',').map(arg => arg.trim());
            let result = "";
            argList.forEach(arg => {
                let text = arg;
                if (text.startsWith('"') && text.endsWith('"')) {
                    text = text.substring(1, text.length - 1);
                }
                result += text;
            });
            return `"${result}"`;
        });
        processedFormula = processedFormula.replace(/\bCONTAINS\(([^,]+),\s*([^)]+)\)/g, (match, arg1, arg2) => {
            let text = arg1.trim();
            let substring = arg2.trim();
            if (text.startsWith('"') && text.endsWith('"')) {
                text = text.substring(1, text.length - 1);
            }
            if (substring.startsWith('"') && substring.endsWith('"')) {
                substring = substring.substring(1, substring.length - 1);
            }
            return (text.includes(substring) ? "true" : "false");
        });

        // Handle logical operators
        processedFormula = processedFormula.replace(/==/g, '===');
        processedFormula = processedFormula.replace(/!=/g, '!==');
        processedFormula = processedFormula.replace(/\^/g, '**');
        processedFormula = processedFormula.replace(/\bAND\b/g, '&&');
        processedFormula = processedFormula.replace(/\bOR\b/g, '||');
        processedFormula = processedFormula.replace(/\bNOT\b/g, '!');

        // --- FIXED: Recursive IF Parser ---
        // This function parses an IF expression recursively
        function parseIFExpression(expr) {
            // Strip leading/trailing whitespace
            expr = expr.trim();

            // Base case: If no IF, return the expression as-is
            if (!expr.startsWith('IF(')) {
                return expr;
            }

            // Find the matching closing parenthesis for the outermost IF
            let depth = 0;
            let i = 0;
            let startParen = -1;

            // Find the opening parenthesis after 'IF'
            for (i = 0; i < expr.length; i++) {
                if (expr[i] === '(') {
                    depth++;
                    if (depth === 1) {
                        startParen = i;
                        break;
                    }
                }
            }

            if (startParen === -1) {
                throw new Error("Invalid IF syntax: Missing opening parenthesis");
            }

            // Find the matching closing parenthesis for the entire IF
            depth = 1;
            let endParen = -1;
            for (i = startParen + 1; i < expr.length; i++) {
                if (expr[i] === '(') {
                    depth++;
                } else if (expr[i] === ')') {
                    depth--;
                    if (depth === 0) {
                        endParen = i;
                        break;
                    }
                }
            }

            if (endParen === -1) {
                throw new Error("Invalid IF syntax: Missing closing parenthesis");
            }

            // Extract the content inside the IF(...), excluding the outermost parentheses
            const innerContent = expr.substring(startParen + 1, endParen);

            // Split the inner content into three parts by top-level commas
            // We need to split on commas that are NOT inside nested parentheses
            let parts = [];
            let currentPart = '';
            let partDepth = 0;

            for (i = 0; i < innerContent.length; i++) {
                const char = innerContent[i];
                if (char === '(') {
                    partDepth++;
                    currentPart += char;
                } else if (char === ')') {
                    partDepth--;
                    currentPart += char;
                } else if (char === ',' && partDepth === 0) {
                    // Top-level comma, split here
                    parts.push(currentPart.trim());
                    currentPart = '';
                } else {
                    currentPart += char;
                }
            }
            // Add the last part
            parts.push(currentPart.trim());

            // Must have exactly 3 parts: condition, trueValue, falseValue
            if (parts.length !== 3) {
                throw new Error("Invalid IF syntax: Must have exactly 3 arguments (condition, trueValue, falseValue)");
            }

            const [conditionStr, trueValueStr, falseValueStr] = parts;

            // Evaluate the condition
            let conditionResult;
            try {
                // Evaluate the condition expression recursively
                const safeCondition = sanitizeExpression(conditionStr);
                conditionResult = eval(safeCondition);
            } catch (e) {
                throw new Error(`Error evaluating condition: ${e.message}`);
            }

            // Recursively evaluate the chosen branch
            if (conditionResult) {
                return parseIFExpression(trueValueStr); // Recurse into true branch
            } else {
                return parseIFExpression(falseValueStr); // Recurse into false branch
            }
        }

        // Now apply the recursive IF parser to the entire processed formula
        // We need to find the outermost IF and replace it recursively
        let finalResult = processedFormula;

        // Keep parsing until there are no more IF expressions left to process
        // or we've done enough iterations to prevent infinite loops
        let iteration = 0;
        const maxIterations = 100;
        
        while (finalResult.includes('IF(') && iteration < maxIterations) {
            iteration++;
            
            // Look for the first occurrence of 'IF('
            const ifIndex = finalResult.indexOf('IF(');
            if (ifIndex === -1) break;

            // We found an IF, now parse it using our recursive function
            // We'll extract the entire IF expression from this point
            let depth = 0;
            let start = -1;
            let end = -1;

            // Find the matching closing parenthesis for this IF
            for (let i = ifIndex; i < finalResult.length; i++) {
                if (finalResult[i] === '(') {
                    if (depth === 0) start = i;
                    depth++;
                } else if (finalResult[i] === ')') {
                    depth--;
                    if (depth === 0) {
                        end = i;
                        break;
                    }
                }
            }

            if (start === -1 || end === -1) {
                throw new Error("Invalid IF syntax: Could not find matching parentheses");
            }

            // Extract the entire IF expression including 'IF(' and its closing ')'
            const fullIfExpr = finalResult.substring(ifIndex, end + 1);

            // Parse it recursively
            const parsedResult = parseIFExpression(fullIfExpr);

            // Replace the entire IF expression with its evaluated result
            finalResult = finalResult.substring(0, ifIndex) + parsedResult + finalResult.substring(end + 1);
        }

        if (iteration >= maxIterations) {
            throw new Error("Too many nested IF expressions. Possible infinite recursion.");
        }

        // Final sanitization and evaluation
        const safeFinal = sanitizeExpression(finalResult);
        
        // If the result is a string literal, return it without quotes
        if (safeFinal.startsWith('"') && safeFinal.endsWith('"')) {
            return safeFinal.substring(1, safeFinal.length - 1);
        }
        
        // Otherwise evaluate as a mathematical expression
        const result = eval(safeFinal);
        
        // Handle boolean results
        if (result === true) return "true";
        if (result === false) return "false";
        
        return result;

    } catch (error) {
        console.error("Formula evaluation error:", error);
        return "ERROR: " + error.message;
    }
}
    // Sanitize expression to prevent malicious code execution
    function sanitizeExpression(expression) {
        // Allow only alphanumeric characters, operators, parentheses, decimal points, and specific function syntax
        // This is a basic sanitization - in production, consider using a proper expression parser
        
        // Allow: numbers, letters, operators, parentheses, dots, commas, spaces, and specific function names
        const allowedPattern = /^[0-9+\-*/()., ]+|[a-zA-Z]+\s*\([^)]*\)|[a-zA-Z]+|"[^"]*"|'[^']*'|===|!==|>=|<=|&&|\|\||!|\*\*$/;
        
        // If the entire expression matches our allowed pattern, return it
        if (allowedPattern.test(expression.replace(/\s+/g, ''))) {
            return expression;
        }
        
        // Otherwise, return a safe default
        return "0";
    }
    
    // Helper function to get headers from active sheet
    function getHeadersFromActiveSheet(section) {
        const activeTab = section.querySelector('.sheet-tab.active');
        if (!activeTab) return null;
        
        const sheetName = activeTab.textContent;
        const tableHeader = section.querySelector('thead');
        if (!tableHeader) return null;
        
        // Get headers from DOM (most up-to-date)
        const headers = Array.from(tableHeader.querySelectorAll('th')).map(th => {
            return th.textContent.split('\n')[0].trim();
        });
        
        return headers;
    }
    
    // Apply formula button
    // Apply formula button
// --- REPLACE THE ENTIRE applyBtn EVENT LISTENER WITH THIS FIXED VERSION ---

applyBtn.addEventListener('click', () => {
    const formula = formulaInput.value.trim();
    const columnName = columnNameInput.value.trim();
    const applyTo = modal.querySelector('.formula-apply-to').value;
    const position = modal.querySelector('.formula-position').value;
    const afterColumnIndex = position === 'after-selected' ? 
        parseInt(modal.querySelector('.after-column-select').value) : -1;
    if (!formula || !columnName) {
        showStatus('Please enter both a formula and a column name', 'error');
        return;
    }
    // Validate formula structure
    if (formula.indexOf('[') !== -1 && formula.indexOf(']') === -1) {
        showStatus('Invalid formula: Unmatched opening bracket [', 'error');
        return;
    }
    if (formula.indexOf(']') !== -1 && formula.indexOf('[') === -1) {
        showStatus('Invalid formula: Unmatched closing bracket ]', 'error');
        return;
    }
    // Get active sheet
    const activeTab = fileDataSection.querySelector('.sheet-tab.active');
    if (!activeTab) {
        showStatus('No active sheet', 'error');
        return;
    }
    const sheetName = activeTab.textContent;
    const headers = getHeadersFromActiveSheet(fileDataSection);
    if (!headers || headers.length === 0) {
        showStatus('No column headers found', 'error');
        return;
    }
    // Check if column name already exists
    if (headers.includes(columnName)) {
        if (!confirm(`A column named "${columnName}" already exists. Overwrite it?`)) {
            return;
        }
    }
    // Get table data
    const tableBody = fileDataSection.querySelector('tbody');
    const allRows = Array.from(tableBody.querySelectorAll('tr'));
    
    // Determine which rows to process based on "Apply to" setting
    let rowsToProcess;
    if (applyTo === 'visible') {
        rowsToProcess = allRows.filter(row => row.style.display !== 'none');
    } else {
        rowsToProcess = allRows;
    }
    
    // Get current worksheet data
    const workbook = fileDataSection.workbook;
    if (!workbook || !workbook.Sheets[sheetName]) {
        showStatus('Workbook data not available', 'error');
        return;
    }
    
    // Get current data
    const currentWorksheet = workbook.Sheets[sheetName];
    const jsonData = XLSX.utils.sheet_to_json(currentWorksheet, { header: 1, defval: '' });
    if (jsonData.length === 0) {
        showStatus('No data to process', 'error');
        return;
    }
    
    // Ensure the first row (header row) has enough columns
    while (jsonData[0].length < headers.length) {
        jsonData[0].push('');
    }
    
    // Insert the new column name into the FIRST ROW (header row) at the specified position
    let insertIndex = headers.length; // Default: add at end
    if (position === 'after-selected' && afterColumnIndex >= 0 && afterColumnIndex < jsonData[0].length) {
        insertIndex = afterColumnIndex + 1;
    }
    // Insert new column name at specified position
    jsonData[0].splice(insertIndex, 0, columnName);
    
    // Process each row to calculate formula
    // We'll use the original jsonData array but only update specific rows
    for (let i = 1; i < jsonData.length; i++) {
        const row = jsonData[i];
        
        // Ensure row has enough columns
        while (row.length < headers.length) {
            row.push('');
        }
        
        // Only calculate formula for visible rows if "Visible Rows Only" is selected
        // Find the corresponding DOM row for this data row
        const correspondingDomRow = allRows[i - 1]; // Since jsonData[0] is header, data starts at index 1
        
        // If "Visible Rows Only" is selected and this row is hidden, skip it
        if (applyTo === 'visible' && correspondingDomRow && correspondingDomRow.style.display === 'none') {
            // Keep existing value (or empty) in the new column for hidden rows
            if (insertIndex < row.length) {
                row[insertIndex] = row[insertIndex] || ''; // Preserve existing value or set to empty
            } else {
                // Append if index is beyond current length
                while (row.length < insertIndex) {
                    row.push('');
                }
                row.push(''); // Add empty value for hidden row
            }
            continue; // Skip formula calculation for hidden rows
        }
        
        // Calculate formula result for this row
        const result = evaluateFormula(formula, row, headers);
        
        // Insert result at specified position
        if (insertIndex < row.length) {
            row[insertIndex] = result;
        } else {
            // Append if index is beyond current length
            while (row.length < insertIndex) {
                row.push('');
            }
            row.push(result);
        }
    }
    
    // Update the worksheet
    const updatedWorksheet = XLSX.utils.aoa_to_sheet(jsonData);
    
    // Preserve formatting and properties if possible
    Object.keys(currentWorksheet).forEach(key => {
        if (key !== '!ref' && key !== '!cols' && key !== '!rows') {
            updatedWorksheet[key] = currentWorksheet[key];
        }
    });
    
    // Update the workbook
    workbook.Sheets[sheetName] = updatedWorksheet;
    fileDataSection.workbook = workbook;
    
    // Re-render the table
    const newHeaders = [...headers];
    newHeaders.splice(insertIndex, 0, columnName);
    renderTableHeader(newHeaders, fileDataSection.querySelector('thead'), fileDataSection, fileDataSection.fileName, sheetName);
    renderTableBody(newHeaders, jsonData, updatedWorksheet, fileDataSection.querySelector('tbody'));
    
    // Reinitialize column controls
    initializeColumnControls(newHeaders, fileDataSection.querySelector('.column-controls'), fileDataSection.fileName, sheetName, fileDataSection.querySelector('thead'), fileDataSection.querySelector('tbody'));
    
    // Reapply filters, sorting, pagination, etc.
    reapplyFilters(fileDataSection, fileDataSection.fileName, sheetName, fileDataSection.querySelector('thead'), fileDataSection.querySelector('tbody'));
    setupPaginationAndStats(fileDataSection, fileDataSection.querySelector('tbody'));
    setupAdvancedSearch(fileDataSection, newHeaders);
    setupCharting(fileDataSection);
    setupStatsPanel(fileDataSection, newHeaders, fileDataSection.querySelector('tbody'));
    
    // Update pivot analyzer if it exists
    if (fileDataSection.querySelector('.toggle-pivot-btn')) {
        setupPivotAnalyzer(fileDataSection, newHeaders, fileDataSection.querySelector('tbody'));
    }
    
    // Show success message
    showStatus(`Formula column "${columnName}" added successfully!`, 'success');
    
    // Close modal
    modal.style.display = 'none';
});
    // Add click event outside modal to close it
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            modal.style.display = 'none';
        }
    });
}

/**
 * Date/Time Formatter Module
 * This module provides comprehensive date/time formatting capabilities
 * with options to overwrite existing columns or create new columns.
 */

function addDateTimeFormattingControls(fileDataSection) {
    const sheetData = fileDataSection.querySelector('.sheet-data');
    
    // Create date/time format button
    const dateTimeFormatBtn = document.createElement('button');
    dateTimeFormatBtn.className = 'datetime-format-btn';
    dateTimeFormatBtn.textContent = 'ðŸ•’ Format Date/Time';
    dateTimeFormatBtn.style.cssText = `
        background: rgba(255, 165, 0, 0.3);
        color: white;
        border: 1px solid rgba(255, 255, 255, 0.3);
        padding: 8px 16px;
        border-radius: 5px;
        cursor: pointer;
        margin-bottom: 10px;
        margin-left: 10px;
        font-size: 0.9rem;
    `;
    
    // Create modal container
    const modal = document.createElement('div');
    modal.className = 'datetime-format-modal';
    modal.style.cssText = `
        display: none;
        position: fixed;
        z-index: 1003;
        left: 0; top: 0;
        width: 100%; height: 100%;
        background-color: rgba(0,0,0,0.5);
        justify-content: center;
        align-items: center;
    `;
    
    // Modal content
    const modalContent = document.createElement('div');
    modalContent.style.cssText = `
        background-color: #2d2d2d;
        margin: auto;
        padding: 20px;
        border: 1px solid rgba(255,255,255,0.1);
        border-radius: 8px;
        width: 90%;
        max-width: 800px;
        max-height: 90vh;
        overflow-y: auto;
        color: white;
    `;
    modal.appendChild(modalContent);
    
    // Modal header
    const modalHeader = document.createElement('div');
    modalHeader.style.cssText = `display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;`;
    const modalTitle = document.createElement('h3');
    modalTitle.textContent = 'Format Date/Time Column';
    modalTitle.style.margin = '0';
    const closeBtn = document.createElement('span');
    closeBtn.innerHTML = '&times;';
    closeBtn.style.cssText = `font-size: 24px; cursor: pointer;`;
    modalHeader.appendChild(modalTitle);
    modalHeader.appendChild(closeBtn);
    modalContent.appendChild(modalHeader);
    
    // Format configuration section
    const configDiv = document.createElement('div');
    configDiv.style.marginBottom = '15px';
    configDiv.innerHTML = `
        <div style="margin-bottom: 10px;">
            <label style="display: block; margin-bottom: 5px;">Select Column:</label>
            <select class="datetime-column-select" style="width: 100%; padding: 8px; border-radius: 4px; 
                   background-color: rgba(255, 255, 255, 0.1); color: white; border: 1px solid rgba(255, 255, 255, 0.3);">
                <option value="">Select a date/time column</option>
            </select>
        </div>
        
        <div style="margin-bottom: 10px;">
            <label style="display: block; margin-bottom: 5px;">Format Type:</label>
            <select class="datetime-format-type" style="width: 100%; padding: 8px; border-radius: 4px; 
                   background-color: rgba(255, 255, 255, 0.1); color: white; border: 1px solid rgba(255, 255, 255, 0.3);">
                <optgroup label="Date Formats">
                    <option value="full-date">Full Date (e.g., January 1, 2024)</option>
                    <option value="short-date">Short Date (e.g., 01/01/2024)</option>
                    <option value="month-year">Month & Year (e.g., January 2024)</option>
                    <option value="month-only">Month Only (e.g., January)</option>
                    <option value="year-only">Year Only (e.g., 2024)</option>
                    <option value="day-month">Day & Month (e.g., 1 January)</option>
                    <option value="day-of-week">Day of Week (e.g., Monday)</option>
                    <option value="day-of-week-date">Day of Week & Date (e.g., Monday, January 1)</option>
                    <option value="iso-date">ISO Date (e.g., 2024-01-01)</option>
                    <option value="custom-date">Custom Date Format</option>
                </optgroup>
                <optgroup label="Time Formats">
                    <option value="full-time">Full Time (e.g., 2:30:45 PM)</option>
                    <option value="short-time">Short Time (e.g., 2:30 PM)</option>
                    <option value="24hr-time">24-Hour Time (e.g., 14:30)</option>
                    <option value="hour-only">Hour Only (e.g., 2 PM)</option>
                    <option value="custom-time">Custom Time Format</option>
                </optgroup>
                <optgroup label="Date & Time">
                    <option value="datetime-full">Date & Time (e.g., January 1, 2024 2:30 PM)</option>
                    <option value="datetime-short">Short Date & Time (e.g., 01/01/2024 14:30)</option>
                    <option value="custom-datetime">Custom Date & Time Format</option>
                </optgroup>
            </select>
        </div>
        
        <div class="custom-format-container" style="margin-bottom: 10px; display: none;">
            <label style="display: block; margin-bottom: 5px;">Custom Format:</label>
            <input type="text" class="custom-format-input" placeholder="e.g., MM/DD/YYYY HH:mm" 
                   style="width: 100%; padding: 8px; border-radius: 4px; 
                          background-color: rgba(255, 255, 255, 0.1); color: white; border: 1px solid rgba(255, 255, 255, 0.3);">
            <div style="margin-top: 5px; font-size: 0.8rem; opacity: 0.8;">
                Format tokens: YYYY (4-digit year), YY (2-digit year), MM (month 01-12), M (month 1-12), 
                MMMM (full month name), MMM (short month name), DD (day 01-31), D (day 1-31), 
                dddd (full day name), ddd (short day name), HH (24hr 00-23), H (24hr 0-23), 
                hh (12hr 01-12), h (12hr 1-12), mm (minutes 00-59), ss (seconds 00-59), A (AM/PM)
            </div>
        </div>
        
         <div style="margin-bottom: 10px;">
            <label style="display: block; margin-bottom: 5px;">New Column Name:</label>
            <input type="text" class="new-column-name" placeholder="e.g., Formatted Date"
                   style="width: 100%; padding: 8px; border-radius: 4px;
                          background-color: rgba(255, 255, 255, 0.1); color: white; border: 1px solid rgba(255, 255, 255, 0.3);">
        </div>
        
        <div style="margin-bottom: 10px;">
            <label style="display: block; margin-bottom: 5px;">Apply to:</label>
            <select class="datetime-apply-to" style="width: 100%; padding: 8px; border-radius: 4px; 
                   background-color: rgba(255, 255, 255, 0.1); color: white; border: 1px solid rgba(255, 255, 255, 0.3);">
                <option value="all">All Rows</option>
                <option value="visible">Visible Rows Only</option>
            </select>
        </div>
        
        <div style="margin-bottom: 10px;">
            <label style="display: block; margin-bottom: 5px;">Preview:</label>
            <div class="preview-container" style="background: rgba(0, 0, 0, 0.2); padding: 10px; border-radius: 5px; min-height: 50px;">
                <div class="preview-content" style="font-family: monospace;">Select a column and format to see preview</div>
            </div>
        </div>
    `;
    modalContent.appendChild(configDiv);
    
    // Buttons
    const buttonContainer = document.createElement('div');
    buttonContainer.style.display = 'flex';
    buttonContainer.style.gap = '10px';
    buttonContainer.style.justifyContent = 'flex-end';
    buttonContainer.style.marginTop = '20px';
    
    const cancelBtn = document.createElement('button');
    cancelBtn.textContent = 'Cancel';
    cancelBtn.style.cssText = `
        background: rgba(255, 0, 0, 0.3);
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 4px;
        cursor: pointer;
    `;
    
    const applyBtn = document.createElement('button');
    applyBtn.textContent = 'Apply Format';
    applyBtn.style.cssText = `
        background: linear-gradient(to right, #4facfe, #00f2fe);
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 4px;
        cursor: pointer;
    `;
    
    buttonContainer.appendChild(cancelBtn);
    buttonContainer.appendChild(applyBtn);
    modalContent.appendChild(buttonContainer);
    
    // Add elements to DOM
    const formulaBtn = fileDataSection.querySelector('.formula-btn');
    if (formulaBtn && formulaBtn.parentNode) {
        formulaBtn.parentNode.insertBefore(dateTimeFormatBtn, formulaBtn.nextSibling);
    } else {
        const formatBtn = fileDataSection.querySelector('.format-btn');
        if (formatBtn && formatBtn.parentNode) {
            formatBtn.parentNode.insertBefore(dateTimeFormatBtn, formatBtn.nextSibling);
        } else {
            sheetData.parentNode.insertBefore(dateTimeFormatBtn, sheetData);
        }
    }
    document.body.appendChild(modal);
    
    // Event listeners
    dateTimeFormatBtn.addEventListener('click', () => {
        populateDateTimeColumnSelect();
        modal.style.display = 'flex';
    });
    
    closeBtn.addEventListener('click', () => {
        modal.style.display = 'none';
    });
    
    cancelBtn.addEventListener('click', () => {
        modal.style.display = 'none';
    });
    
    // Show custom format input when custom format is selected
    const formatTypeSelect = modal.querySelector('.datetime-format-type');
    const customFormatContainer = modal.querySelector('.custom-format-container');
    formatTypeSelect.addEventListener('change', () => {
        const isCustom = formatTypeSelect.value.includes('custom');
        customFormatContainer.style.display = isCustom ? 'block' : 'none';
        updatePreview();
    });
    
    
    
    // Update preview when inputs change
    const columnSelect = modal.querySelector('.datetime-column-select');
    const customFormatInput = modal.querySelector('.custom-format-input');
    const newColumnNameInput = modal.querySelector('.new-column-name');
    const applyToSelect = modal.querySelector('.datetime-apply-to');
    
    columnSelect.addEventListener('change', updatePreview);
    customFormatInput.addEventListener('input', updatePreview);
    newColumnNameInput.addEventListener('input', updatePreview);
    applyToSelect.addEventListener('change', updatePreview);
    
    // Apply formatting
    applyBtn.addEventListener('click', () => {
        applyDateTimeFormatting();
    });
    
    // Add click event outside modal to close it
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            modal.style.display = 'none';
        }
    });
    
    /**
     * Populate the column select with date/time columns
     */
    function populateDateTimeColumnSelect() {
        const columnSelect = modal.querySelector('.datetime-column-select');
        columnSelect.innerHTML = '<option value="">Select a date/time column</option>';
        
        const headers = getHeadersFromActiveSheet(fileDataSection);
        if (!headers) return;
        
        const activeTab = fileDataSection.querySelector('.sheet-tab.active');
        if (!activeTab) return;
        
        const sheetName = activeTab.textContent;
        const dateTimeInfo = fileDataSection.dateTimeInfo?.[sheetName];
        
        // Get date/time columns from detection or try to identify them
        let dateTimeColumns = [];
        if (dateTimeInfo && dateTimeInfo.dateColumns) {
            dateTimeColumns = dateTimeInfo.dateColumns.map(idx => ({ index: idx, name: headers[idx] }));
        } else {
            // Fallback: try to detect date/time columns by sampling data
            const tableBody = fileDataSection.querySelector('tbody');
            const rows = Array.from(tableBody.querySelectorAll('tr'));
            
            headers.forEach((header, index) => {
                // Sample first 10 rows to check if column contains date-like values
                const sampleValues = rows.slice(0, Math.min(10, rows.length))
                    .map(row => {
                        const cells = row.querySelectorAll('td');
                        return cells[index] ? cells[index].textContent.trim() : '';
                    })
                    .filter(val => val !== '');
                
                // Check if any value looks like a date
                const hasDateLikeValue = sampleValues.some(val => {
                    return isDateLikeString(val) || !isNaN(Date.parse(val));
                });
                
                if (hasDateLikeValue) {
                    dateTimeColumns.push({ index, name: header });
                }
            });
        }
        
        // Add options to select
        dateTimeColumns.forEach(col => {
            const option = document.createElement('option');
            option.value = col.index;
            option.textContent = `${col.name} (Column ${parseInt(col.index) + 1})`;
            option.dataset.columnName = col.name;
            columnSelect.appendChild(option);
        });
    }
    
    /**
     * Update the preview based on current selections
     */
    function updatePreview() {
        const columnSelect = modal.querySelector('.datetime-column-select');
        const formatTypeSelect = modal.querySelector('.datetime-format-type');
        const customFormatInput = modal.querySelector('.custom-format-input');
        const columnName = columnSelect.options[columnSelect.selectedIndex]?.dataset?.columnName || '';
        
        if (!columnSelect.value) {
            setPreviewText('Select a date/time column to see preview');
            return;
        }
        
        // Get sample data
        const columnIndex = parseInt(columnSelect.value);
        const tableBody = fileDataSection.querySelector('tbody');
        const rows = Array.from(tableBody.querySelectorAll('tr'));
        
        // Filter rows based on applyTo setting
        const applyTo = modal.querySelector('.datetime-apply-to').value;
        let sampleRows = applyTo === 'visible' ? 
            rows.filter(row => row.style.display !== 'none') : rows;
        
        // Take first 3 rows for preview
        sampleRows = sampleRows.slice(0, 3);
        
        // Generate preview content
        let previewContent = '';
        if (sampleRows.length === 0) {
            previewContent = 'No data available for preview';
        } else {
            previewContent = `<div style="margin-bottom: 10px;"><strong>Original â†’ Formatted</strong></div>`;
            sampleRows.forEach(row => {
                const cells = row.querySelectorAll('td');
                if (columnIndex < cells.length) {
                    const originalValue = cells[columnIndex].textContent.trim();
                    const formattedValue = formatDateTimeValue(originalValue, formatTypeSelect.value, customFormatInput.value);
                    previewContent += `<div>${originalValue} â†’ <strong>${formattedValue}</strong></div>`;
                }
            });
        }
        
        setPreviewText(previewContent);
    }
    
    /**
     * Set preview text content
     */
    function setPreviewText(content) {
        const previewContent = modal.querySelector('.preview-content');
        if (typeof content === 'string' && (content.startsWith('<') || content.includes('<'))) {
            previewContent.innerHTML = content;
        } else {
            previewContent.textContent = content;
        }
    }
    
    /**
     * Apply the date/time formatting to the selected column
     */
    function applyDateTimeFormatting() {
        const columnSelect = modal.querySelector('.datetime-column-select');
        const formatTypeSelect = modal.querySelector('.datetime-format-type');
        const customFormatInput = modal.querySelector('.custom-format-input');
        const newColumnNameInput = modal.querySelector('.new-column-name');
        const applyToSelect = modal.querySelector('.datetime-apply-to');
        // Validate inputs
        if (!columnSelect.value) {
            showStatus('Please select a column', 'error');
            return;
        }
        const columnIndex = parseInt(columnSelect.value);
        const formatType = formatTypeSelect.value;
        const customFormat = customFormatInput.value;
        const newColumnName = newColumnNameInput.value.trim();
        const applyTo = applyToSelect.value;
        if (!newColumnName) {
            showStatus('Please enter a name for the new column', 'error');
            return;
        }
        
        // Get active sheet info
        const activeTab = fileDataSection.querySelector('.sheet-tab.active');
        if (!activeTab) {
            showStatus('No active sheet', 'error');
            return;
        }
        
        const sheetName = activeTab.textContent;
        const headers = getHeadersFromActiveSheet(fileDataSection);
        if (!headers) {
            showStatus('No headers found', 'error');
            return;
        }
        
        // Get table data
        const tableBody = fileDataSection.querySelector('tbody');
        const allRows = Array.from(tableBody.querySelectorAll('tr'));
        
        // Determine which rows to process
        let rowsToProcess = applyTo === 'visible' ? 
            allRows.filter(row => row.style.display !== 'none') : allRows;
        
        // Get current worksheet data
        const workbook = fileDataSection.workbook;
        if (!workbook || !workbook.Sheets[sheetName]) {
            showStatus('Workbook data not available', 'error');
            return;
        }
        
        // Get current data
        const currentWorksheet = workbook.Sheets[sheetName];
        const jsonData = XLSX.utils.sheet_to_json(currentWorksheet, { header: 1, defval: '' });
        if (jsonData.length === 0) {
            showStatus('No data to process', 'error');
            return;
        }
        
                // Always create a new column at the end
        const targetColumnIndex = headers.length;
        const targetColumnName = newColumnName;
        // Add new column header
        jsonData[0].push(targetColumnName);
        // Ensure all data rows have the new column
        for (let i = 1; i < jsonData.length; i++) {
            jsonData[i].push('');
        }
        
        // Process each row
        for (let i = 1; i < jsonData.length; i++) {
            // Skip if processing only visible rows and this row is hidden
            if (applyTo === 'visible' && i <= allRows.length && allRows[i - 1].style.display === 'none') {
                continue;
            }
            
            // Get original value
            const originalValue = i < jsonData.length && columnIndex < jsonData[i].length ? 
                jsonData[i][columnIndex] : '';
            
            // Format the value
            const formattedValue = formatDateTimeValue(originalValue, formatType, customFormat);
            
            // Set the formatted value
            if (i < jsonData.length) {
                if (targetColumnIndex < jsonData[i].length) {
                    jsonData[i][targetColumnIndex] = formattedValue;
                } else {
                    // Pad with empty values if needed
                    while (jsonData[i].length < targetColumnIndex) {
                        jsonData[i].push('');
                    }
                    jsonData[i].push(formattedValue);
                }
            }
        }
        
        // Update the worksheet
        const updatedWorksheet = XLSX.utils.aoa_to_sheet(jsonData);
        
        // Preserve formatting and properties
        Object.keys(currentWorksheet).forEach(key => {
            if (key !== '!ref' && key !== '!cols' && key !== '!rows') {
                updatedWorksheet[key] = currentWorksheet[key];
            }
        });
        
        // Update the workbook
        workbook.Sheets[sheetName] = updatedWorksheet;
        fileDataSection.workbook = workbook;
        
                // Add the new column name to the headers array
        headers.push(targetColumnName);
        
        // Re-render the table
        renderTableHeader(headers, fileDataSection.querySelector('thead'), fileDataSection, fileDataSection.fileName, sheetName);
        renderTableBody(headers, jsonData, updatedWorksheet, fileDataSection.querySelector('tbody'));
        
        // Reinitialize column controls
        initializeColumnControls(headers, fileDataSection.querySelector('.column-controls'), fileDataSection.fileName, sheetName, fileDataSection.querySelector('thead'), fileDataSection.querySelector('tbody'));
        
        // Reapply filters, sorting, pagination, etc.
        reapplyFilters(fileDataSection, fileDataSection.fileName, sheetName, fileDataSection.querySelector('thead'), fileDataSection.querySelector('tbody'));
        setupPaginationAndStats(fileDataSection, fileDataSection.querySelector('tbody'));
        setupAdvancedSearch(fileDataSection, headers);
        setupCharting(fileDataSection);
        setupStatsPanel(fileDataSection, headers, fileDataSection.querySelector('tbody'));
        
        // Update pivot analyzer if it exists
        if (fileDataSection.querySelector('.toggle-pivot-btn')) {
            setupPivotAnalyzer(fileDataSection, headers, fileDataSection.querySelector('tbody'));
        }
        
        // Show success message
        const action = outputOption === 'new-column' ? 'created' : 'updated';
        showStatus(`Date/time column "${targetColumnName}" ${action} successfully!`, 'success');
        
        // Close modal
        modal.style.display = 'none';
    }
    
    /**
     * Helper function to get headers from active sheet
     */
    function getHeadersFromActiveSheet(section) {
        const activeTab = section.querySelector('.sheet-tab.active');
        if (!activeTab) return null;
        const sheetName = activeTab.textContent;
        const tableHeader = section.querySelector('thead');
        if (!tableHeader) return null;
        
        // Get headers from DOM
        const headers = Array.from(tableHeader.querySelectorAll('th')).map(th => {
            return th.textContent.split('\n')[0].trim();
        });
        return headers;
    }
    
    /**
     * Check if a string looks like a date
     */
    function isDateLikeString(str) {
        if (typeof str !== 'string' || !str.trim()) return false;
        
        // Common date patterns
        const datePatterns = [
            /^\d{4}-\d{1,2}-\d{1,2}$/, // YYYY-MM-DD
            /^\d{1,2}\/\d{1,2}\/\d{4}$/, // MM/DD/YYYY
            /^\d{1,2}-\d{1,2}-\d{4}$/, // MM-DD-YYYY
            /^\d{1,2}\.\d{1,2}\.\d{4}$/, // MM.DD.YYYY
            /^[A-Za-z]+\s+\d{1,2},?\s+\d{4}$/, // January 1, 2024
            /^\d{1,2}\s+[A-Za-z]+\s+\d{4}$/ // 1 January 2024
        ];
        
        return datePatterns.some(pattern => pattern.test(str.trim()));
    }
    
    /**
     * Format a date/time value according to the specified format
     */
    function formatDateTimeValue(value, formatType, customFormat = '') {
        if (!value || value === '') return '';
        
        // Try to parse the value as a date
        let date = null;
        
        // First, try direct Date.parse
        const timestamp = Date.parse(value);
        if (!isNaN(timestamp)) {
            date = new Date(timestamp);
        }
        
        // If that fails, try our custom parseDate function
        if (!date || isNaN(date.getTime())) {
            date = parseDate(value);
        }
        
        // If still no valid date, return original value
        if (!date || isNaN(date.getTime())) {
            return value;
        }
        
        // Format according to type
        switch (formatType) {
            // Date formats
            case 'full-date':
                return date.toLocaleDateString('en-US', { 
                    year: 'numeric', 
                    month: 'long', 
                    day: 'numeric' 
                });
                
            case 'short-date':
                return date.toLocaleDateString('en-US');
                
            case 'month-year':
                return date.toLocaleDateString('en-US', { 
                    year: 'numeric', 
                    month: 'long' 
                });
                
            case 'month-only':
                return date.toLocaleDateString('en-US', { 
                    month: 'long' 
                });
                
            case 'year-only':
                return date.getFullYear().toString();
                
            case 'day-month':
                return date.toLocaleDateString('en-US', { 
                    month: 'long', 
                    day: 'numeric' 
                });
                
            case 'day-of-week':
                return date.toLocaleDateString('en-US', { 
                    weekday: 'long' 
                });
                
            case 'day-of-week-date':
                return date.toLocaleDateString('en-US', { 
                    weekday: 'long', 
                    month: 'long', 
                    day: 'numeric' 
                });
                
            case 'iso-date':
                return date.toISOString().split('T')[0];
                
            // Time formats
            case 'full-time':
                return date.toLocaleTimeString('en-US');
                
            case 'short-time':
                return date.toLocaleTimeString('en-US', { 
                    hour: 'numeric', 
                    minute: '2-digit', 
                    hour12: true 
                });
                
            case '24hr-time':
                return date.toLocaleTimeString('en-US', { 
                    hour: '2-digit', 
                    minute: '2-digit', 
                    hour12: false 
                });
                
            case 'hour-only':
                return date.toLocaleTimeString('en-US', { 
                    hour: 'numeric', 
                    hour12: true 
                });
                
            // Date & Time formats
            case 'datetime-full':
                return date.toLocaleString('en-US');
                
            case 'datetime-short':
                return `${date.toLocaleDateString('en-US')} ${date.toLocaleTimeString('en-US', { 
                    hour: '2-digit', 
                    minute: '2-digit', 
                    hour12: false 
                })}`;
                
            // Custom formats
            case 'custom-date':
            case 'custom-time':
            case 'custom-datetime':
                return formatCustomDateTime(date, customFormat);
                
            default:
                return date.toLocaleString('en-US');
        }
    }
    
    /**
     * Format date with custom format string
     */
    function formatCustomDateTime(date, format) {
        if (!format) return date.toLocaleString('en-US');
        
        // Format tokens
        const replacements = {
            'YYYY': date.getFullYear().toString(),
            'YY': date.getFullYear().toString().slice(2),
            'MMMM': date.toLocaleDateString('en-US', { month: 'long' }),
            'MMM': date.toLocaleDateString('en-US', { month: 'short' }),
            'MM': (date.getMonth() + 1).toString().padStart(2, '0'),
            'M': (date.getMonth() + 1).toString(),
            'DD': date.getDate().toString().padStart(2, '0'),
            'D': date.getDate().toString(),
            'dddd': date.toLocaleDateString('en-US', { weekday: 'long' }),
            'ddd': date.toLocaleDateString('en-US', { weekday: 'short' }),
            'HH': date.getHours().toString().padStart(2, '0'),
            'H': date.getHours().toString(),
            'hh': (date.getHours() % 12 || 12).toString().padStart(2, '0'),
            'h': (date.getHours() % 12 || 12).toString(),
            'mm': date.getMinutes().toString().padStart(2, '0'),
            'ss': date.getSeconds().toString().padStart(2, '0'),
            'A': date.getHours() >= 12 ? 'PM' : 'AM',
            'a': date.getHours() >= 12 ? 'pm' : 'am'
        };
        
        let result = format;
        // Replace tokens (longest first to avoid partial replacements)
        Object.keys(replacements)
            .sort((a, b) => b.length - a.length)
            .forEach(token => {
                result = result.replace(new RegExp(token, 'g'), replacements[token]);
            });
        
        return result;
    }
    
    // Return public methods
    return {
        showDateTimeFormatModal: () => {
            populateDateTimeColumnSelect();
            modal.style.display = 'flex';
        }
    };
}

/**
 * Enhanced parseDate function that can handle more date formats
 */
function parseDateEnhanced(value) {
    if (!value || typeof value !== 'string') return null;
    
    value = value.trim();
    
    // Handle ISO formats
    if (/^\d{4}-\d{2}-\d{2}/.test(value)) {
        const date = new Date(value);
        if (!isNaN(date.getTime())) return date;
    }
    
    // Handle common formats
    const patterns = [
        // MM/DD/YYYY or MM-DD-YYYY
        /^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})/,
        // YYYY/MM/DD or YYYY-MM-DD
        /^(\d{4})[\/\-](\d{1,2})[\/\-](\d{1,2})/,
        // DD/MM/YYYY or DD-MM-YYYY
        /^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})/,
        // Month name formats
        /^([A-Za-z]+)\s+(\d{1,2}),?\s+(\d{4})/,
        /^(\d{1,2})\s+([A-Za-z]+)\s+(\d{4})/
    ];
    
    for (let pattern of patterns) {
        const match = value.match(pattern);
        if (match) {
            let year, month, day;
            
            if (pattern.toString().includes('([A-Za-z]+)')) {
                // Month name format
                if (pattern.toString().startsWith('^([A-Za-z]+)')) {
                    // Month Day, Year format
                    const monthName = match[1];
                    day = parseInt(match[2]);
                    year = parseInt(match[3]);
                    month = getMonthIndex(monthName);
                } else {
                    // Day Month Year format
                    day = parseInt(match[1]);
                    const monthName = match[2];
                    year = parseInt(match[3]);
                    month = getMonthIndex(monthName);
                }
            } else if (pattern.toString().startsWith('^(\d{4})')) {
                // YYYY-MM-DD format
                year = parseInt(match[1]);
                month = parseInt(match[2]) - 1; // JS months are 0-indexed
                day = parseInt(match[3]);
            } else if (pattern.toString().includes('(\d{4})$')) {
                // MM/DD/YYYY format
                month = parseInt(match[1]) - 1;
                day = parseInt(match[2]);
                year = parseInt(match[3]);
            } else {
                // DD/MM/YYYY format
                day = parseInt(match[1]);
                month = parseInt(match[2]) - 1;
                year = parseInt(match[3]);
            }
            
            if (month >= 0 && month <= 11 && day >= 1 && day <= 31 && year >= 1000) {
                const date = new Date(year, month, day);
                if (date.getDate() === day && date.getMonth() === month && date.getFullYear() === year) {
                    return date;
                }
            }
        }
    }
    
    // Try JavaScript's built-in parser as fallback
    const date = new Date(value);
    if (!isNaN(date.getTime())) {
        return date;
    }
    
    return null;
}

/**
 * Get month index from month name
 */
function getMonthIndex(monthName) {
    const months = {
        'january': 0, 'jan': 0,
        'february': 1, 'feb': 1,
        'march': 2, 'mar': 2,
        'april': 3, 'apr': 3,
        'may': 4,
        'june': 5, 'jun': 5,
        'july': 6, 'jul': 6,
        'august': 7, 'aug': 7,
        'september': 8, 'sep': 8,
        'october': 9, 'oct': 9,
        'november': 10, 'nov': 10,
        'december': 11, 'dec': 11
    };
    
    return months[monthName.toLowerCase()] || -1;
}

// Integration with existing code
// Add this to the init function or after the DOM is loaded
function integrateDateTimeFormatting() {
    // Add date/time formatting controls to all existing file sections
    document.querySelectorAll('.file-data-section').forEach(section => {
        if (!section._dateTimeFormattingAdded) {
            addDateTimeFormattingControls(section);
            section._dateTimeFormattingAdded = true;
        }
    });
    
}

/**
 * Cleans the worksheet data by removing empty rows and duplicate rows
 * @param {Array} jsonData - The 2D array of data from the worksheet
 * @param {Object} options - Configuration options
 * @param {boolean} options.removeEmptyRows - Whether to remove empty rows (default: true)
 * @param {boolean} options.removeDuplicateRows - Whether to remove duplicate rows (default: true)
 * @param {boolean} options.ignoreHeader - Whether to ignore the header row (default: true)
 * @returns {Object} - Object containing cleaned data and statistics
 */
function cleanWorksheetData(jsonData, options = {}) {
    // Set default options
    const {
        removeEmptyRows = true,
        removeDuplicateRows = true,
        ignoreHeader = true
    } = options;
    
    if (!jsonData || jsonData.length === 0) {
        return { cleanedData: jsonData, stats: { emptyRowsRemoved: 0, duplicateRowsRemoved: 0 } };
    }
    
    let dataToProcess = [...jsonData];
    let emptyRowsRemoved = 0;
    let duplicateRowsRemoved = 0;
    
    // Store header separately if ignoreHeader is true
    let headerRow = null;
    if (ignoreHeader && dataToProcess.length > 0) {
        headerRow = dataToProcess[0];
        dataToProcess = dataToProcess.slice(1);
    }
    
    // Remove empty rows
    if (removeEmptyRows) {
        const originalLength = dataToProcess.length;
        dataToProcess = dataToProcess.filter(row => {
            // Check if row is not empty (has at least one non-empty cell)
            return row && row.some(cell => {
                const cellValue = cell !== undefined && cell !== null ? String(cell).trim() : '';
                return cellValue !== '';
            });
        });
        emptyRowsRemoved = originalLength - dataToProcess.length;
    }
    
    // Remove duplicate rows
    if (removeDuplicateRows) {
        const originalLength = dataToProcess.length;
        const uniqueRows = [];
        const seenRows = new Set();
        
        for (const row of dataToProcess) {
            // Create a string representation of the row for comparison
            // Handle different data types appropriately
            const rowString = row.map(cell => {
                if (cell === null || cell === undefined) return 'null';
                if (typeof cell === 'object') return JSON.stringify(cell);
                return String(cell);
            }).join('|||'); // Use a delimiter unlikely to appear in data
            
            if (!seenRows.has(rowString)) {
                seenRows.add(rowString);
                uniqueRows.push(row);
            }
        }
        
        dataToProcess = uniqueRows;
        duplicateRowsRemoved = originalLength - dataToProcess.length;
    }
    
    // Reconstruct the final data with header if it was separated
    let cleanedData = dataToProcess;
    if (headerRow !== null) {
        cleanedData = [headerRow, ...dataToProcess];
    }
    
    return {
        cleanedData,
        stats: {
            emptyRowsRemoved,
            duplicateRowsRemoved,
            totalRowsRemoved: emptyRowsRemoved + duplicateRowsRemoved,
            originalRowCount: jsonData.length,
            finalRowCount: cleanedData.length
        }
    };
}

/**
 * Adds UI controls for cleaning data (removing empty/duplicate rows)
 * @param {HTMLElement} fileDataSection - The file data section element
 */
function addDataCleaningControls(fileDataSection) {
    const sheetData = fileDataSection.querySelector('.sheet-data');
    
    // Create clean data button
    const cleanBtn = document.createElement('button');
    cleanBtn.className = 'clean-btn';
    cleanBtn.textContent = 'ðŸ§¹ Clean Data';
    cleanBtn.style.cssText = `
        background: rgba(255, 193, 7, 0.3);
        color: white;
        border: 1px solid rgba(255, 255, 255, 0.3);
        padding: 8px 16px;
        border-radius: 5px;
        cursor: pointer;
        margin-bottom: 10px;
        margin-left: 10px;
        font-size: 0.9rem;
    `;
    
    // Create modal container
    const modal = document.createElement('div');
    modal.className = 'clean-data-modal';
    modal.style.cssText = `
        display: none;
        position: fixed;
        z-index: 1004;
        left: 0; top: 0;
        width: 100%; height: 100%;
        background-color: rgba(0,0,0,0.5);
        justify-content: center;
        align-items: center;
    `;
    
    // Modal content
    const modalContent = document.createElement('div');
    modalContent.style.cssText = `
        background-color: #2d2d2d;
        margin: auto;
        padding: 20px;
        border: 1px solid rgba(255,255,255,0.1);
        border-radius: 8px;
        width: 90%;
        max-width: 600px;
        color: white;
    `;
    
    modalContent.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <h3>Clean Data</h3>
            <span class="close-clean-modal" style="font-size: 24px; cursor: pointer;">&times;</span>
        </div>
        <div style="margin-bottom: 15px; padding: 15px; background: rgba(0, 0, 0, 0.2); border-radius: 8px;">
            <h4>Current Data Statistics</h4>
            <div class="current-stats" style="margin-top: 10px;">
                <div>Total Rows: <span class="total-rows">0</span></div>
            </div>
        </div>
        <div style="margin-bottom: 15px;">
            <label style="display: block; margin-bottom: 10px; font-weight: bold;">Select Cleaning Options:</label>
            <div style="display: flex; flex-direction: column; gap: 10px;">
                <label style="display: flex; align-items: center;">
                    <input type="checkbox" class="remove-empty-rows" checked style="margin-right: 8px;">
                    Remove Empty Rows (rows with no data in any column)
                </label>
                <label style="display: flex; align-items: center;">
                    <input type="checkbox" class="remove-duplicate-rows" checked style="margin-right: 8px;">
                    Remove Duplicate Rows (exact matches across all columns)
                </label>
                <label style="display: flex; align-items: center;">
                    <input type="checkbox" class="ignore-header" checked style="margin-right: 8px;">
                    Ignore Header Row (don't clean the first row)
                </label>
            </div>
        </div>
        <div style="margin-bottom: 15px; padding: 15px; background: rgba(0, 100, 0, 0.2); border-radius: 8px; display: none;" class="preview-stats">
            <h4>Preview Results</h4>
            <div class="preview-content" style="margin-top: 10px;">
                <div>Empty Rows to Remove: <span class="empty-rows-count">0</span></div>
                <div>Duplicate Rows to Remove: <span class="duplicate-rows-count">0</span></div>
                <div><strong>Total Rows After Cleaning: <span class="final-rows-count">0</span></strong></div>
            </div>
        </div>
        <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
            <button class="cancel-clean" style="background: rgba(255, 0, 0, 0.3); color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">Cancel</button>
            <button class="apply-clean" style="background: linear-gradient(to right, #4facfe, #00f2fe); color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">Apply Cleaning</button>
        </div>
    `;
    
    modal.appendChild(modalContent);
    document.body.appendChild(modal);
    
    // Add button to DOM
    const formatBtn = fileDataSection.querySelector('.format-btn');
    if (formatBtn && formatBtn.parentNode) {
        formatBtn.parentNode.insertBefore(cleanBtn, formatBtn.nextSibling);
    } else {
        sheetData.parentNode.insertBefore(cleanBtn, sheetData);
    }
    
    // Event listeners
    cleanBtn.addEventListener('click', () => {
        updateCurrentStats();
        updatePreview();
        modal.style.display = 'flex';
    });
    
    modal.querySelector('.close-clean-modal').addEventListener('click', () => {
        modal.style.display = 'none';
    });
    
    modal.querySelector('.cancel-clean').addEventListener('click', () => {
        modal.style.display = 'none';
    });
    
    // Update preview when options change
    const checkboxes = modal.querySelectorAll('input[type="checkbox"]');
    checkboxes.forEach(checkbox => {
        checkbox.addEventListener('change', updatePreview);
    });
    
    // Apply cleaning
    modal.querySelector('.apply-clean').addEventListener('click', () => {
        applyDataCleaning();
    });
    
    // Close modal when clicking outside
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            modal.style.display = 'none';
        }
    });
    
    /**
     * Update current statistics
     */
    function updateCurrentStats() {
        const tableBody = fileDataSection.querySelector('tbody');
        if (!tableBody) return;
        
        const rows = tableBody.querySelectorAll('tr');
        const totalRows = rows.length;
        
        modal.querySelector('.total-rows').textContent = totalRows;
    }
    
    /**
     * Update preview based on current selections
     */
    function updatePreview() {
        const removeEmptyRows = modal.querySelector('.remove-empty-rows').checked;
        const removeDuplicateRows = modal.querySelector('.remove-duplicate-rows').checked;
        const ignoreHeader = modal.querySelector('.ignore-header').checked;
        
        // Get current data
        const activeTab = fileDataSection.querySelector('.sheet-tab.active');
        if (!activeTab) return;
        
        const sheetName = activeTab.textContent;
        const workbook = fileDataSection.workbook;
        if (!workbook || !workbook.Sheets[sheetName]) return;
        
        const worksheet = workbook.Sheets[sheetName];
        const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: '' });
        
        if (!jsonData || jsonData.length === 0) return;
        
        // Simulate cleaning without actually modifying data
        const result = cleanWorksheetData(jsonData, {
            removeEmptyRows,
            removeDuplicateRows,
            ignoreHeader
        });
        
        // Show preview stats
        const previewStats = modal.querySelector('.preview-stats');
        previewStats.style.display = 'block';
        
        modal.querySelector('.empty-rows-count').textContent = result.stats.emptyRowsRemoved;
        modal.querySelector('.duplicate-rows-count').textContent = result.stats.duplicateRowsRemoved;
        modal.querySelector('.final-rows-count').textContent = result.stats.finalRowCount;
    }
    
    /**
     * Apply the actual data cleaning
     */
    function applyDataCleaning() {
        const removeEmptyRows = modal.querySelector('.remove-empty-rows').checked;
        const removeDuplicateRows = modal.querySelector('.remove-duplicate-rows').checked;
        const ignoreHeader = modal.querySelector('.ignore-header').checked;
        
        const activeTab = fileDataSection.querySelector('.sheet-tab.active');
        if (!activeTab) {
            showStatus('No active sheet', 'error');
            return;
        }
        
        const sheetName = activeTab.textContent;
        const workbook = fileDataSection.workbook;
        if (!workbook || !workbook.Sheets[sheetName]) {
            showStatus('Workbook data not available', 'error');
            return;
        }
        
        // Get current data
        const worksheet = workbook.Sheets[sheetName];
        const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: '' });
        
        if (!jsonData || jsonData.length === 0) {
            showStatus('No data to clean', 'error');
            return;
        }
        
        // Clean the data
        const result = cleanWorksheetData(jsonData, {
            removeEmptyRows,
            removeDuplicateRows,
            ignoreHeader
        });
        
        // Update the worksheet with cleaned data
        const cleanedWorksheet = XLSX.utils.aoa_to_sheet(result.cleanedData);
        
        // Preserve formatting and properties
        Object.keys(worksheet).forEach(key => {
            if (key !== '!ref' && key !== '!cols' && key !== '!rows') {
                cleanedWorksheet[key] = worksheet[key];
            }
        });
        
        // Update the workbook
        workbook.Sheets[sheetName] = cleanedWorksheet;
        fileDataSection.workbook = workbook;
        
        // Get headers from cleaned data
        const headers = result.cleanedData.length > 0 ? result.cleanedData[0] : [];
        
        // Re-render the table
        const tableHeader = fileDataSection.querySelector('thead');
        const tableBody = fileDataSection.querySelector('tbody');
        const columnControls = fileDataSection.querySelector('.column-controls');
        
        renderTableHeader(headers, tableHeader, fileDataSection, fileDataSection.fileName, sheetName);
        renderTableBody(headers, result.cleanedData, cleanedWorksheet, tableBody);
        initializeColumnControls(headers, columnControls, fileDataSection.fileName, sheetName, tableHeader, tableBody);
        
        // Reapply filters, sorting, pagination, etc.
        applyHiddenColumns(fileDataSection.fileName, sheetName, tableHeader, tableBody);
        reapplyFilters(fileDataSection, fileDataSection.fileName, sheetName, tableHeader, tableBody);
        setupPaginationAndStats(fileDataSection, tableBody);
        setupAdvancedSearch(fileDataSection, headers);
        setupCharting(fileDataSection);
        setupStatsPanel(fileDataSection, headers, tableBody);
        
        // Update pivot analyzer if it exists
        if (fileDataSection.querySelector('.toggle-pivot-btn')) {
            setupPivotAnalyzer(fileDataSection, headers, tableBody);
        }
        
        // Show success message
        const message = `Data cleaned successfully! Removed ${result.stats.totalRowsRemoved} rows (${result.stats.emptyRowsRemoved} empty, ${result.stats.duplicateRowsRemoved} duplicates).`;
        showStatus(message, 'success');
        
        // Close modal
        modal.style.display = 'none';
    }
    
    // Store reference to cleaning controls
    fileDataSection.cleanDataControls = {
        modal,
        updatePreview,
        updateCurrentStats
    };
    
    return {
        showCleanDataModal: () => {
            updateCurrentStats();
            updatePreview();
            modal.style.display = 'flex';
        }
    };
}

window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>