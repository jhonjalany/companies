<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-File Excel Uploader - Enhanced with Sorting</title>
    <script src="https://cdn.sheetjs.com/xlsx-0.20.2/package/dist/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #1a2a6c);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 90%;
            margin: 0 auto;
            padding: 20px;
        }
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        h1 {
            font-size: 2.8rem;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
            max-width: 700px;
            margin: 0 auto;
        }
        .upload-section {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .upload-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        .file-input-wrapper {
            position: relative;
            width: 100%;
            max-width: 500px;
        }
        .file-input {
            width: 100%;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            color: white;
            font-size: 1.1rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .file-input:hover {
            background: rgba(0, 0, 0, 0.4);
            border-color: rgba(255, 255, 255, 0.5);
        }
        .file-input input {
            display: none;
        }
        .upload-btn {
            background: linear-gradient(to right, #4facfe, #00f2fe);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.2rem;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        .upload-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }
        .upload-btn:active {
            transform: translateY(1px);
        }
        .upload-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        .status {
            margin-top: 15px;
            font-size: 1.1rem;
            min-height: 25px;
        }
        .success {
            color: #7fff00;
        }
        .error {
            color: #ff4d4d;
        }
        .file-list {
            width: 100%;
            max-width: 600px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
            max-height: 200px;
            overflow-y: auto;
        }
        .file-item {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
            margin-bottom: 8px;
            align-items: center;
        }
        .file-item:last-child {
            margin-bottom: 0;
        }
        .file-name {
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            padding-right: 10px;
        }
        .remove-file {
            background: rgba(255, 0, 0, 0.3);
            border: none;
            color: white;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .remove-file:hover {
            background: rgba(255, 0, 0, 0.5);
        }
        .info-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        .info-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .info-card h2 {
            margin-bottom: 15px;
            font-size: 1.5rem;
            color: #4facfe;
        }
        .info-card ul {
            padding-left: 20px;
        }
        .info-card li {
            margin-bottom: 10px;
            line-height: 1.5;
        }
        /* Container for all file data sections */
        .data-section-container {
            display: flex;
            flex-direction: column;
            gap: 30px; /* Space between file sections */
        }
        /* Individual file data section */
        .file-data-section {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative; /* Needed for absolute positioning of delete button */
        }
        .file-data-section h2 {
            margin-bottom: 20px;
            font-size: 1.8rem;
            color: #00f2fe;
            word-break: break-all; /* Handle long filenames */
            padding-right: 40px; /* Make space for the delete button */
        }
        /* --- Add Delete Button Styles --- */
        .delete-section-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 0, 0, 0.3);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.3s ease;
        }
        .delete-section-btn:hover {
            background: rgba(255, 0, 0, 0.5);
        }
        /* --- End Delete Button Styles --- */
        .sheet-tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }
        .sheet-tab {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px 20px;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .sheet-tab.active {
            background: linear-gradient(to right, #4facfe, #00f2fe);
            color: white;
        }
        .sheet-tab:hover:not(.active) {
            background: rgba(0, 0, 0, 0.5);
        }
        .sheet-data {
            overflow-x: auto;
            max-height: 100vh;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 15px;
            display: flex;
            flex-direction: column;
        }
        .table-container {
            overflow-y: auto;
            max-height: 600px;
            flex-grow: 1;
        }
        .table-container table {
            width: 100%;
            border-collapse: collapse;
            min-width: 600px;
        }
        .table-container thead th {
            position: sticky;
            top: 0;
            background: rgba(31, 27, 27, 0.911);
            z-index: 1;
            font-weight: 600;
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
            transition: background 0.3s ease;
        }
        .table-container thead th:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        .table-container thead th.sorted-asc::after {
            content: " ▲";
            color: #4facfe;
        }
        .table-container thead th.sorted-desc::after {
            content: " ▼";
            color: #4facfe;
        }
        .table-container tbody td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        .table-container tr:nth-child(even) {
            background: rgba(255, 255, 255, 0.05);
        }
        .table-container tr:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        /* Hidden column class */
        .hidden-column {
            display: none;
        }
        /* Column visibility controls */
        .column-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
        }
        .column-control-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 6px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }
        .column-control-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        .column-control-btn.hidden {
            background: rgba(255, 0, 0, 0.3);
            border-color: rgba(255, 0, 0, 0.5);
        }
        .column-control-btn.hidden::after {
            content: " (Hidden)";
            font-size: 0.8em;
            opacity: 0.8;
        }
        .controls {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        .clear-btn {
            background: rgba(255, 0, 0, 0.3);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .clear-btn:hover {
            background: rgba(255, 0, 0, 0.5);
        }
        footer {
            text-align: center;
            margin-top: 30px;
            padding: 20px;
            font-size: 0.9rem;
            opacity: 0.8;
        }
        @media (max-width: 768px) {
            h1 {
                font-size: 2.2rem;
            }
            .upload-section, .info-card, .file-data-section {
                padding: 20px;
            }
            .info-section {
                grid-template-columns: 1fr;
            }
            .controls {
                flex-direction: column;
            }
            /* --- Responsive Delete Button --- */
            .file-data-section h2 {
                 padding-right: 0;
            }
            .delete-section-btn {
                position: relative;
                top: auto;
                right: auto;
                margin-top: 10px;
                align-self: flex-end;
            }
            /* --- End Responsive Delete Button --- */
        }
        /* Search input styling */
        .table-container thead th input {
            width: 100%;
            padding: 5px;
            margin-top: 5px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background-color: rgba(255, 255, 255, 0.1);
            color: white;
        }
        .table-container thead th input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }
        .table-container thead th input:focus {
            outline: none;
            border-color: #4facfe;
            background-color: rgba(255, 255, 255, 0.2);
        }
        .table-stats {
    font-size: 0.9rem;
    opacity: 0.9;
    display: flex;
    justify-content: space-between;
    flex-wrap: wrap;
    gap: 10px;
    margin-top: 15px;
    align-items: center;
}
.pagination-controls button {
    background: rgba(79, 172, 254, 0.3);
    color: white;
    border: 1px solid rgba(255, 255, 255, 0.3);
    padding: 6px 12px;
    border-radius: 5px;
    cursor: pointer;
    margin: 0 5px;
}
.pagination-controls button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}
.pagination-controls button:hover:not(:disabled) {
    background: rgba(79, 172, 254, 0.5);
}
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Multi-File Excel Uploader</h1>
            <p class="subtitle">Upload multiple Excel, CSV, or spreadsheet files to view and manage sheet data in real-time</p>
        </header>
        <section class="upload-section">
            <div class="upload-container">
                <div class="file-input-wrapper">
                    <div class="file-input" id="dropZone">
                        <span id="fileText">Drag & drop files here or click to browse</span>
                        <input type="file" id="fileInput" accept=".xlsx,.xls,.csv" multiple>
                    </div>
                </div>
                <button class="upload-btn" id="uploadBtn" disabled>Process Files</button>
                <div class="status" id="status"></div>
                <div class="file-list" id="fileList"></div>
            </div>
        </section>
        <section class="info-section">
            <div class="info-card">
                <h2>Supported File Types</h2>
                <ul>
                    <li>Excel files (.xlsx, .xls)</li>
                    <li>CSV files (.csv)</li>
                    <li>OpenDocument spreadsheets (.ods)</li>
                    <li>Tab-separated values (.tsv)</li>
                </ul>
            </div>
            <div class="info-card">
                <h2>Features</h2>
                <ul>
                    <li>Upload multiple files at once</li>
                    <li>Handles large files efficiently</li>
                    <li>Clears previous data when needed</li>
                    <li>Displays data from all sheets</li>
                    <li>Responsive design for all devices</li>
                    <li><strong>Preserves original date/time formatting</strong></li>
                    <li><strong>Hide and unhide columns for each sheet individually</strong></li>
                    <li><strong>Sort data by any column (text, numbers, dates)</strong></li>
                    <li>Advanced search with multiple conditions</li>
                </ul>
            </div>
        </section>
        <!-- Template for individual file data sections -->
        <template id="fileDataSectionTemplate">
            <section class="file-data-section">
                <h2 class="file-title"></h2>
                <button class="delete-section-btn">Delete File Data</button>
                <div class="sheet-tabs"></div>
                <div class="sheet-data">
                    <div class="column-controls" id="columnControls"></div>
                    <div class="table-container">
                        <table>
                            <thead></thead>
                            <tbody></tbody>
                        </table>
                    </div>
                    <div class="no-data">No data available for this file.</div>
                    <div class="table-stats" style="margin-top: 15px; font-size: 0.9rem; opacity: 0.9; display: flex; justify-content: space-between; flex-wrap: wrap;">
                        <div class="row-count">Rows: 0</div>
                        <div class="pagination-controls">
                            <button class="prev-page" disabled>◀ Previous</button>
                            <span class="page-info">Page 1</span>
                            <button class="next-page">Next ▶</button>
                        </div>
                    </div>
                </div>
            </section>
        </template>
        <!-- Container for dynamically created file data sections -->
        <div class="data-section-container" id="dataSectionContainer"></div>
        <div class="controls">
            <button class="clear-btn" id="clearAllBtn">Clear All Data</button>
        </div>
        <footer>
            <p>Multi-File Excel Uploader &copy; 2023 | All data is processed locally in your browser</p>
        </footer>
    </div>
    <script>
    // DOM elements
    const fileInput = document.getElementById('fileInput');
    const dropZone = document.getElementById('dropZone');
    const fileText = document.getElementById('fileText');
    const uploadBtn = document.getElementById('uploadBtn');
    const statusDiv = document.getElementById('status');
    const fileList = document.getElementById('fileList');
    const dataSectionContainer = document.getElementById('dataSectionContainer');
    const clearAllBtn = document.getElementById('clearAllBtn');
    const fileDataSectionTemplate = document.getElementById('fileDataSectionTemplate');
    
    // Track hidden columns for each file and sheet
    let hidden = {};
    
    // Track sorting state for each column
    let sortingState = {};
    
    // --- NEW: Reusable Date/Time Detection Function ---
    async function detectDateTimeFormats(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = function (e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array', cellDates: false, cellNF: true });
                    const dateTimeInfo = {};
                    workbook.SheetNames.forEach(sheetName => {
                        const worksheet = workbook.Sheets[sheetName];
                        const dateColumns = new Set();
                        const timeColumns = new Set();
                        const range = XLSX.utils.decode_range(worksheet['!ref']);
                        for (let R = range.s.r; R <= range.e.r; ++R) {
                            for (let C = range.s.c; C <= range.e.c; ++C) {
                                const cellAddress = XLSX.utils.encode_cell({ r: R, c: C });
                                const cell = worksheet[cellAddress];
                                if (cell && cell.t === 'n' && typeof cell.z === 'string') {
                                    const format = cell.z.toLowerCase();
                                    if (
                                        format.includes('yy') || format.includes('yyyy') ||
                                        format.includes('mm') || format.includes('mmm') ||
                                        format.includes('dd') || format.includes('d') ||
                                        format.includes('date') ||
                                        /\[(h|m|s)\]/.test(format) ||
                                        (format.includes(':') && (format.includes('h') || format.includes('m') || format.includes('s')))
                                    ) {
                                        if (format.includes(':') || /\[(h|m|s)\]/.test(format)) {
                                            timeColumns.add(C);
                                        } else {
                                            dateColumns.add(C);
                                        }
                                    }
                                }
                            }
                        }
                        dateTimeInfo[sheetName] = {
                            dateColumns: Array.from(dateColumns),
                            timeColumns: Array.from(timeColumns)
                        };
                    });
                    resolve(dateTimeInfo);
                } catch (error) {
                    reject(error);
                }
            };
            reader.onerror = () => reject(new Error("Failed to read file"));
            reader.readAsArrayBuffer(file);
        });
    }
    
    // --- NEW: Reusable Delete Function ---
    function deleteFileSection(sectionElement) {
        const sectionToDelete = sectionElement || this.closest('.file-data-section');
        if (!sectionToDelete) return;
        const fileTitleElement = sectionToDelete.querySelector('.file-title');
        const fileName = fileTitleElement ? fileTitleElement.textContent.replace('Data from: ', '') : 'this file';
        const userConfirmed = confirm(`Are you sure you want to delete the data for "${fileName}"?`);
        if (userConfirmed) {
            if (sectionToDelete.fileName) {
                delete hidden[sectionToDelete.fileName];
                delete sortingState[sectionToDelete.fileName];
            }
            sectionToDelete.fileDataArrayBuffer = null;
            sectionToDelete.dateTimeInfo = null;
            sectionToDelete.remove();
            showStatus(`Data for "${fileName}" deleted.`, 'success');
        }
    }
    
    // Initialize the application
    function init() {
        setupEventListeners();
    }
    
    function setupEventListeners() {
        fileInput.addEventListener('change', handleFileSelect);
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.style.borderColor = '#4facfe';
            dropZone.style.backgroundColor = 'rgba(0, 0, 0, 0.4)';
        });
        dropZone.addEventListener('dragleave', () => {
            dropZone.style.borderColor = 'rgba(255, 255, 255, 0.3)';
            dropZone.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';
        });
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.style.borderColor = 'rgba(255, 255, 255, 0.3)';
            dropZone.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';
            if (e.dataTransfer.files.length) {
                fileInput.files = e.dataTransfer.files;
                handleFileSelect();
            }
        });
        uploadBtn.addEventListener('click', processFiles);
        clearAllBtn.addEventListener('click', clearAllData);
    }
    
    function handleFileSelect() {
        const files = fileInput.files;
        if (files.length > 0) {
            fileText.textContent = `${files.length} file(s) selected`;
            uploadBtn.disabled = false;
            statusDiv.textContent = '';
            statusDiv.className = 'status';
            updateFileList();
        } else {
            fileText.textContent = 'Drag & drop files here or click to browse';
            uploadBtn.disabled = true;
            fileList.innerHTML = '';
        }
    }
    
    function updateFileList() {
        fileList.innerHTML = '';
        Array.from(fileInput.files).forEach((file, index) => {
            const fileItem = document.createElement('div');
            fileItem.className = 'file-item';
            const fileName = document.createElement('div');
            fileName.className = 'file-name';
            fileName.textContent = file.name;
            const removeBtn = document.createElement('button');
            removeBtn.className = 'remove-file';
            removeBtn.innerHTML = '&times;';
            removeBtn.addEventListener('click', () => removeFile(index));
            fileItem.appendChild(fileName);
            fileItem.appendChild(removeBtn);
            fileList.appendChild(fileItem);
        });
    }
    
    function removeFile(index) {
        const dt = new DataTransfer();
        const files = fileInput.files;
        for (let i = 0; i < files.length; i++) {
            if (i !== index) {
                dt.items.add(files[i]);
            }
        }
        fileInput.files = dt.files;
        handleFileSelect();
    }
    
    function processFiles() {
        const files = fileInput.files;
        if (files.length === 0) return;
        showStatus('Processing files...', 'success');
        uploadBtn.disabled = true;
        processFileBatch(Array.from(files), 0);
    }
    
    async function processFileBatch(files, index) {
        if (index >= files.length) {
            showStatus(`Processed ${files.length} files successfully!`, 'success');
            uploadBtn.disabled = false;
            return;
        }
        const file = files[index];
        try {
            showStatus(`Analyzing formats for ${file.name}...`, 'success');
            const dateTimeInfo = await detectDateTimeFormats(file);
            console.log(`Date/Time Info for ${file.name}:`, dateTimeInfo);
            const reader = new FileReader();
            reader.onload = async function(e) {
                try {
                    const arrayBuffer = e.target.result;
                    const fileDataSectionFragment = fileDataSectionTemplate.content.cloneNode(true);
                    const fileDataSection = fileDataSectionFragment.querySelector('.file-data-section');
                    fileDataSection.fileName = file.name;
                    fileDataSection.dateTimeInfo = dateTimeInfo;
                    const deleteBtn = fileDataSection.querySelector('.delete-section-btn');
                    deleteBtn.addEventListener('click', () => deleteFileSection(fileDataSection));
                    const fileTitle = fileDataSection.querySelector('.file-title');
                    fileTitle.textContent = `Data from: ${file.name}`;
                    const sheetTabsContainer = fileDataSection.querySelector('.sheet-tabs');
                    const table = fileDataSection.querySelector('table');
                    const tableHeader = table.querySelector('thead');
                    const tableBody = table.querySelector('tbody');
                    const noDataMessage = fileDataSection.querySelector('.no-data');
                    const columnControls = fileDataSection.querySelector('.column-controls');
                    
                    if (!hidden[file.name]) hidden[file.name] = {};
                    if (!sortingState[file.name]) sortingState[file.name] = {};
                    
                    // Store raw ArrayBuffer for lazy loading
                    fileDataSection.fileDataArrayBuffer = arrayBuffer;
                    fileDataSection.workbook = null; // Will be parsed on demand
                    
                    // Read workbook structure to get sheet names
                    const tempWorkbook = XLSX.read(arrayBuffer, { type: 'array', bookSheets: true , cellDates: true });
                    const sheetNames = tempWorkbook.SheetNames;
                    
                    if (sheetNames.length === 0) {
                        noDataMessage.style.display = 'block';
                        table.style.display = 'none';
                        columnControls.style.display = 'none';
                    } else {
                        noDataMessage.style.display = 'none';
                        table.style.display = 'table';
                        columnControls.style.display = 'flex';
                        
                        // Create tabs
                        sheetNames.forEach((sheetName, tabIndex) => {
                            const tab = document.createElement('div');
                            tab.className = 'sheet-tab';
                            if (tabIndex === 0) tab.classList.add('active');
                            tab.textContent = sheetName;
                            tab.addEventListener('click', function() {
                                // Lazy load sheet data when tab is clicked
                                loadSheetData(sheetName, fileDataSection, sheetTabsContainer, tableHeader, tableBody, columnControls, file.name);
                            });
                            sheetTabsContainer.appendChild(tab);
                        });
                        
                        // Load first sheet immediately
                        loadSheetData(sheetNames[0], fileDataSection, sheetTabsContainer, tableHeader, tableBody, columnControls, file.name);
                    }
                    
                    dataSectionContainer.appendChild(fileDataSection);
                    processFileBatch(files, index + 1);
                } catch (err) {
                    console.error('Error parsing file:', err);
                    showStatus(`Error processing ${file.name}.`, 'error');
                    processFileBatch(files, index + 1);
                }
            };
            reader.onerror = () => {
                showStatus(`Error reading ${file.name}.`, 'error');
                processFileBatch(files, index + 1);
            };
            reader.readAsArrayBuffer(file);
        } catch (err) {
            console.error('Error detecting formats:', err);
            showStatus(`Error analyzing ${file.name}. Skipping.`, 'error');
            processFileBatch(files, index + 1);
        }
    }
    
    function resetAdvancedFilter(fileDataSection) {
    const advancedSearchContainer = fileDataSection.querySelector('.advanced-search-container');
    const conditions = advancedSearchContainer.querySelectorAll('.condition-group');
    conditions.forEach((conditionGroup, index) => {
        if (index === 0) {
            conditionGroup.querySelector('.value').value = '';
            conditionGroup.seenValues = {}; // Reset unique tracking
        } else {
            if (conditionGroup.parentNode) {
                conditionGroup.remove();
            }
        }
    });
    const tableBody = fileDataSection.querySelector('tbody');
    const bodyRows = tableBody.querySelectorAll('tr');
    bodyRows.forEach(row => {
        row.style.display = '';
    });
    
    // Properly notify the pagination system about the reset
    if (fileDataSection && typeof fileDataSection.currentFilterCallback === 'function') {
        const allRows = Array.from(tableBody.querySelectorAll('tr'));
        fileDataSection.currentFilterCallback(allRows);
    } else {
        // Fallback behavior
        const visibleCount = Array.from(tableBody.querySelectorAll('tr')).length;
        showStatus('Advanced filter reset', 'success');
    }
}
    
    function addAdvancedSearchControls(fileDataSection) {
        // Create advanced search container
        const advancedSearchContainer = document.createElement('div');
        advancedSearchContainer.className = 'advanced-search-container';
        advancedSearchContainer.style.cssText = `
            margin: 15px 0;
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            display: none; /* Hidden by default */
        `;
        
        // Create toggle button
        const toggleBtn = document.createElement('button');
        toggleBtn.className = 'toggle-advanced-search';
        toggleBtn.textContent = 'Toggle Advanced Search';
        toggleBtn.style.cssText = `
            background: rgba(79, 172, 254, 0.3);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            margin-bottom: 10px;
            font-size: 0.9rem;
        `;
        
        // Advanced search form
        advancedSearchContainer.innerHTML = `
            <div class="search-conditions" style="margin-bottom: 10px; max-height: 200px; overflow-y: auto;">
                <div class="condition-group" style="margin-bottom: 10px; padding: 10px; background: rgba(0, 0, 0, 0.2); border-radius: 5px;">
                    <select class="condition-type" style="padding: 5px; margin-right: 5px; background: rgba(255, 255, 255, 0.1); color: #888888; border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 4px;">
                        <option value="AND">AND</option>
                        <option value="OR">OR</option>
                    </select>
                    <select class="column-name" style="padding: 5px; margin-right: 5px; background: rgba(255, 255, 255, 0.1); color: #888888; border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 4px; flex: 1;"></select>
                    <select class="operator" style="padding: 5px; margin-right: 5px; background: rgba(255, 255, 255, 0.1); color: #888888; border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 4px;">
                        <option value="equals">=</option>
                        <option value="not-equals">!=</option>
                        <option value="greater-than">></option>
                        <option value="less-than"><</option>
                        <option value="greater-than-equal">>=</option>
                        <option value="less-than-equal"><=</option>
                        <option value="between">Between</option>
                        <option value="is-null">Is Empty</option>
                        <option value="is-not-null">Is Not Empty</option>
                        <option value="contains">Contains (Text)</option>
                        <option value="starts-with">Starts With</option>
                        <option value="ends-with">Ends With</option>
                        <option value="like">LIKE</option>
                        <option value="unique">Unique Values</option>
                    </select>
                    <input type="text" class="value" placeholder="Value" style="flex: 1; padding: 5px; border-radius: 4px; border: 1px solid rgba(255, 255, 255, 0.3); background-color: rgba(255, 255, 255, 0.1); color: white;">
                    <button class="remove-condition" style="background: rgba(255, 0, 0, 0.3); color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer; margin-left: 5px;">✕</button>
                </div>
            </div>
            <div style="display: flex; gap: 10px;">
                <button class="add-condition-btn" style="flex: 1; background: rgba(79, 172, 254, 0.3); color: white; border: 1px solid rgba(255, 255, 255, 0.3); padding: 8px; border-radius: 5px; cursor: pointer;">
                    + Add Condition
                </button>
                <button class="apply-advanced-filter" style="flex: 1; background: linear-gradient(to right, #4facfe, #00f2fe); color: white; border: none; padding: 8px; border-radius: 5px; cursor: pointer;">
                    Apply Filter
                </button>
                <button class="reset-advanced-filter" style="flex: 1; background: rgba(255, 0, 0, 0.3); color: white; border: none; padding: 8px; border-radius: 5px; cursor: pointer;">
                    Reset
                </button>
            </div>
        `;
        
        // Add the controls to the file data section
        const sheetData = fileDataSection.querySelector('.sheet-data');
        sheetData.parentNode.insertBefore(advancedSearchContainer, sheetData);
        sheetData.parentNode.insertBefore(toggleBtn, advancedSearchContainer);
        
        // Setup event listeners
        toggleBtn.addEventListener('click', () => {
            advancedSearchContainer.style.display = advancedSearchContainer.style.display === 'none' ? 'block' : 'none';
        });
        
        // Add initial condition event listeners
        setupConditionEvents(advancedSearchContainer, fileDataSection);
        
        // Add condition button
        const addConditionBtn = advancedSearchContainer.querySelector('.add-condition-btn');
        addConditionBtn.addEventListener('click', () => {
            const conditionGroup = document.createElement('div');
            conditionGroup.className = 'condition-group';
            conditionGroup.style.cssText = 'margin-bottom: 10px; padding: 10px; background: rgba(0, 0, 0, 0.2); border-radius: 5px;';
            conditionGroup.innerHTML = `
                <select class="condition-type" style="padding: 5px; margin-right: 5px; background: rgba(255, 255, 255, 0.1); color: #888888; border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 4px;">
                    <option value="AND">AND</option>
                    <option value="OR">OR</option>
                </select>
                <select class="column-name" style="padding: 5px; margin-right: 5px; background: rgba(255, 255, 255, 0.1); color: #888888; border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 4px; flex: 1;"></select>
                <select class="operator" style="padding: 5px; margin-right: 5px; background: rgba(255, 255, 255, 0.1); color: #888888; border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 4px;">
                    <option value="equals">=</option>
                    <option value="not-equals">!=</option>
                    <option value="greater-than">></option>
                    <option value="less-than"><</option>
                    <option value="greater-than-equal">>=</option>
                    <option value="less-than-equal"><=</option>
                    <option value="between">Between</option>
                    <option value="is-null">Is Empty</option>
                    <option value="is-not-null">Is Not Empty</option>
                    <option value="contains">Contains (Text)</option>
                    <option value="starts-with">Starts With</option>
                    <option value="ends-with">Ends With</option>
                    <option value="like">LIKE</option>
                    <option value="unique">Unique Values</option>
                </select>
                <input type="text" class="value" placeholder="Value" style="flex: 1; padding: 5px; border-radius: 4px; border: 1px solid rgba(255, 255, 255, 0.3); background-color: rgba(255, 255, 255, 0.1); color: white;">
                <button class="remove-condition" style="background: rgba(255, 0, 0, 0.3); color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer; margin-left: 5px;">✕</button>
            `;
            advancedSearchContainer.querySelector('.search-conditions').appendChild(conditionGroup);
            setupConditionEvents(advancedSearchContainer, fileDataSection);
            populateColumnNames(fileDataSection, conditionGroup);
        });
        
        // Apply filter button
        const applyFilterBtn = advancedSearchContainer.querySelector('.apply-advanced-filter');
        applyFilterBtn.addEventListener('click', () => {
            applyAdvancedFilter(fileDataSection);
        });
        
        // Reset filter button
        const resetFilterBtn = advancedSearchContainer.querySelector('.reset-advanced-filter');
        resetFilterBtn.addEventListener('click', () => {
            resetAdvancedFilter(fileDataSection);
        });
        
        return advancedSearchContainer;
    }
    
    function setupConditionEvents(advancedSearchContainer, fileDataSection) {
        // Remove condition button
        const removeButtons = advancedSearchContainer.querySelectorAll('.remove-condition');
        removeButtons.forEach(btn => {
            btn.onclick = null; // Remove any existing listeners
            btn.addEventListener('click', function() {
                if (advancedSearchContainer.querySelectorAll('.condition-group').length > 1) {
                    this.closest('.condition-group').remove();
                } else {
                    // Clear values instead of removing the last condition
                    const group = this.closest('.condition-group');
                    group.querySelector('.value').value = '';
                }
            });
        });
        
        // Populate column names for all condition groups
        const conditionGroups = advancedSearchContainer.querySelectorAll('.condition-group');
        conditionGroups.forEach(group => {
            populateColumnNames(fileDataSection, group);
        });
    }
    
    function populateColumnNames(fileDataSection, conditionGroup) {
        const columnNameSelect = conditionGroup.querySelector('.column-name');
        const previouslySelectedValue = columnNameSelect.value; // Save the current selection
        columnNameSelect.innerHTML = ''; // Clear existing options
        
        // Get headers from the current active sheet
        const tableHeader = fileDataSection.querySelector('thead');
        if (tableHeader) {
            const headers = tableHeader.querySelectorAll('th');
            headers.forEach(th => {
                const headerText = th.textContent.split('\n')[0]; // Extract just the header text
                const option = document.createElement('option');
                option.value = headerText;
                option.textContent = headerText;
                columnNameSelect.appendChild(option);
            });
            // Restore the previously selected value if it still exists
            if (previouslySelectedValue && Array.from(columnNameSelect.options).some(opt => opt.value === previouslySelectedValue)) {
                columnNameSelect.value = previouslySelectedValue;
            }
        }
    }
    
    
    // Enhanced version of applyAdvancedFilter with improved logic
    function applyAdvancedFilter(fileDataSection) {
        const advancedSearchContainer = fileDataSection.querySelector('.advanced-search-container');
        fileDataSection.currentAdvancedFilterActive = true;
        const conditions = Array.from(advancedSearchContainer.querySelectorAll('.condition-group'));
        const tableBody = fileDataSection.querySelector('tbody');
        const bodyRows = Array.from(tableBody.querySelectorAll('tr'));
        const seenComposites = {}; // For unique tracking
        
        // Reset all rows to visible
        bodyRows.forEach(row => {
            row.style.display = '';
        });
        
        // Get current sheet name and date/time info
        const activeTab = fileDataSection.querySelector('.sheet-tab.active');
        if (!activeTab) return;
        const sheetName = activeTab.textContent;
        const dateTimeInfo = fileDataSection.dateTimeInfo?.[sheetName];
        const dateCols = new Set(dateTimeInfo?.dateColumns || []);
        const timeCols = new Set(dateTimeInfo?.timeColumns || []);
        
        // Apply each condition
        conditions.forEach((conditionGroup, index) => {
            const columnName = conditionGroup.querySelector('.column-name').value;
            const operator = conditionGroup.querySelector('.operator').value;
            const inputVal = conditionGroup.querySelector('.value').value.trim();
            const conditionType = conditionGroup.querySelector('.condition-type').value;
            
            // Skip empty value fields unless operator is null-related or unique
            if (!['unique', 'is-null', 'is-not-null'].includes(operator) && !inputVal) return;
            
            // Get column index
            const tableHeader = fileDataSection.querySelector('thead');
            const headers = Array.from(tableHeader.querySelectorAll('th'));
            const colIndex = headers.findIndex(th => {
                const headerText = th.textContent.split('\n')[0];
                return headerText === columnName;
            });
            if (colIndex === -1) return;
            
            // Determine if this column is a date/time column
            const isDateColumn = dateCols.has(colIndex);
            
            // Parse input value if needed
            let inputDate = null;
            let parsedInputValue = null;
            let isInputNumeric = false;
            if (isDateColumn && ['equals', 'not-equals', 'greater-than', 'less-than', 'greater-than-equal', 'less-than-equal', 'between'].includes(operator)) {
                inputDate = parseDate(inputVal);
                if (!inputDate && operator !== 'between') {
                    showStatus(`Invalid date format: "${inputVal}"`, 'error');
                    return;
                }
            } else if (!['unique', 'is-null', 'is-not-null', 'between'].includes(operator)) {
                parsedInputValue = parseFormattedNumber(inputVal);
                isInputNumeric = parsedInputValue !== null;
            }
            
            bodyRows.forEach((row, rowIndex) => {
                if (row.style.display === 'none' && conditionType === 'AND') return;
                const cell = row.cells[colIndex];
                if (!cell) return;
                const cellText = cell.textContent.trim();
                let matches = false;
                
                if (isDateColumn) {
                    const cellDate = parseDate(cellText);
                    if (operator === 'is-null') {
                        matches = !cellDate && !cellText;
                    } else if (operator === 'is-not-null') {
                        matches = !!cellDate;
                    } else if (operator === 'between') {
                        const [from, to] = inputVal.split(',').map(v => parseDate(v.trim())).filter(Boolean);
                        if (from && to) {
                            matches = cellDate && cellDate >= from && cellDate <= to;
                        } else {
                            matches = false;
                        }
                    } else if (cellDate) {
                        switch (operator) {
                            case 'equals':
                                matches = cellDate.toDateString() === inputDate.toDateString();
                                break;
                            case 'not-equals':
                                matches = cellDate.toDateString() !== inputDate.toDateString();
                                break;
                            case 'greater-than':
                                matches = cellDate > inputDate;
                                break;
                            case 'less-than':
                                matches = cellDate < inputDate;
                                break;
                            case 'greater-than-equal':
                                matches = cellDate >= inputDate;
                                break;
                            case 'less-than-equal':
                                matches = cellDate <= inputDate;
                                break;
                            default:
                                matches = false;
                        }
                    }
                } else {
                    let cellValue = cellText;
                    let cellNumeric = parseFormattedNumber(cellText);
                    let useNumeric = isInputNumeric && cellNumeric !== null;
                    
                    switch (operator) {
                        case 'is-null':
                            matches = !cellText;
                            break;
                        case 'is-not-null':
                            matches = !!cellText;
                            break;
                        case 'equals':
                            matches = useNumeric
                                ? Math.abs(cellNumeric - parsedInputValue) < 1e-9
                                : cellText.toLowerCase() === inputVal.toLowerCase();
                            break;
                        case 'not-equals':
                            matches = useNumeric
                                ? Math.abs(cellNumeric - parsedInputValue) > 1e-9
                                : cellText.toLowerCase() !== inputVal.toLowerCase();
                            break;
                        case 'contains':
                            matches = cellText.toLowerCase().includes(inputVal.toLowerCase());
                            break;
                        case 'starts-with':
                            matches = cellText.toLowerCase().startsWith(inputVal.toLowerCase());
                            break;
                        case 'ends-with':
                            matches = cellText.toLowerCase().endsWith(inputVal.toLowerCase());
                            break;
                        case 'greater-than':
                            matches = useNumeric ? cellNumeric > parsedInputValue : false;
                            break;
                        case 'less-than':
                            matches = useNumeric ? cellNumeric < parsedInputValue : false;
                            break;
                        case 'greater-than-equal':
                            matches = useNumeric ? cellNumeric >= parsedInputValue : false;
                            break;
                        case 'less-than-equal':
                            matches = useNumeric ? cellNumeric <= parsedInputValue : false;
                            break;
                        case 'like':
                            const escaped = inputVal.replace(/[-\\^$*+?.()|[\]{}]/g, '\\$&');
                            const pattern = '^' + escaped.replace(/%/g, '.*').replace(/_/g, '.') + '$';
                            matches = new RegExp(pattern, 'i').test(cellText);
                            break;
                        case 'unique':
                            // Handle unique across multiple columns
                            const selectedColumns = conditions
                                .filter(c => c.querySelector('.operator').value === 'unique')
                                .map(c => c.querySelector('.column-name').value);
                            if (selectedColumns.length === 0) {
                                matches = true;
                            } else {
                                const keyParts = selectedColumns.map(colName => {
                                    const idx = headers.findIndex(th => {
                                        const headerText = th.textContent.split('\n')[0];
                                        return headerText === colName;
                                    });
                                    return idx !== -1 ? row.cells[idx]?.textContent.trim() : '';
                                });
                                const compositeKey = keyParts.join('|||'); // Delimiter to avoid collisions
                                if (conditionType === 'AND' && index > 0) {
                                    // Only keep if previously visible AND unique
                                    matches = !seenComposites[compositeKey];
                                } else {
                                    matches = !seenComposites[compositeKey];
                                }
                                if (matches) {
                                    seenComposites[compositeKey] = true;
                                }
                            }
                            break;
                        default:
                            matches = false;
                    }
                }
                
                // Apply logic based on condition index and type
                if (index === 0) {
                    if (!matches) row.style.display = 'none';
                } else {
                    if (conditionType === 'AND') {
                        if (!matches) row.style.display = 'none';
                    } else { // OR
                        if (matches) row.style.display = '';
                    }
                }
            });
        });
        // Notify pagination system
if (fileDataSection && typeof fileDataSection.currentFilterCallback === 'function') {
    const visibleRows = Array.from(tableBody.querySelectorAll('tr')).filter(r => r.style.display !== 'none');
    fileDataSection.currentFilterCallback(visibleRows);
} else {
    // Fallback
    const visibleCount = Array.from(tableBody.querySelectorAll('tr')).filter(r => r.style.display !== 'none').length;
    showStatus(`Advanced filter applied: ${visibleCount} rows`, 'success');
}
    }

    
    function resetAdvancedFilter(fileDataSection) {
    const advancedSearchContainer = fileDataSection.querySelector('.advanced-search-container');
    fileDataSection.currentAdvancedFilterActive = false;
    const conditions = advancedSearchContainer.querySelectorAll('.condition-group');
    
    // Reset all condition groups
    conditions.forEach((conditionGroup, index) => {
        if (index === 0) {
            conditionGroup.querySelector('.value').value = '';
            conditionGroup.seenValues = {}; // Reset unique tracking
        } else {
            if (conditionGroup.parentNode) {
                conditionGroup.remove();
            }
        }
    });

    const tableBody = fileDataSection.querySelector('tbody');
    const allRows = Array.from(tableBody.querySelectorAll('tr')); // Get all rows

    // Show all rows
    allRows.forEach(row => {
        row.style.display = '';
    });

    // ✅ Notify pagination system that filter is reset
    if (fileDataSection && typeof fileDataSection.currentFilterCallback === 'function') {
        fileDataSection.currentFilterCallback(allRows); // Pass all rows
    }

    showStatus('Advanced filter reset', 'success');
}

    function parseFormattedNumber(value) {
        if (typeof value !== 'string') value = String(value);
        value = value.trim();
        // Handle percentage: convert to decimal
        if (value.includes('%')) {
            const numericPart = value.replace(/[%$€£¥₹,]/g, '');
            const num = parseFloat(numericPart);
            return isNaN(num) ? null : num / 100;
        }
        // Extract number from currency/commas
        const numericPart = value.replace(/[$€£¥₹,]/g, '');
        const num = parseFloat(numericPart);
        return isNaN(num) ? null : num;
    }
    
    // --- NEW: Sorting Functions ---
    function sortTableData(fileDataSection, columnIndex, sheetName) {
    const table = fileDataSection.querySelector('table');
    const tableHeader = table.querySelector('thead');
    const tableBody = table.querySelector('tbody');

    // Get current search filters
    const searchTerms = {};
    const headers = tableHeader.querySelectorAll('th');
    headers.forEach((th, idx) => {
        const input = th.querySelector('input');
        if (input && input.value.trim()) {
            searchTerms[idx] = input.value.trim().toLowerCase();
        }
    });

    // Get the current sort state
    const currentState = sortingState[fileDataSection.fileName]?.[sheetName]?.[columnIndex] || 'none';
    const nextSortState = currentState === 'none' || currentState === 'desc' ? 'asc' : 'desc';

    // Update sort state
    if (!sortingState[fileDataSection.fileName]) sortingState[fileDataSection.fileName] = {};
    if (!sortingState[fileDataSection.fileName][sheetName]) sortingState[fileDataSection.fileName][sheetName] = {};
    sortingState[fileDataSection.fileName][sheetName][columnIndex] = nextSortState;

    // Reset header indicators
    headers.forEach(th => {
        th.classList.remove('sorted-asc', 'sorted-desc');
    });
    headers[columnIndex]?.classList.add(nextSortState === 'asc' ? 'sorted-asc' : 'sorted-desc');

    // Get column type info
    const dateTimeInfo = fileDataSection.dateTimeInfo?.[sheetName];
    const isDateColumn = dateTimeInfo?.dateColumns?.includes(columnIndex);

    // --- Get all rows (including hidden ones) ---
    const allRows = Array.from(tableBody.querySelectorAll('tr'));

    // Sort all rows
    const sortedRows = allRows.sort((a, b) => {
        const cellA = a.cells[columnIndex];
        const cellB = b.cells[columnIndex];
        if (!cellA || !cellB) return 0;

        const valA = cellA.textContent.trim();
        const valB = cellB.textContent.trim();
        let comparison = 0;

        if (isDateColumn) {
            const dateA = parseDate(valA);
            const dateB = parseDate(valB);
            if (dateA && dateB) {
                comparison = dateA - dateB;
            } else if (dateA) {
                comparison = 1;
            } else if (dateB) {
                comparison = -1;
            } else {
                comparison = valA.localeCompare(valB);
            }
        } else if (valA !== '' && valB !== '') {
            const numA = parseFormattedNumber(valA);
            const numB = parseFormattedNumber(valB);
            if (numA !== null && numB !== null) {
                comparison = numA - numB;
            } else {
                const floatA = parseFloat(valA);
                const floatB = parseFloat(valB);
                if (!isNaN(floatA) && !isNaN(floatB)) {
                    comparison = floatA - floatB;
                } else {
                    comparison = valA.localeCompare(valB);
                }
            }
        } else {
            if (valA === '' && valB === '') comparison = 0;
            else if (valA === '') comparison = 1;
            else comparison = -1;
        }

        return nextSortState === 'desc' ? -comparison : comparison;
    });

    // Re-append sorted rows to update DOM order
    sortedRows.forEach(row => tableBody.appendChild(row));

    // ✅ Re-apply the current filter after sorting
    if (Object.keys(searchTerms).length > 0) {
        // Simulate filter re-apply using existing function
        filterTableData(fileDataSection.fileName, sheetName, table, searchTerms, fileDataSection);
    } else if (fileDataSection.currentAdvancedFilterActive) {
        // If advanced filter was applied, re-apply it
        applyAdvancedFilter(fileDataSection);
    } else {
        // No filter: just notify pagination system with all sorted rows
        if (typeof fileDataSection.currentFilterCallback === 'function') {
            fileDataSection.currentFilterCallback(sortedRows);
        }
    }

    showStatus(`Sorted column ${columnIndex + 1} ${nextSortState === 'asc' ? 'ascending' : 'descending'}`, 'success');
}

    function loadSheetData(sheetName, fileDataSection, sheetTabsContainer, tableHeader, tableBody, columnControls, fileName) {
    // 1. Update active tab
    updateActiveTab(sheetTabsContainer, sheetName);

    // 2. Lazy-load workbook if not already parsed
    if (!fileDataSection.workbook) {
        try {
            fileDataSection.workbook = XLSX.read(fileDataSection.fileDataArrayBuffer, {
                type: 'array',
                cellDates: false,
                cellNF: true,
                cellText: true
            });
        } catch (err) {
            showStatus(`Failed to parse workbook for ${fileName}.`, 'error');
            return;
        }
    }
    const workbook = fileDataSection.workbook;
    const worksheet = workbook.Sheets[sheetName];
    if (!worksheet) {
        tableBody.innerHTML = '<tr><td colspan="100">Sheet data not found.</td></tr>';
        return;
    }

    // 3. Extract data
    const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: '' });
    if (jsonData.length === 0) {
        renderEmptyState(tableHeader, tableBody, columnControls);
        return;
    }

    const headers = jsonData[0];

    // 4. Render UI Components
    renderTableHeader(headers, tableHeader, fileDataSection, fileName, sheetName);
    renderTableBody(headers, jsonData, worksheet, tableBody);
    initializeColumnControls(headers, columnControls, fileName, sheetName, tableHeader, tableBody);

    // 5. Apply visibility, sorting, and filtering
    applyHiddenColumns(fileName, sheetName, tableHeader, tableBody);
    applySavedSortState(headers, tableHeader, fileDataSection, fileName, sheetName);
    reapplyFilters(fileDataSection, fileName, sheetName, tableHeader, tableBody);

    // 6. Setup Pagination & Stats
    setupPaginationAndStats(fileDataSection, tableBody);

    // 7. Setup Advanced Search (rebind or create)
    setupAdvancedSearch(fileDataSection, headers);

    // 8. Add Export Controls (if not already present)
    if (!fileDataSection.querySelector('.export-controls')) {
        addExportControls(fileDataSection);
    }
}

function updateActiveTab(sheetTabsContainer, sheetName) {
    sheetTabsContainer.querySelectorAll('.sheet-tab').forEach(tab => {
        tab.classList.toggle('active', tab.textContent === sheetName);
    });
}
function renderEmptyState(tableHeader, tableBody, columnControls) {
    tableHeader.innerHTML = '';
    tableBody.innerHTML = '<tr><td colspan="100">No data available</td></tr>';
    columnControls.innerHTML = '';
}
function renderTableHeader(headers, tableHeader, fileDataSection, fileName, sheetName) {
    tableHeader.innerHTML = '';
    const headerRow = document.createElement('tr');
    const searchTerms = {};

    headers.forEach((header, index) => {
        const th = document.createElement('th');
        th.dataset.columnIndex = index;

        const headerContainer = document.createElement('div');
        headerContainer.style.display = 'flex';
        headerContainer.style.flexDirection = 'column';

        const headerText = document.createElement('div');
        headerText.textContent = header || `Column ${index}`;
        headerContainer.appendChild(headerText);

        const searchInput = document.createElement('input');
        searchInput.type = 'text';
        searchInput.placeholder = 'Search...';
        searchInput.style.cssText = `
            width: 100%; padding: 5px; margin-top: 5px; border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background-color: rgba(255, 255, 255, 0.1); color: white;
        `;
        searchInput.addEventListener('input', function () {
            const colIndex = parseInt(th.dataset.columnIndex);
            if (this.value.trim() === '') {
                delete searchTerms[colIndex];
            } else {
                searchTerms[colIndex] = this.value;
            }
            filterTableData(fileName, sheetName, tableHeader.closest('table'), searchTerms, fileDataSection);
        });
        headerContainer.appendChild(searchInput);
        th.appendChild(headerContainer);

        // Sort on click
        th.addEventListener('click', function (e) {
            if (e.target !== searchInput) {
                sortTableData(fileDataSection, index, sheetName);
            }
        });

        headerRow.appendChild(th);
    });
    tableHeader.appendChild(headerRow);
}
function renderTableBody(headers, jsonData, worksheet, tableBody) {
    tableBody.innerHTML = '';
    for (let i = 1; i < jsonData.length; i++) {
        const row = document.createElement('tr');
        const rowData = jsonData[i];
        headers.forEach((_, cellIndex) => {
            const td = document.createElement('td');
            let displayText = '';
            const cellAddress = XLSX.utils.encode_cell({ r: i, c: cellIndex });
            const cell = worksheet[cellAddress];
            if (cell) {
                displayText = cell.w !== undefined ? cell.w : cell.v;
            } else {
                displayText = rowData[cellIndex] || '';
            }
            td.textContent = displayText;
            row.appendChild(td);
        });
        tableBody.appendChild(row);
    }
}
function initializeColumnControls(headers, columnControls, fileName, sheetName, tableHeader, tableBody) {
    if (!hidden[fileName][sheetName]) hidden[fileName][sheetName] = [];
    columnControls.innerHTML = '';
    headers.forEach((header, index) => {
        const headerText = header || `Column ${index}`;
        const btn = document.createElement('button');
        btn.className = 'column-control-btn';
        btn.textContent = headerText;
        btn.dataset.columnIndex = index;
        if (hidden[fileName][sheetName].includes(headerText)) btn.classList.add('hidden');
        btn.addEventListener('click', function () {
            toggleColumnVisibility(index, headerText, fileName, sheetName, tableHeader, tableBody);
            this.classList.toggle('hidden');
        });
        columnControls.appendChild(btn);
    });
}
function applySavedSortState(headers, tableHeader, fileDataSection, fileName, sheetName) {
    const sortState = sortingState[fileName]?.[sheetName];
    if (!sortState) return;

    Object.keys(sortState).forEach(colIndexStr => {
        const colIndex = parseInt(colIndexStr);
        const state = sortState[colIndex];
        const th = tableHeader.querySelector(`th[data-column-index="${colIndex}"]`);
        if (th) {
            th.classList.remove('sorted-asc', 'sorted-desc');
            th.classList.add(state === 'asc' ? 'sorted-asc' : 'sorted-desc');
        }
    });
}
function reapplyFilters(fileDataSection, fileName, sheetName, tableHeader, tableBody) {
    const searchInputs = tableHeader.querySelectorAll('input');
    const searchTerms = {};
    searchInputs.forEach(input => {
        const th = input.parentElement.parentElement;
        const colIndex = th.dataset.columnIndex;
        if (input.value.trim()) {
            searchTerms[colIndex] = input.value;
        }
    });

    if (Object.keys(searchTerms).length > 0) {
        filterTableData(fileName, sheetName, tableHeader.closest('table'), searchTerms, fileDataSection);
    } else if (fileDataSection.currentAdvancedFilterActive) {
        applyAdvancedFilter(fileDataSection);
    } else {
        const allRows = Array.from(tableBody.querySelectorAll('tr'));
        if (typeof fileDataSection.currentFilterCallback === 'function') {
            fileDataSection.currentFilterCallback(allRows);
        }
    }
}
function setupPaginationAndStats(fileDataSection, tableBody) {
    const tableStats = fileDataSection.querySelector('.table-stats');
    const rowCountEl = tableStats.querySelector('.row-count');
    const paginationControls = tableStats.querySelector('.pagination-controls');
    const prevBtn = paginationControls.querySelector('.prev-page');
    const nextBtn = paginationControls.querySelector('.next-page');
    const pageInfo = paginationControls.querySelector('.page-info');

    const allRows = Array.from(tableBody.querySelectorAll('tr'));
    let filteredRows = [...allRows];
    let currentPage = 1;
    const rowsPerPage = 25;

    function updateStats() {
        const total = allRows.length;
        const visible = filteredRows.length;
        const totalPages = Math.ceil(visible / rowsPerPage);
        const start = (currentPage - 1) * rowsPerPage + 1;
        const end = Math.min(start + rowsPerPage - 1, visible);
        rowCountEl.textContent = `Total: ${total} | Displayed: ${visible}`;
        pageInfo.textContent = visible === 0 ? 'Page 0' : `Page ${currentPage} of ${totalPages} (${start}–${end})`;
        prevBtn.disabled = currentPage === 1;
        nextBtn.disabled = currentPage === totalPages || totalPages === 0;
    }

    function renderPage() {
        allRows.forEach(row => (row.style.display = 'none'));
        const start = (currentPage - 1) * rowsPerPage;
        const end = start + rowsPerPage;
        filteredRows.slice(start, end).forEach(row => (row.style.display = ''));
        updateStats();
    }

    function onFilterChange(filteredVisibleRows) {
        filteredRows = filteredVisibleRows;
        fileDataSection.filteredRows = filteredVisibleRows; // For export
        currentPage = 1;
        renderPage();
    }

    fileDataSection.currentFilterCallback = onFilterChange;

    prevBtn.addEventListener('click', () => {
        if (currentPage > 1) {
            currentPage--;
            renderPage();
        }
    });

    nextBtn.addEventListener('click', () => {
        const totalPages = Math.ceil(filteredRows.length / rowsPerPage);
        if (currentPage < totalPages) {
            currentPage++;
            renderPage();
        }
    });

    updateStats();
    renderPage();
}
function setupAdvancedSearch(fileDataSection, headers) {
    const advancedSearchContainer = fileDataSection.querySelector('.advanced-search-container');
    if (!advancedSearchContainer) {
        addAdvancedSearchControls(fileDataSection);
        return;
    }

    const conditionGroups = advancedSearchContainer.querySelectorAll('.condition-group');
    conditionGroups.forEach(group => {
        const select = group.querySelector('.column-name');
        if (select) {
            const prevValue = select.value;
            select.innerHTML = '';
            headers.forEach(h => {
                const opt = document.createElement('option');
                opt.value = h;
                opt.textContent = h;
                select.appendChild(opt);
            });
            if (Array.from(select.options).some(o => o.value === prevValue)) {
                select.value = prevValue;
            }
        }
    });

    setupConditionEvents(advancedSearchContainer, fileDataSection);
}

    function clearAllData() {
        dataSectionContainer.innerHTML = '';
        hidden = {};
        sortingState = {};
        fileInput.value = '';
        fileText.textContent = 'Drag & drop files here or click to browse';
        uploadBtn.disabled = true;
        fileList.innerHTML = '';
        showStatus('All data cleared', 'success');
    }
    
    function toggleColumnVisibility(columnIndex, columnName, fileName, sheetName, tableHeader, tableBody) {
        if (!hidden[fileName][sheetName]) hidden[fileName][sheetName] = [];
        const idx = hidden[fileName][sheetName].indexOf(columnName);
        if (idx > -1) {
            hidden[fileName][sheetName].splice(idx, 1);
        } else {
            hidden[fileName][sheetName].push(columnName);
        }
        applyHiddenColumns(fileName, sheetName, tableHeader, tableBody);
        showStatus(`Column "${columnName}" ${hidden[fileName][sheetName].includes(columnName) ? 'hidden' : 'shown'}`, 'success');
    }
    
    function applyHiddenColumns(fileName, sheetName, tableHeader, tableBody) {
        const headerCells = Array.from(tableHeader.querySelectorAll('th'));
        const bodyRows = tableBody.querySelectorAll('tr');
        bodyRows.forEach(row => row.querySelectorAll('td').forEach(td => td.classList.remove('hidden-column')));
        headerCells.forEach(th => th.classList.remove('hidden-column'));
        
        if (hidden[fileName] && hidden[fileName][sheetName]) {
            hidden[fileName][sheetName].forEach(colName => {
                const colIndex = headerCells.findIndex(th => th.textContent.trim() === colName);
                if (colIndex !== -1) {
                    headerCells[colIndex].classList.add('hidden-column');
                    bodyRows.forEach(row => {
                        const cells = row.querySelectorAll('td');
                        if (cells[colIndex]) cells[colIndex].classList.add('hidden-column');
                    });
                }
            });
        }
    }
    
    function parseDate(value) {
        if (!value || typeof value !== 'string') return null;
        value = value.trim();
        // Handle ISO formats, slashes, dashes
        const date = new Date(value);
        return isNaN(date.getTime()) ? null : date;
    }
    
    function filterTableData(fileName, sheetName, table, searchTerms, fileDataSection) {
    const bodyRows = Array.from(table.querySelector('tbody').querySelectorAll('tr'));
    const headers = Array.from(table.querySelector('thead').querySelectorAll('th'));
    const lowerCaseSearchTerms = {};
    Object.keys(searchTerms).forEach(k => {
        if (searchTerms[k]) lowerCaseSearchTerms[k] = searchTerms[k].toLowerCase();
    });

    const filteredRows = bodyRows.filter(row => {
        const cells = row.querySelectorAll('td');
        let matches = true;
        Object.keys(lowerCaseSearchTerms).forEach(colIndex => {
            const term = lowerCaseSearchTerms[colIndex];
            if (colIndex < cells.length) {
                const text = (cells[colIndex].textContent || '').toLowerCase();
                if (!text.includes(term)) matches = false;
            }
        });
        return matches;
    });

    // Hide all rows first
    bodyRows.forEach(row => (row.style.display = 'none'));

    // Notify pagination system
    if (fileDataSection && typeof fileDataSection.currentFilterCallback === 'function') {
        fileDataSection.currentFilterCallback(filteredRows);
    } else {
        // Fallback: just show filtered
        filteredRows.forEach(row => (row.style.display = ''));
    }

    showStatus(`Filtered: ${filteredRows.length} rows match`, 'success');
}
    function showStatus(message, type) {
        statusDiv.textContent = message;
        statusDiv.className = `status ${type}`;
    }

    function addExportControls(fileDataSection) {
        // Create export controls container
        const exportControls = document.createElement('div');
        exportControls.className = 'export-controls';
        exportControls.style.cssText = `
            display: flex;
            gap: 10px;
            margin: 15px 0;
            flex-wrap: wrap;
        `;
        
        // Export full file button
        const exportFullBtn = document.createElement('button');
        exportFullBtn.className = 'export-btn full-data';
        exportFullBtn.textContent = 'Export Full File';
        exportFullBtn.style.cssText = `
            background: linear-gradient(to right, #4facfe, #00f2fe);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
        `;
        
        // Export visible data button
        const exportVisibleBtn = document.createElement('button');
        exportVisibleBtn.className = 'export-btn visible-data';
        exportVisibleBtn.textContent = 'Export Visible Data as CSV';
        exportVisibleBtn.style.cssText = `
            background: rgba(79, 172, 254, 0.3);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
        `;
        
        // Add buttons to container
        exportControls.appendChild(exportFullBtn);
        exportControls.appendChild(exportVisibleBtn);
        
        // Add event listeners
        exportFullBtn.addEventListener('click', () => {
            exportFileData(fileDataSection, 'full');
        });
        
        exportVisibleBtn.addEventListener('click', () => {
            exportFileData(fileDataSection, 'visible');
        });
        
        // Add export controls to the file data section
        const sheetData = fileDataSection.querySelector('.sheet-data');
        sheetData.parentNode.insertBefore(exportControls, sheetData);
        
        return exportControls;
    }
    
    function exportFileData(fileDataSection, exportType) {
        const fileName = fileDataSection.fileName;
        const activeTab = fileDataSection.querySelector('.sheet-tab.active');
        if (!activeTab) return;
        
        const sheetName = activeTab.textContent;
        
        try {
            // Get the workbook
            if (!fileDataSection.workbook) {
                showStatus('Loading workbook data...', 'success');
                fileDataSection.workbook = XLSX.read(fileDataSection.fileDataArrayBuffer, { 
                    type: 'array', 
                    cellDates: true,
                    cellNF: true,
                    cellText: true
                });
            }
            
            const workbook = fileDataSection.workbook;
            const worksheet = workbook.Sheets[sheetName];
            
            if (!worksheet) {
                showStatus('Could not find worksheet data.', 'error');
                return;
            }
            
            if (exportType === 'visible') {
                // Export only visible data (filtered and paginated)
                exportVisibleDataAsCSV(fileDataSection, sheetName, fileName);
            } else {
                // Export the full original file
                exportFullFile(workbook, fileName);
            }
        } catch (error) {
            console.error('Export error:', error);
            showStatus(`Export failed: ${error.message}`, 'error');
        }
    }

    function exportVisibleDataAsCSV(fileDataSection, sheetName, originalFileName) {
    const tableBody = fileDataSection.querySelector('tbody');
    const tableHeader = fileDataSection.querySelector('thead');

    // Get headers (only non-hidden columns)
    const headers = Array.from(tableHeader.querySelectorAll('th'))
        .filter(th => !th.classList.contains('hidden-column'))
        .map(th => {
            const text = th.textContent.split('\n')[0]; // Remove search input line
            return text.trim();
        });

    // ✅ Use the full filteredRows list instead of DOM visibility
    let filteredRows = Array.from(tableBody.querySelectorAll('tr'));
    
    // Check if pagination system has a filtered list
    if (fileDataSection.filteredRows && Array.isArray(fileDataSection.filteredRows)) {
        filteredRows = fileDataSection.filteredRows;
    } else {
        // Fallback: use all rows (unfiltered)
        console.warn("No filteredRows found, exporting all data.");
    }

    // Extract data from all filtered rows
    const csvData = [];
    csvData.push(headers); // Header row

    filteredRows.forEach(row => {
        const rowData = [];
        const cells = row.querySelectorAll('td');
        Array.from(tableHeader.querySelectorAll('th')).forEach((th, index) => {
            if (!th.classList.contains('hidden-column') && cells[index]) {
                rowData.push(cells[index].textContent.trim());
            }
        });
        csvData.push(rowData);
    });

    // Convert to CSV string
    const csvString = csvData.map(row =>
        row.map(cell => {
            // Escape quotes and wrap if needed
            const escaped = String(cell).replace(/"/g, '""');
            return /[",\r\n]/.test(escaped) ? `"${escaped}"` : escaped;
        }).join(',')
    ).join('\n');

    // Create download
    const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    const url = URL.createObjectURL(blob);
    const baseName = originalFileName.replace(/\.[^/.]+$/, "");
    link.setAttribute('href', url);
    link.setAttribute('download', `${baseName}_${sheetName}_filtered_data.csv`);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);

    showStatus(`Exported ${filteredRows.length} filtered/sorted rows as CSV`, 'success');
}

    function exportFullFile(workbook, originalFileName) {
        try {
            // Use SheetJS to write the workbook
            const wbout = XLSX.write(workbook, { 
                bookType: 'xlsx', 
                type: 'array',
                cellDates: true 
            });
            
            // Create blob and download
            const blob = new Blob([wbout], { 
                type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' 
            });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            
            link.setAttribute('href', url);
            link.setAttribute('download', originalFileName);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            showStatus('Full file exported successfully', 'success');
        } catch (error) {
            console.error('Full file export error:', error);
            showStatus('Failed to export full file', 'error');
        }
    }

    window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
